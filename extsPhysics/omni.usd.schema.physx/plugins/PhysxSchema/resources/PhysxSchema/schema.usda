#usda 1.0
(
    subLayers = [
    @usdGeom/schema.usda@,
    @usdPhysics/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
    string libraryName = "physxSchema"
    string libraryPath = "./"
    string libraryPrefix = "PhysxSchema"
        dictionary libraryTokens = {
        dictionary triangleMesh = {
            string doc = """
            This token represents the collection name to use
            with PhysxCookedDataAPI to represent cooked data
            of a TriangleMesh.
            """
            }        
        dictionary convexHull = {
            string doc = """
            This token represents the collection name to use
            with PhysxCookedDataAPI to represent cooked data
            of a convexhull.
            """
            }        
        dictionary convexDecomposition = {
            string doc = """
            This token represents the collection name to use
            with PhysxCookedDataAPI to represent cooked data
            of a convexDecomposition.
            """
            }
        dictionary sdf = {
            string doc = """
            This token represents the SDF triangle mesh
            approximation.
            """
            }
        dictionary sphereFill = {
            string doc = """
            This token represents sphere fill approximation.
            """
            }
        dictionary clothConstaint = {
            string doc = """
            This token represents the collection name to use
            with PhysxCookedDataAPI to represent cooked data
            of a clothConstaint.
            """
            }
        dictionary physxCollisionCustomGeometry = {
            string doc = """
            This token represents the custom geometry option for
            cones and cylinders. The simulation will not use a convex
            approximation but a custom geometry instead.
            """
            }
        dictionary brakes0 = {
            string doc = """
            This token represents braking system 0 used in
            PhysxVehicleBrakesAPI. It also holds the instance name
            to use for PhysxVehicleNonlinearCommandResponseAPI when
            applied to braking system 0.
            """
            }
        dictionary brakes1 = {
            string doc = """
            This token represents braking system 1 used in
            PhysxVehicleBrakesAPI. It also holds the instance name
            to use for PhysxVehicleNonlinearCommandResponseAPI when
            applied to braking system 1.
            """
            }
        dictionary referenceFrameIsCenterOfMass = {
            string value = "physxVehicle:referenceFrameIsCenterOfMass"
            string doc = """
            This token represents a boolean custom metadata
            attribute that defines whether some vehicle wheel attachment
            properties are defined relative to the vehicle prim coordinate
            frame or relative to the vehicle center of mass coordinate frame.
            The affected properties are: suspensionTravelDirection,
            suspensionFramePosition, suspensionFrameOrientation,
            suspensionForceAppPointOffset, wheelCenterOfMassOffset and
            tireForceAppPointOffset. This custom metadata can be set on the
            prim that has PhysxVehicleAPI applied. Note that using the center
            of mass frame as reference (=True) is deprecated and will not be
            supported for much longer.
            """
            }
        dictionary steer = {
            string doc = """
            This token holds the instance name to use for
            PhysxVehicleNonlinearCommandResponseAPI when applying it to
            the steering system.
            """
            }
        dictionary drive = {
            string doc = """
            This token holds the instance name to use for
            PhysxVehicleNonlinearCommandResponseAPI when applying it to
            a basic drive.
            """
            }
        }
    }
)
{

}


//-----------------------------------------------------------------------------
// Independent physics schema definitions that are not yet ready to be a part of PhysicsSchema
//-----------------------------------------------------------------------------

class TetrahedralMesh "TetrahedralMesh"
(
    customData = {
        string className = "TetrahedralMesh"
    }

    doc = """Describes a tetrahedral mesh in 3D space."""
    # Inherits from </PointBased> defined in usdGeom/schema.usda.
    inherits = </PointBased>
)  
{
    int[] indices (
        customData = {
            string apiName = "indices"
        }
        displayGroup = "Advanced"
        displayName = "Indices"
        doc = """Flat list of the index (into the 'points' attribute) of each vertex of each tetrahedron in the mesh."""
    )
}

//-----------------------------------------------------------------------------
// PhysX engine dependent properties
//-----------------------------------------------------------------------------


class "PhysxSceneAPI"
(
    doc = """PhysX scene extended parameters.
    Default PhysX material for the scene can be set by using material bind with purpose physics onto the PhysicsScene prim."""
    inherits = </APISchemaBase>
)
{
    float physxScene:bounceThreshold = 0.2  (
        customData = {
            string apiName = "bounceThreshold"
        }

        displayGroup = "Advanced"
        displayName = "Bounce Threshold"
        doc = """A contact with a relative velocity below this will not bounce.
            Range: [0, inf)
            Default: 0.2 * tolerancesSpeed
            Units: distance / seconds"""
   )

    float physxScene:frictionOffsetThreshold = 0.04 (
        customData = {
            string apiName = "frictionOffsetThreshold"
        }

        displayGroup = "Advanced"
        displayName = "Friction Offset Threshold"
        doc = """A threshold of contact separation distance used to decide if a contact point will experience friction forces.
            Range: [0, inf)
            Default: 0.04 * tolerancesLength
            Units: distance"""
   )

    float physxScene:frictionCorrelationDistance = 0.025 (
        customData = {
            string apiName = "frictionCorrelationDistance"
        }

        displayGroup = "Advanced"
        displayName = "Friction Correlation Distance"
        doc = """Friction correlation distance used to decide whether contacts are close enough to be merged into a single friction anchor point or not.
            Range: [0, inf)
            Default: 0.025 * tolerancesLength
            Units: distance"""
   )

       float physxScene:maxBiasCoefficient = inf (
        customData = {
            string apiName = "maxBiasCoefficient"
        }

        displayGroup = "Advanced"
        displayName = "Maximum Bias Coefficient"
        doc = """The maximum bias coefficient used in the constraint solver.
            Range: [0, inf)
            Units: dimensionless"""
   )

    uniform token physxScene:collisionSystem = "PCM" (
        allowedTokens = ["PCM", "SAT"]
        customData = {
            string apiName = "collisionSystem"
        }

        displayName = "Collision System"
        doc = """Collision detection system."""
    )  

    uniform token physxScene:solverType = "TGS" (
        allowedTokens = ["PGS", "TGS"]
        customData = {
            string apiName = "solverType"
        }

        displayName = "Solver Type"
        doc = """Solver used for the simulation."""
    )  

    uniform token physxScene:broadphaseType = "GPU" (
        allowedTokens = ["GPU", "MBP", "SAP"]
        customData = {
            string apiName = "broadphaseType"
        }

        displayName = "Broadphase Type"
        doc = """Broad phase algorithm used in the simulation."""
    )

    uniform token physxScene:frictionType = "patch" (
        allowedTokens = ["patch", "oneDirectional", "twoDirectional"]
        customData = {
            string apiName = "frictionType"
        }

        displayGroup = "Advanced"
        displayName = "Friction Type"
        doc = """Friction type used in simulation.
                 
                 Note: "oneDirectional" is deprecated."""
    )

    bool physxScene:enableCCD = false (
        customData = {
            string apiName = "enableCCD"
        }

        displayName = "Enable CCD"
        doc = """Enables a second broad phase check after integration that makes it possible to prevent objects from tunneling through each other."""
   )

    bool physxScene:enableStabilization = false (
        customData = {
            string apiName = "enableStabilization"
        }

        displayGroup = "Advanced"
        displayName = "Enable Stabilization"
        doc = """Enables additional stabilization pass in solver."""
   )

   uniform token physxScene:updateType = "Synchronous" (
        allowedTokens = [ "Synchronous", "Asynchronous", "Disabled"]
        customData = {
            string apiName = "updateType"
        }

        displayGroup = "Advanced"
        displayName = "Update Type"
        doc = """Type of update for a PhysX scene."""
    )

    bool physxScene:enableGPUDynamics = true (
        customData = {
            string apiName = "enableGPUDynamics"
        }

        displayName = "Enable GPU Dynamics"
        doc = """Enables the GPU dynamics pipeline. Required for GPU only features like deformables."""
   )

    bool physxScene:enableEnhancedDeterminism = false (
        customData = {
            string apiName = "enableEnhancedDeterminism"
        }

        displayGroup = "Advanced"
        displayName = "Enable Enhanced Determinism"
        doc = """Provides improved determinism at the expense of performance."""
   )

       bool physxScene:enableSceneQuerySupport = true (
        customData = {
            string apiName = "enableSceneQuerySupport"
        }

        displayGroup = "Advanced"
        displayName = "Enable Scene Query Support"
        doc = """Enables scene query support for collision shapes."""
   )

    uint physxScene:timeStepsPerSecond = 60 (
        customData = {
            string apiName = "timeStepsPerSecond"
        }

        displayName = "Time Steps Per Second"        
        doc = """Simulation scene step defined as number of steps per second.
        Note that application might cap the number of simulation steps to avoid
        running more simulations steps with a low frame rate."""
   )

    uint physxScene:gpuTempBufferCapacity = 16777216 (
        customData = {
            string apiName = "gpuTempBufferCapacity"
        }

        displayName = "Gpu Temp Buffer Capacity"
        displayGroup = "Gpu"
        doc = """Gpu temp buffer capacity."""
   )

    uint physxScene:gpuMaxRigidContactCount = 524288 (
        customData = {
            string apiName = "gpuMaxRigidContactCount"
        }

        displayName = "Gpu Max Rigid Contact Count"  
        displayGroup = "Gpu"
        doc = """Gpu max rigid contact count."""
   )

    uint physxScene:gpuMaxRigidPatchCount = 81920 (
        customData = {
            string apiName = "gpuMaxRigidPatchCount"
        }

        displayName = "Gpu Max Rigid Patch Count"
        displayGroup = "Gpu"
        doc = """Gpu max rigid patch count."""
   )

    uint physxScene:gpuHeapCapacity = 67108864 (
        customData = {
            string apiName = "gpuHeapCapacity"
        }

        displayName = "Gpu Heap Capacity"
        displayGroup = "Gpu"
        doc = """Gpu heap capacity."""
   )

    uint physxScene:gpuFoundLostPairsCapacity = 262144 (
        customData = {
            string apiName = "gpuFoundLostPairsCapacity"
        }

        displayName = "Gpu Found Lost Pairs Capacity"
        displayGroup = "Gpu"
        doc = """Gpu found lost pairs capacity."""
   )

    uint physxScene:gpuFoundLostAggregatePairsCapacity = 1024 (
        customData = {
            string apiName = "gpuFoundLostAggregatePairsCapacity"
        }

        displayName = "Gpu Found Lost Aggregate Pairs Capacity"
        displayGroup = "Gpu"
        doc = """Gpu found lost aggregate pairs capacity."""
   )

    uint physxScene:gpuTotalAggregatePairsCapacity = 1024 (
        customData = {
            string apiName = "gpuTotalAggregatePairsCapacity"
        }

        displayName = "Gpu Total Aggregate Pairs Capacity"
        displayGroup = "Gpu"
        doc = """Gpu total aggregate pairs capacity."""
   )

    uint physxScene:gpuMaxSoftBodyContacts = 1048576 (
        customData = {
            string apiName = "gpuMaxSoftBodyContacts"
        }

        displayName = "Gpu Max Softbody Contacts"
        displayGroup = "Gpu"
        doc = """Gpu max soft body contacts."""
   )

    uint physxScene:gpuMaxDeformableSurfaceContacts = 1048576 (
        customData = {
            string apiName = "gpuMaxDeformableSurfaceContacts"
        }

        displayName = "Gpu Max Deformable Surface Contacts"
        displayGroup = "Gpu"
        doc = """Gpu max deformable surface contacts."""
   )

    uint physxScene:gpuMaxParticleContacts = 1048576 (
        customData = {
            string apiName = "gpuMaxParticleContacts"
        }

        displayName = "Gpu Max Particle Contacts"
        displayGroup = "Gpu"
        doc = """Gpu max particle contacts."""
   )

	uint physxScene:gpuMaxHairContacts = 1048576 (
        customData = {
            string apiName = "gpuMaxHairContacts"
        }

        displayName = "Gpu Max Hair Contacts"
        displayGroup = "Gpu"
      doc = """Gpu max hair contacts."""
   )
   
    uint physxScene:gpuMaxNumPartitions = 8 (
        customData = {
            string apiName = "gpuMaxNumPartitions"
        }

        displayName = "Gpu Max Num Partitions"
        displayGroup = "Gpu"
        doc = """Limitation for the partitions in the GPU dynamics pipeline. This variable must be a power of 2. A value greater than 32 is currently not supported."""
   )

   uint physxScene:gpuCollisionStackSize = 67108864 (
        customData = {
            string apiName = "gpuCollisionStackSize"
        }

        displayName = "Gpu Collision Stack Size"
        displayGroup = "Gpu"
        doc = """Gpu collision stack size."""
   )

    bool physxScene:invertCollisionGroupFilter = false (
        customData = {
            string apiName = "invertCollisionGroupFilter"
        }

        displayName = "Inverted Collision Group Filter"
        doc = """Boolean attribute indicating whether inverted collision group filtering should be used.
        By default two collisions, that do have a collisionGroup set, collide with each other. Adding
        a collisionGroup into a collisionGroup filtering will mean that the collision between those groups
        will be disabled. This boolean attribute does invert the default behavior. Hence two collisions with
        defined collisionGroups will not collide with each other by default and one does enable the
        collisions between the groups through the "CollisionGroup" filtering."""
    )

    bool physxScene:reportKinematicKinematicPairs = false (
        customData = {
            string apiName = "reportKinematicKinematicPairs"
        }

        displayName = "Report Kinematic vs Kinematic Pairs"
        doc = """Boolean attribute indicating whether kinematic vs kinematic pairs
        generate contact reports."""
    )

    bool physxScene:reportKinematicStaticPairs = false (
        customData = {
            string apiName = "reportKinematicStaticPairs"
        }

        displayName = "Report Kinematic vs Static Pairs"
        doc = """Boolean attribute indicating whether kinematic vs static pairs
        generate contact reports."""
    )

    uniform uint physxScene:minPositionIterationCount = 1 (
    customData = {
        string apiName = "minPositionIterationCount"
    }
        displayName = "Minimum Position Iteration Count"
        doc = """Minimum position iteration count for all actors (rigid bodies, cloth, particles etc).
            Range: [1, 255]"""
    )

    uniform uint physxScene:maxPositionIterationCount = 255 (
    customData = {
        string apiName = "maxPositionIterationCount"
    }
        displayName = "Maximum Position Iteration Count"
        doc = """Maximum position iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations.
            Range: [1, 255]"""
    )

    uniform uint physxScene:minVelocityIterationCount = 0 (
    customData = {
        string apiName = "minVelocityIterationCount"
    }
        displayName = "Minimum Velocity Iteration Count"
        doc = """Minimum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
            Range: [0, 255]"""
    )

    uniform uint physxScene:maxVelocityIterationCount = 255 (
    customData = {
        string apiName = "maxVelocityIterationCount"
    }
        displayName = "Maximum Velocity Iteration Count"
        doc = """Maximum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations.
            Range: [0, 255]"""
    )

}

class "PhysxRigidBodyAPI"
(
    doc = """PhysX rigid body extended parameters"""
   inherits = </APISchemaBase>
)
{
    float physxRigidBody:linearDamping = 0.0 (
        customData = {
            string apiName = "linearDamping"
        }

        displayName = "Linear Damping"
        doc = """Linear damping coefficient.
            Range: [0, inf)
            Units: dimensionless"""
   )

    float physxRigidBody:angularDamping = 0.05 (
        customData = {
            string apiName = "angularDamping"
        }

        displayName = "Angular Damping"
        doc = """Angular damping coefficient.
            Range: [0, inf)
            Units: dimensionless"""
   )

    float physxRigidBody:maxLinearVelocity = inf (
        customData = {
            string apiName = "maxLinearVelocity"
        }

        displayName = "Max Linear Velocity"
        doc = """Maximum allowable linear velocity for the rigid body.
            Range: [0, inf)
            Units: distance / seconds"""
   )

    float physxRigidBody:maxAngularVelocity = 5729.58 (
        customData = {
            string apiName = "maxAngularVelocity"
        }

        displayName = "Max Angular Velocity"
        doc = """Maximum allowable angular velocity for rigid body.
            Range: [0, inf)
            Units: degrees / seconds"""
   )

    float physxRigidBody:sleepThreshold = 0.00005 (
        customData = {
            string apiName = "sleepThreshold"
        }

        displayName = "Sleep Threshold"
        doc = """Mass-normalized kinetic energy threshold below which an actor may go to sleep.
            Range: [0, inf)
            Default: 0.00005 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
   )

    float physxRigidBody:stabilizationThreshold = 0.00001 (
        customData = {
            string apiName = "stabilizationThreshold"
        }

        displayGroup = "Advanced"
        displayName = "Stabilization Threshold"
        doc = """Mass-normalized kinetic energy threshold below which an actor may participate in stabilization.
            Range: [0, inf)
            Default: 0.00001 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
   )

    float physxRigidBody:maxDepenetrationVelocity = 3.0 (
        customData = {
            string apiName = "maxDepenetrationVelocity"
        }

        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum depenetration velocity permitted to be introduced by the solver.
            Range: [0, inf)
            Default: 5.0 * tolerancesLength
            Units: distance / seconds"""
   )

    float physxRigidBody:maxContactImpulse = inf (
        customData = {
            string apiName = "maxContactImpulse"
        }

        displayGroup = "Advanced"
        displayName = "Max Contact Impulse"
        doc = """Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic
            bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited
            by the value for the dynamic body.
            Range: [0, inf)
            Units: force * seconds = mass * distance / seconds"""
   )

    int physxRigidBody:solverPositionIterationCount = 16 (
        customData = {
            string apiName = "solverPositionIterationCount"
        }

        displayGroup = "Advanced"
        displayName = "Solver Position Iteration Count"
        doc = """Solver position iteration counts for the body. Allowed range [1, 255]."""
   )

    int physxRigidBody:solverVelocityIterationCount = 1 (
        customData = {
            string apiName = "solverVelocityIterationCount"
        }

        displayGroup = "Advanced"
        displayName = "Solver Velocity Iteration Count"
        doc = """Solver velocity iteration counts for the body. Allowed range [0, 255]."""
   )
 
    bool physxRigidBody:enableCCD = false (
        customData = {
            string apiName = "enableCCD"
        }
        
        displayName = "Enable CCD"
        doc = """Enables swept integration for the actor."""
   )

    bool physxRigidBody:enableSpeculativeCCD = false (
        customData = {
            string apiName = "enableSpeculativeCCD"
        }

        displayGroup = "Advanced"
        displayName = "Enable Speculative CCD"
        doc = """Register a rigid body to dynamically adjust contact offset based on velocity. This can be used to achieve a CCD effect."""
   )

    bool physxRigidBody:retainAccelerations = false (
        customData = {
            string apiName = "retainAccelerations"
        }

        displayGroup = "Advanced"
        displayName = "Retain Accelerations"
        doc = """Carries over forces/accelerations between frames, rather than clearing them."""
   )

    bool physxRigidBody:enableGyroscopicForces = true (
        customData = {
            string apiName = "enableGyroscopicForces"
        }

        displayGroup = "Advanced"
        displayName = "Enable Gyroscopic Forces"
        doc = """Enables computation of gyroscopic forces on the rigid body."""
   )

    bool physxRigidBody:disableGravity = false (
        customData = {
            string apiName = "disableGravity"
        }

        displayName = "Disable Gravity"
        doc = """Disable gravity for the actor."""
   )

       bool physxRigidBody:solveContact = true (
        customData = {
            string apiName = "solveContact"
        }

        displayGroup = "Advanced"
        displayName = "Solve Contact"
        doc = """Process the contacts of this rigid body in the dynamics solver."""
   )

    int physxRigidBody:lockedPosAxis = 0 (
        customData = {
            string apiName = "lockedPosAxis"
        }

        displayName = "Locked Pos Axis"
        doc = """Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2)."""
   )

    int physxRigidBody:lockedRotAxis = 0 (
        customData = {
            string apiName = "lockedRotAxis"
        }

        displayName = "Locked Rot Axis"
        doc = """Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2)."""
   )

   float physxRigidBody:contactSlopCoefficient = 0.0 (
        customData = {
            string apiName = "contactSlopCoefficient"
        }

        displayGroup = "Advanced"
        displayName = "Contact Slop Coefficient"
        doc = """Tolerance on the angular influence of a contact that can help improve the behavior of rolling approximate collision shapes.
            Specifically, the angular component of a normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance.
            The tolerance is scaled such that the behavior improvement persists through a range of angular velocities of a rolling shape.
            Range: [0, inf)
            Units: distance"""
   )

   float physxRigidBody:cfmScale = 0.025 (
        customData = {
            string apiName = "cfmScale"
        }

        displayGroup = "Advanced"
        displayName = "Constraint-force-mixing Scale"
        doc = """The cfm scale term can help stabilize an articulation by weakening the constraint's response.
            Use small values close to the default and typically in the range [0, 0.1] for best results.
            Note that this parameter is currently used only if rigid body is part of an articulation.
            Range: [0, 1]
            Units: unitless"""
   )   
}

class "PhysxContactReportAPI"
(
    doc = """Enables contact reporting for a rigid body or articulation."""
   inherits = </APISchemaBase>
)
{
    float physxContactReport:threshold = 1.0 (
        customData = {
            string apiName = "threshold"
        }

        displayName = "Contact Report Threshold"
        doc = """Sets the force threshold for contact reports.
            Range: [0, inf]
            Units: force = mass * distance / seconds^2"""
   )

   rel physxContactReport:reportPairs (
        customData = {
            string apiName = "reportPairs"
        }

        displayName = "Report Pairs"
        doc = """Relationship to objects. If in contact with these objects, contact reports will be sent. If relationship not set or list empty all contacts are reported."""
   )
}

class "PhysxCollisionAPI"
(
    doc = """PhysX collision extended parameters"""
   inherits = </APISchemaBase>
)
{
    float physxCollision:contactOffset = -inf (
        customData = {
            string apiName = "contactOffset"
        }
        displayGroup = "Advanced"
        displayName = "Contact Offset"
        doc = """Contact offset of a collision shape. Default value -inf means default is picked by the simulation based on the shape extent.
            Range: [maximum(0, restOffset), inf)
            Units: distance"""
   )

    float physxCollision:restOffset = -inf (
        customData = {
            string apiName = "restOffset"
        }

        displayGroup = "Advanced"
        displayName = "Rest Offset"
        doc = """Rest offset of a collision shape. Default value -inf means that the simulation sets a suitable value.
            For rigid bodies, this value is zero.
            Range: [0, contactOffset]
            Units: distance"""
   )

    float physxCollision:torsionalPatchRadius = 0.0 (
        customData = {
            string apiName = "torsionalPatchRadius"
        }

        displayGroup = "Advanced"
        displayName = "Torsional Patch Radius"
        doc = """Defines the radius of the contact patch used to apply torsional friction.
            Range: [0, inf)
            Units: distance"""
   )

    float physxCollision:minTorsionalPatchRadius = 0.0 (
        customData = {
            string apiName = "minTorsionalPatchRadius"
        }

        displayGroup = "Advanced"
       displayName = "Min Torsional Patch Radius"
        doc = """Defines the minimum radius of the contact patch used to apply torsional friction.
            Range: [0, inf)
            Units: distance"""
   )
}

class "PhysxConvexHullCollisionAPI"
(
    doc = """PhysX convex hull collision extended parameters"""
   inherits = </APISchemaBase>
)
{
   int physxConvexHullCollision:hullVertexLimit = 64 (
        customData = {
            string apiName = "hullVertexLimit"
        }

        displayName = "Hull Vertex Limit"
        doc = """Convex hull vertex limit used for convex hull cooking."""
   )

    float physxConvexHullCollision:minThickness = 0.001 (
        customData = {
            string apiName = "minThickness"
        }

        displayName = "Min Thickness"
        displayGroup = "Advanced"
        doc = """Convex hull minimum thickness.
            Range: [0, inf)
            Units: distance"""
   )
}

class "PhysxConvexDecompositionCollisionAPI"
(
    doc = """PhysX convex decomposition extended parameters"""
   inherits = </APISchemaBase>
)
{
   int physxConvexDecompositionCollision:hullVertexLimit = 64 (
        customData = {
            string apiName = "hullVertexLimit"
        }

        displayName = "Hull Vertex Limit"
        doc = """Convex hull vertex limit used for convex hull cooking."""
   )

    int physxConvexDecompositionCollision:maxConvexHulls = 32 (
        customData = {
            string apiName = "maxConvexHulls"
        }

        displayName = "Max Convex Hulls"
        doc = """Maximum of convex hulls created during convex decomposition."""
   )

    float physxConvexDecompositionCollision:minThickness = 0.001 (
        customData = {
            string apiName = "minThickness"
        }

        displayName = "Min Thickness"
        displayGroup = "Advanced"
        doc = """Convex hull min thickness.
            Range: [0, inf)
            Units: distance"""
   )
   
       int physxConvexDecompositionCollision:voxelResolution = 500000 (
        customData = {
            string apiName = "voxelResolution"
        }

        displayName = "Voxel Resolution"
        displayGroup = "Advanced"
        doc = """Voxel resolution used for convex decomposition."""
   )

    float physxConvexDecompositionCollision:errorPercentage = 10 (
        customData = {
            string apiName = "errorPercentage"
        }

        displayName = "Error Percentage"
        displayGroup = "Advanced"
        doc = """Convex decomposition errorPercentage parameter."""
   )

       bool physxConvexDecompositionCollision:shrinkWrap = false (
        customData = {
            string apiName = "shrinkWrap"
        }

        displayName = "Shrink Wrap"
        displayGroup = "Advanced"
        doc = """Attempts to adjust the convex hull points so that they are projected onto the surface of the original graphics mesh."""
   )

}

class "PhysxSphereFillCollisionAPI"
(
    doc = """PhysX sphere fill extended parameters"""
    inherits = </APISchemaBase>
)
{
    int physxSphereFillCollision:maxSpheres = 128 (
        customData = {
            string apiName = "maxSpheres"
        }

        displayName = "Max Spheres"
        doc = """Maximum of spheres produced. Range (2, 4000)"""
    )
   
    int physxSphereFillCollision:voxelResolution = 50000 (
        customData = {
            string apiName = "voxelResolution"
        }

        displayName = "Voxel Resolution"
        displayGroup = "Advanced"
        doc = """Voxel resolution used for the algorithm. Range (10 000, 1 000 000)"""
    )

    int physxSphereFillCollision:seedCount = 1000 (
        customData = {
            string apiName = "seedCount"
        }

        displayName = "Seed Count"
        displayGroup = "Advanced"
        doc = """Seed count used for the algorithm. Range (16, 4000)"""
    )

    uniform token physxSphereFillCollision:fillMode = "flood" (
        customData = {
            string apiName= "fillMode"
        }
        allowedTokens = ["flood", "raycast", "surface"]
        displayName = "Fill Mode"
        displayGroup = "Advanced"
        doc = """Fill mode for the the algorithm."""
    )
}

class "PhysxTriangleMeshSimplificationCollisionAPI"
(
    doc = """PhysX triangle mesh simplification extended parameters"""
   inherits = </APISchemaBase>
)
{
    float physxTriangleMeshSimplificationCollision:metric = 0.55 (
        customData = {
            string apiName = "simplificationMetric"
        }

        displayName = "Simplification Metric"
        doc = """Mesh simplification accuracy."""
   )

       float physxTriangleMeshSimplificationCollision:weldTolerance = -inf (
        customData = {
            string apiName = "weldTolerance"
        }

        displayName = "Weld Tolerance"
        displayGroup = "Advanced"
        doc = """Mesh weld tolerance, controls the distance at which vertices are welded. 
            Default -inf will autocompute the welding tolerance based on the mesh size. Zero value will disable welding.
            Range: [0, inf)
            Units: distance"""
   )
}

class "PhysxTriangleMeshCollisionAPI"
(
    doc = """PhysX triangle mesh extended parameters"""
   inherits = </APISchemaBase>
)
{
    float physxTriangleMeshCollision:weldTolerance = -inf (
        customData = {
            string apiName = "weldTolerance"
        }

        displayName = "Weld Tolerance"
        displayGroup = "Advanced"
        doc = """Mesh weld tolerance, controls the distance at which vertices are welded. 
            Default -inf will autocompute the welding tolerance based on the mesh size. Zero value will disable welding.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxSDFMeshCollisionAPI"
(
    doc = """PhysX SDF mesh extended parameters"""
   inherits = </APISchemaBase>
)
{
    uniform int physxSDFMeshCollision:sdfResolution = 256 (
        customData = {
            string apiName= "sdfResolution"
        }
        
        displayName = "SDF Resolution"
        doc = """The spacing of the uniformly sampled SDF is equal to the largest AABB extent of the mesh, divided by the resolution.
            Choose the lowest possible resolution that provides acceptable performance; very high resolution results in
            large memory consumption, and slower cooking and simulation performance.
            Range: (1, inf)"""
    )
    
    uniform int physxSDFMeshCollision:sdfSubgridResolution = 6 (
        customData = {
            string apiName= "sdfSubgridResolution"
        }
        
        displayName = "SDF Subgrid Resolution"
        displayGroup = "Advanced"
        doc = """A positive subgrid resolution enables sparsity on signed-distance-fields (SDF) while a value of 0 leads
            to the usage of a dense SDF. A value in the range of 4 to 8 is a reasonable compromise between block size and 
            the overhead introduced by block addressing. The smaller a block, the more memory is spent on the address 
            table. The bigger a block, the less precisely the sparse SDF can adapt to the mesh's surface. In most cases 
            sparsity reduces the memory consumption of a SDF significantly. 
            Range: [0, inf)"""
    )
    
    uniform token physxSDFMeshCollision:sdfBitsPerSubgridPixel = "BitsPerPixel16" (
        customData = {
            string apiName= "sdfBitsPerSubgridPixel"
        }
        allowedTokens = ["BitsPerPixel8", "BitsPerPixel16", "BitsPerPixel32"]
        displayName = "SDF Bits per Subgrid Pixel"
        displayGroup = "Advanced"
        doc = """Values of 8, 16 and 32 bits per subgrid pixel are supported. Dense SDFs always use 32 bits per pixel. The
            less bits per pixel, the smaller the resulting SDF but also the less precise. The SDF's memory consumption 
            scales proportionally with the number of bits per subgrid pixel."""
    )
    
    uniform float physxSDFMeshCollision:sdfNarrowBandThickness = 0.01 (
        customData = {
            string apiName= "sdfNarrowBandThickness"
        }
        
        displayName = "SDF Narrow Band Thickness"
        displayGroup = "Advanced"
        doc = """Size of the narrow band around the mesh surface where high resolution SDF samples are available. Outside
            of the narrow band, only low resolution samples are stored. Representing the narrow band thickness as a fraction
            of the mesh's bounding box diagonal length ensures that it is scale independent. A value of 0.01 is usually
            large enough. The smaller the narrow band thickness, the smaller the memory consumption of the sparse SDF.
            Range: [0, 1]
            Units: dimensionless"""
    )
    
    uniform float physxSDFMeshCollision:sdfMargin = 0.01 (
        customData = {
            string apiName= "sdfMargin"
        }
        
        displayName = "SDF Margin"
        displayGroup = "Advanced"
        doc = """Margin to increase the size of the SDF relative to the bounding box diagonal length of the mesh. A sdf 
            margin value of 0.01 means the sdf boundary will be enlarged in any direction by 1% of the mesh's bounding box 
            diagonal length. Representing the margin relative to the bounding box diagonal length ensures that it is scale 
            independent. Margins allow for precise distance queries in a region slightly outside of the mesh's bounding box.
            Range: [0, inf)
            Units: dimensionless"""
    )

    uniform bool physxSDFMeshCollision:sdfEnableRemeshing = false (
        customData = {
            string apiName= "sdfEnableRemeshing"
        }
        displayName = "Enable SDF Remeshing"
        displayGroup = "Advanced"
        doc = """Enables optional remeshing as a preprocessing step before the SDF is computed. Remeshing can help generate 
            valid SDF data even if the input mesh has bad properties like inconsistent winding or self-intersections. The SDF
            distances (and therefore the collisions) will be slightly less accurate when remeshing is enabled."""
    )
}


class "PhysxMaterialAPI"
(
    doc = """PhysX material extended parameters"""
   inherits = </APISchemaBase>
)
{
   uniform token physxMaterial:frictionCombineMode = "average" (
        customData = {
            string apiName = "frictionCombineMode"
        }       
        allowedTokens = ["average", "min", "multiply","max"]
        displayName = "Friction Combine Mode"
        doc = """Determines the way in which two material properties will be combined to yield a friction or restitution coefficient for a collision."""
   )  
   uniform token physxMaterial:restitutionCombineMode = "average" (
        customData = {
            string apiName = "restitutionCombineMode"
        }       
        allowedTokens = ["average", "min", "multiply","max"]
        displayName = "Restitution Combine Mode"
        doc = """Determines the way in which two material properties will be combined to yield a friction or restitution coefficient for a collision."""
   )  

    bool physxMaterial:improvePatchFriction = true (
        customData = {
            string apiName = "improvePatchFriction"
        }       
        displayName = "Improved Patch Friction"
        doc = """Flag only has an effect if physxScene:frictionType "patch" friction model is used."""
   )

    float physxMaterial:compliantContactStiffness = 0.0 (
        customData = {
            string apiName = "compliantContactStiffness"
        }

        displayGroup = "Advanced"
        displayName = "Compliant Contact Stiffness"
        doc = """Spring stiffness for a compliant contact model using implicit springs. A higher stiffness results in behavior
            closer to a rigid contact. The compliant contact model is only enabled if the stiffness is larger than 0.
            Range: [0, inf)
            Units: force/distance = mass / seconds / seconds"""
   )

   float physxMaterial:compliantContactDamping = 0.0 (
        customData = {
            string apiName = "compliantContactDamping"
        }

        displayGroup = "Advanced"
        displayName = "Compliant Contact Damping"
        doc = """Damping coefficient for a compliant contact model using implicit springs. Irrelevant if compliant contacts
            are disabled when compliantContactStiffness is set to zero and rigid contacts are active.
            Range: [0, inf)
            Units: force / (distance / seconds) = mass / seconds"""
   )
}

class PhysxPhysicsInstancer "PhysxPhysicsInstancer"
(
    doc = """Core class for instancing physics prims"""


    inherits = </Imageable>
)
{
  rel physics:prototypes (
      doc = """<b>Required property</b>. Orders and targets the prototype root
      prims, which can be located anywhere in the scenegraph that is convenient,
      although we promote organizing prototypes as children of the
      PhysxPhysicsInstancer.  The position of a prototype in this relationship defines
      the value an instance would specify in the \\em protoIndices attribute to
      instance that prototype. Since relationships are uniform, this property
      cannot be animated."""
  )


  int[] physics:protoIndices (
      doc = """<b>Required property</b>. Per-instance index into
      \\em prototypes relationship that identifies what physics prims are instanced.  <b>Topology attribute</b> - can be animated,
      but at a potential performance impact for streaming."""
  )
}


class PhysxPhysicsJointInstancer "PhysxPhysicsJointInstancer"
(
    doc = """Physics joint instancer, the prototypes are expected to be UsdPhysicsJoint prim types."""


    inherits = </PhysxPhysicsInstancer>
)
{
  rel physics:body0s (
      doc = """<b>Required property</b>. The rel must contain either exactly one 
      UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage.
      If the rel is to a point instancer, the body0Indices must be specified. 
      """
  )

  int[] physics:body0Indices (
      doc = """<b>Optional property</b>. Only applicable if body0s is a point instancer. 
      An index specifies the per-instance body0 rel as the rigid body at the body0s-instancer's protoIndices[index].
      """
  )

  rel physics:body1s (
      doc = """<b>Required property</b>. The rel must contain either exactly one 
      UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage.
      If the rel is to a point instancer, the body0Indices must be specified.
      """
  )

  int[] physics:body1Indices (
      doc = """<b>Optional property</b>. Only applicable if body0s is a point instancer. 
      An index specifies the per-instance body0 rel as the rigid body at the body0s-instancer's protoIndices[index].
      """
  )


  point3f[] physics:localPos0s (
      doc = """<b>Required property</b>. Per-instance localPos0. This transformation
      is added on top of the joint localPos0."""
  )

  quath[] physics:localRot0s (
    doc = """<b>Required property</b>. Per-instance localRot0. This transformation
      is added on top of the joint localPos0."""
  )

  point3f[] physics:localPos1s (
      doc = """<b>Required property</b>. Per-instance localPos1. This transformation
      is added on top of the joint localPos1."""
  )

  quath[] physics:localRot1s (
    doc = """<b>Required property</b>. Per-instance localRot1. This transformation
      is added on top of the joint localPos0."""
  )  
}


class PhysxPhysicsGearJoint "PhysxPhysicsGearJoint"
(
    doc = """Predefined gear joint type"""

    inherits = </PhysicsJoint>
)
{
    rel physics:hinge0 (
        customData = {
            string apiName = "hinge0"
        }       

        displayName = "Hinge 0"
        doc = """Relationship to first revolute joint."""
    )

    rel physics:hinge1 (
        customData = {
            string apiName = "hinge1"
        }       
        displayName = "Hinge 1"
        doc = """Relationship to second revolute joint."""
    )

    float physics:gearRatio = 1.0 (
        customData = {
            string apiName = "gearRatio"
        }       

        displayName = "Gear Ratio"
        doc = """Gear ratio
            Range: (-inf, inf)
            Units: dimensionless"""
    )
}

class PhysxPhysicsRackAndPinionJoint "PhysxPhysicsRackAndPinionJoint"
(
    doc = """Predefined rack & pinion joint type"""

    inherits = </PhysicsJoint>
)
{
    rel physics:hinge (
        customData = {
            string apiName = "hinge"
        }       

        displayName = "Hinge"
        doc = """Relationship to revolute joint."""
    )

    rel physics:prismatic (
        customData = {
            string apiName = "prismatic"
        }       

        displayName = "Prismatic"
        doc = """Relationship to prismatic joint."""
    )

    float physics:ratio = 1.0 (
        customData = {
            string apiName = "ratio"
        }       

        displayName = "Ratio"
        doc = """Ratio between angular and linear motion.
            Range: (-inf, inf)
            Units: degrees / distance"""
    )
}

class "PhysxJointAPI"
(
    doc = """PhysX joint extended parameters"""
   inherits = </APISchemaBase>
)
{
    bool physxJoint:enableProjection = false (
        customData = {
            string apiName = "enableProjection"
        }       

        displayGroup = "Advanced"
        displayName = "Enable Projection"
        doc = """Whether the actors should get projected for this constraint (the direction will be chosen by PhysX)."""
   )

    float physxJoint:jointFriction = 0.0 (
        customData = {
            string apiName = "jointFriction"
        }       

        displayGroup = "Advanced"
        displayName = "Joint Friction"
        doc = """Joint friction. Only applies for joints that are parts of an articulation.
            Range: [0, inf)
            Units: dimensionless"""
   )

    float physxJoint:maxJointVelocity = 1000000.0 (
        customData = {
            string apiName = "maxJointVelocity"
        }       

        displayGroup = "Advanced"
        displayName = "Maximum Joint Velocity"
        doc = """Maximum joint velocity.
            Range: [0, inf)
            Units: Linear joint - distance / time
                   Angular joint - degrees / time"""
   )

    float physxJoint:armature = 0.0 (
        customData = {
            string apiName = "armature"
        }       

        displayGroup = "Advanced"
        displayName = "Armature"
        doc = """Armature can help stabilize an articulation by adding to the inertial response of a joint.
            Conceptually, armature represents the inertia of an actuator driving the joint.
            Note that this parameter is used only when the joint belongs to an articulation.
            Range: [0, inf)
            Units: Linear joint - mass
                   Angular joint - mass * (distance)^2"""
   )
}

class "PhysxPhysicsDistanceJointAPI"
(
    doc = """PhysX distance joint extended parameters"""
   inherits = </APISchemaBase>
)
{
    bool physxPhysicsDistanceJoint:springEnabled = false (
        customData = {
            string apiName = "springEnabled"
        }       

        displayName = "Spring Enabled"
        doc = """Whether spring should be enabled. (default off)"""
   )

    float physxPhysicsDistanceJoint:springStiffness = 0.0 (
        customData = {
            string apiName = "springStiffness"
        }       

        displayName = "Spring Stiffness"
        doc = """Spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / seconds^2"""
   )

    float physxPhysicsDistanceJoint:springDamping = 0.0 (
        customData = {
            string apiName = "springDamping"
        }       

        displayName = "Spring Damping"
        doc = """Spring damping.
            Range: [0, inf)
            Units: force * seconds / distance = mass / seconds"""
   )
}

class "PhysxLimitAPI"
(
    inherits = </APISchemaBase>

    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix  = "physxLimit"
    }  
)
{
    float restitution = 0.0 (        
        displayName = "Restitution"
        doc = """Controls the amount of bounce when the joint hits a limit.
            Range: [0, inf)
            Units: dimensionless"""
   )

    float bounceThreshold = 0.0 (
        displayName = "Bounce Threshold"
        doc = """Determines the minimum impact velocity which will cause the joint to bounce.
            Range: [0, inf)
            Units: linear - distance / seconds
                   angular - degrees / seconds"""
   )

    float stiffness = 0.0 (
        displayName = "Stiffness"
        doc = """If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
            Range: [0, inf)
            Units: linear - force / distance
                   angular - torque / degrees"""
   )

    float damping = 0.0 (
        displayName = "Damping"
      doc = """If spring is greater than zero, this is the damping of the limit spring.
            Range: [0, inf)
            Units: linear - force / distance * seconds
                   angular - torque / degrees * seconds"""
   )

    float contactDistance = 0.0 (
        displayName = "Contact Distance"
        doc = """The distance inside the limit value at which the limit will be considered to be active by the solver.
            As this value is made larger, the limit becomes active more quickly. It thus becomes less likely to violate
            the extents of the limit, but more expensive.
            Range: [0, inf)
            Units: linear - distance
                   angular - degrees"""
   )
}

class "PhysicsJointStateAPI"
(
    customData = {
        string className = "JointStateAPI"
        token apiSchemaType = "multipleApply"  
        token propertyNamespacePrefix  = "state"      
    }

    doc = """The PhysicsJointStateAPI is applied to a joint primitive 
    (i.e. any PhysicsJoint-derived type) and provides read/write access 
    to the joint position and velocity for a specific joint axis.
    The PhysicsJointStateAPI is a multipleApply schema, and its instance name 
    TfToken defines the joint axis: The name can be "transX", "transY", "transZ", 
    "rotX", "rotY", "rotZ" or its "linear" for prismatic joint or "angular" 
    for revolute joints, respectively."""

    inherits = </APISchemaBase>
)
{
    float physics:position = 0.0 (
        customData = {
            string apiName = "position"
        }

        displayName = "Position"
        doc = """Joint state position defines the relative difference between
            joint body0 frame and joint body1 frame in world frame.
            Range: (-inf, inf)
            Units: linear - distance
                   angular - degrees"""
    )

    float physics:velocity = 0.0 (
        customData = {
            string apiName = "velocity"
        }

        displayName = "Velocity"
        doc = """Joint state velocity defines the relative velocity between
            joint body0 and joint body1.
            Range: (-inf, inf)
            Units: linear - distance / seconds
                   angular - degrees / seconds"""
    )    
}

class "PhysxArticulationAPI"
(
    doc = """PhysX articulation extended parameters"""
   inherits = </APISchemaBase>
)
{
    bool physxArticulation:articulationEnabled = true (
        customData = {
            string apiName = "articulationEnabled"
        }       

        displayName = "Articulation Enabled"
        doc = """Boolean defining whether articulation is enabled or disabled."""
    )

    int physxArticulation:solverPositionIterationCount = 32 (
        customData = {
            string apiName = "solverPositionIterationCount"
        }       

        displayName = "Solver Position Iteration Count"
        doc = """Solver position iteration counts for the body. Allowed range [1, 255]."""
   )

    int physxArticulation:solverVelocityIterationCount = 1 (
        customData = {
            string apiName = "solverVelocityIterationCount"
        }       

        displayName = "Solver Velocity Iteration Count"
        doc = """Solver velocity iteration counts for the body. Allowed range [0, 255]."""
   )

    float physxArticulation:sleepThreshold = 0.00005 (
        customData = {
            string apiName = "sleepThreshold"
        }       

        displayName = "Sleep Threshold"
        doc = """Mass-normalized kinetic energy threshold below which the articulation may go to sleep.
            Range: [0, inf)
            Default: 0.00005 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
   )

    float physxArticulation:stabilizationThreshold = 0.00001 (
        customData = {
            string apiName = "stabilizationThreshold"
        }       

        displayName = "Stabilization Threshold"
        doc = """The mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.
            Range: [0, inf)
            Default: 0.00001 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
   )

    bool physxArticulation:enabledSelfCollisions = true (
        customData = {
            string apiName = "enabledSelfCollisions"
        }       

        displayName = "Self Collisions Enabled"
        doc = """Boolean defining whether self collisions should be enabled or disabled."""
   )
}

class "PhysxArticulationForceSensorAPI"
(
    doc = """ WARNING: THIS API IS DEPRECATED AND WILL BE REMOVED IN A FUTURE RELEASE.
    PhysX articulation sensor to measure spatial force.
    Articulation sensor API must be applied to a UsdGeom.Xformable in order to get
    a transformation information. The UsdGeom.Xformable must be created under the
    articulated rigid body in order to compute a relative transformation between the
    body and the sensor."""
    inherits = </APISchemaBase>
)
{
    vector3f physxArticulationForceSensor:force = (0.0, 0.0, 0.0) (
        customData = {
            string apiName = "force"
        }       
 
        displayName = "Force"
        doc = """Spatial force in the local frame of the sensor computed by the simulation.
            Units: force"""
    )
    vector3f physxArticulationForceSensor:torque = (0.0, 0.0, 0.0) (
        customData = {
            string apiName = "torque"
        }       
 
        displayName = "Torque"
        doc = """Spatial torque in the local frame of the sensor computed by the simulation.
            Units: torque"""
    )
 
    bool physxArticulationForceSensor:sensorEnabled = true (
        customData = {
            string apiName = "sensorEnabled"
        }       
 
        displayName = "Force Sensor Enabled"
        doc = """Boolean defining whether sensor is enabled."""
   )
 
    bool physxArticulationForceSensor:worldFrameEnabled = false (
        customData = {
            string apiName = "worldFrameEnabled"
        }       
 
        displayName = "World Frame Force Enabled"
        doc = """Boolean defining whether reported force is in world frame."""
   )
 
    bool physxArticulationForceSensor:forwardDynamicsForcesEnabled = true (
        customData = {
            string apiName = "forwardDynamicsForcesEnabled"
        }       
 
        displayName = "Forward Dynamics Forces Enabled"
        doc = """Boolean defining whether to receive forces from forward dynamics."""
    )
 
 
    bool physxArticulationForceSensor:constraintSolverForcesEnabled = true (
        customData = {
            string apiName = "constraintSolverForcesEnabled"
        }       
 
        displayName = "Constraint Solver Forces Enabled"
        doc = """Boolean defining whether to receive forces from constraint solver."""
    )
}

class "PhysxForceAPI"
(
    doc = """PhysX schema API that applies a force and torque to a rigid body 
    (UsdGeom.Xformable with UsdPhysicsRigidBodyAPI). The API can be applied to either:
    - The rigid-body Xformable, in which case the force is applied at the body's center of mass.
    - To an UsdGeom.Xformable that is a child of the rigid-body Xformable, 
    in which case the force is applied at the location defined by the Xformable.

    The worldFrameEnabled flag defines what coordinate frame the force and torque are expressed in. 
    Note that any scale transform operations will only affect the force and torque values if on "acceleration" mode."""
    inherits = </APISchemaBase>
)
{
    bool physxForce:forceEnabled = true (
        customData = {
            string apiName = "forceEnabled"
        }      
 
        displayName = "Force Enabled"
        doc = """Boolean defining whether the force and torque are enabled or disabled."""
    )
 
    bool physxForce:worldFrameEnabled = false (
        customData = {
            string apiName = "worldFrameEnabled"        
        }      
 
        displayName = "World Frame Enabled"
        doc = """Boolean defining whether the force and torque are in world frame or in local frame."""
    )
 
    uniform token physxForce:mode = "acceleration" (
        customData = {
            string apiName = "mode"        
        }      
        allowedTokens = ["force", "acceleration"]
        displayName = "Mode"
        doc = """Force mode, can be either a force or an acceleration.
            force - units:  (linear) mass * distance / seconds^2, i.e. a force
                            (angular) mass * distance * distance / time^2, i.e. a torque
            acceleration - units: (linear) distance / seconds^2, i.e. a linear acceleration.
                            (angular) degrees / seconds^2, i.e. an angular acceleration."""
    )
 
    vector3f physxForce:force = (0.0, 0.0, 0.0) (
        customData = {
            string apiName = "force"
        }      
 
        displayName = "Force"
        doc = """Force to apply defined in global or local frame depending on worldFrameEnabled. The force is applied at the position
            defined by the relative transform to the parent rigid-body Xformable, or at the body's center of mass if the API is applied
            directly to a rigid-body Xformable. For units see mode attribute.
            Range: (-inf, inf)"""
    )
 
    vector3f physxForce:torque = (0.0, 0.0, 0.0) (
        customData = {
            string apiName = "torque"
        }      
 
        displayName = "Torque"
        doc = """Torque to apply defined in the global or local frame depending on worldFrameEnabled. For units see mode attribute.
            Range: (-inf, inf)"""
    )
}


class "PhysxCharacterControllerAPI"
(
    doc = """PhysxCharacterControllerAPI can be applied to a capsuleGeom. It will turn the capsule into a character controller."""
    inherits = </APISchemaBase>
)
{
    float physxCharacterController:slopeLimit = 0.3 (
        customData = {
            string apiName = "slopeLimit"
        }
        
        displayName = "Slope Limit"
        doc = """Slope limit which the CCT can climb. The limit is expressed as the cosine of the desired limit angle. 
        A value of 0 disables this feature."""
    )

    vector3f physxCharacterController:moveTarget = (0.0, 0.0, 0.0) (
        customData = {
            string apiName = "moveTarget"
        }

        displayName = "Move Target"
        doc = """Desired target position that CCT should try to reach."""
    )

    rel physxCharacterController:simulationOwner (
        customData = {
            string apiName = "simulationOwner"
        }

        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that simulates this character controller.
        By default, this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )

    uniform token physxCharacterController:upAxis = "Z" (
        customData = {
            string apiName = "upAxis"
        }

        allowedTokens = ["X", "Y", "Z"]
        displayName = "Up Axis"
        doc = """Up axis for stepping functionality."""
    )

    uniform token physxCharacterController:nonWalkableMode = "preventClimbing" (
        customData = {
            string apiName = "nonWalkableMode"
        }

        allowedTokens = ["preventClimbing", "preventClimbingForceSliding"]
        displayName = "Non Walkable Mode"
        doc = """The non-walkable mode controls if a character controller slides or not on a non-walkable part."""
    )     

    uniform token physxCharacterController:climbingMode = "easy" (
        customData = {
            string apiName = "climbingMode"
        }

        allowedTokens = ["easy", "constrained"]
        displayName = "Climb Mode"
        doc = """The climbing mode."""
    )

    float physxCharacterController:invisibleWallHeight = 0.0 (
        customData = {
            string apiName = "invisibleWallHeight"
        }

        displayName = "Invisible Wall Height"
        doc = """Height of invisible walls created around non-walkable triangles.
            Range: [0, inf)
            Units: distance"""
    )

    float physxCharacterController:maxJumpHeight = 0.0 (
        customData = {
            string apiName = "maxJumpHeight"
        }

        displayName = "Max Jump Height"
        doc = """Maximum height a jumping character can reach.
            Range: [0, inf)
            Units: distance"""
    )

    float physxCharacterController:contactOffset = 0.1 (
        customData = {
            string apiName = "contactOffset"
        }

        displayName = "Contact Offset"
        doc = """The contact offset used by the controller.
            Range: [0, inf)
            Units: distance"""
    )

    float physxCharacterController:stepOffset = 0.5 (
        customData = {
            string apiName = "stepOffset"
        }

        displayName = "Step Offset"
        doc = """Defines the maximum height of an obstacle which the character can climb.
            Range: [0, inf)
            Units: distance"""
    )

    float physxCharacterController:scaleCoeff = 0.8 (
        customData = {
            string apiName = "scaleCoeff"
        }

        displayName = "Scale Coefficient"
        doc = """Scale coefficient for underlying kinematic actor.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxCharacterController:volumeGrowth = 1.5 (
        customData = {
            string apiName = "volumeGrowth"
        }

        displayName = "Volume Growth"
        doc = """Cached volume growth.
            Range: [0, inf)
            Units: dimensionless"""
    )
}

class "PhysxTriggerAPI"
(
    doc = """PhysX trigger"""
    inherits = </APISchemaBase>
)
{
    uniform token physxTrigger:enterScriptType = "scriptFile" (
        customData = {
            string apiName = "enterScriptType"
        }       

        allowedTokens = ["scriptFile", "scriptBuffer"]
        displayName = "Enter Script Type"
        doc = """Enter script type. Script file tries to find a file on disc and execute. Script buffer does execute the provided script string directly."""
    )

    uniform token physxTrigger:leaveScriptType = "scriptFile" (
        customData = {
            string apiName = "leaveScriptType"
        }       

        allowedTokens = ["scriptFile", "scriptBuffer"]

        displayName = "Leave Script Type"
        doc = """Leave script type. Script file tries to find a file on disc and execute. Script buffer does execute the provided script string directly."""
    )

    uniform token physxTrigger:onEnterScript (
        customData = {
            string apiName = "onEnterScript"
        }       

        displayName = "On Enter Script"
        doc = """Enter script."""
    )

    uniform token physxTrigger:onLeaveScript (
        customData = {
            string apiName = "onLeaveScript"
        }       

        displayName = "On Leave Script"
        doc = """Leave script."""
    )
}

class "PhysxTriggerStateAPI"
(
    doc = """PhysX trigger state"""
    inherits = </APISchemaBase>
)
{
    rel physxTrigger:triggeredCollisions (
        customData = {
            string apiName = "triggeredCollisions"
        }       

        displayName = "Triggered Collisions"
        doc = """List of collisions that are currently triggered."""
    )
}

class "PhysxCookedDataAPI"
(
    doc = """PhysX cooked data storage."""
       customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix  = "physxCookedData"
    }
    inherits = </APISchemaBase>
)
{
    uchar[] buffer (
        customData = {
            string apiName = "buffer"
        }
    )
}

class "PhysxTendonAxisAPI"
(
    doc = """WARNING: Draft API, this design is not fixed and may change in the future. At this point, we don't support
    multi-axis joints (e.g. spherical, D6).
    
    Applied to a Physics Joint that must be part of an articulation, e.g. PhysicsRevoluteJoint or PhysicsPrismaticJoint.
    
    A tendon axis is part of a fixed tendon and contributes to the tendon length via the position of its associated
    articulation joint axis and the gearing attribute. The tendon applies spring-damper forces to the articulation links,
    scaled by the force coefficient, that aim to maintain constraints on the tendon lengths.
    
    A joint may have multiple tendon axes that belong to distinct fixed tendons; therefore, the fixed-tendon APIs are
    multi-apply and are grouped into tendons by their instance names.
    
    Fixed tendons do not allow linking arbitrary joint axes of the articulation: The respective joints must all be
    directly connected to each other in the articulation structure, i.e. each of the joints in the tendon must be
    connected by a single articulation link to another joint in the same tendon. This implies that fixed tendons can
    branch along with a branching articulation as well. In addition, the root tendon axis created by applying the
    PhysxTendonAxisRootAPI must be applied to the articulation joint that is the common ancestor of all joint
    axes in the fixed tendon.
    
    In a future version, it will be possible to include multiple axes of a multi-axis joint (e.g. a spherical joint)
    in the fixed tendon by adding them to the axis token array, and setting their gearing and forceCoefficient accordingly
    in the respective float arrays (in the same order). Until then, the jointAxis token array is ignored, and only the first
    element of the gearing array is considered.
    """

    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix  = "physxTendon"
    }
    inherits = </APISchemaBase>
)
{
    float[] gearing = [1.0] (
        customData = {
            string apiName = "gearing"
        }
        displayName = "Gearing"
        doc = """Joint gearing(s) per joint axis in axis token array, in the same order.
            Range: (-inf, inf)
            Units: translational axis: unitless
                   rotational axis:    distance/degrees"""
    )

    float[] forceCoefficient = [1.0] (
        customData = {
            string apiName = "forceCoefficient"
        }
        displayName = "Force Coefficient"
        doc = """Joint force coefficient(s) per joint axis in axis token array, in the same order.
            Range: (-inf, inf)
            Units: translational axis: unitless
                   rotational axis:    distance"""
    )

    uniform token[] jointAxis (
        customData = {
            string apiName = "jointAxis"
        }
        displayName = "Joint Axis"
        allowedTokens = ["transX", "transY", "transZ", "rotX", "rotY", "rotZ"]
        doc = """Specifies target joint axis/axes. Ignored when the joint only has a single axis, e.g. a revolute joint."""
    )
}

class "PhysxTendonAxisRootAPI"
(
    doc = """WARNING: Draft API, this design is not fixed and may change in the future. At this point, we don't support
    multi-axis joints (e.g. spherical, D6) yet.
    
    Applied to a Physics Joint that must be part of an articulation, e.g. PhysicsRevoluteJoint or PhysicsPrismaticJoint.
    
    In addition to creating a regular axis of the fixed tendon, the root API provides attributes that apply to the
    entire tendon. The root API must be applied to the joint that is the common ancestor of all joint axes in the tendon.
    
    For restrictions on tendon structure and grouping of axes into tendons, see PhysxTendonAxisAPI.
    """

    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix  = "physxTendon"
    }
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxTendonAxisAPI"]
)
{
    float stiffness = 0.0 (
        customData = {
            string apiName = "stiffness"
        }
        displayName = "Stiffness"
        doc = """Tendon length spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )

    float damping = 0.0 (
        customData = {
            string apiName = "damping"
        }
        displayName = "Damping"
        doc = """Tendon length damping.
            Range: [0, inf)
            Units: force / distance * time = mass / time"""
    )

    float limitStiffness = 0.0 (
        customData = {
            string apiName = "limitStiffness"
        }
        displayName = "Limit Stiffness"
        doc = """Tendon length-limit spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )

    float offset = 0.0 (
        customData = {
            string apiName = "offset"
        }
        displayName = "Offset"
        doc = """Tendon length offset.
            Range: (-inf, inf)
            Units: distance"""
    )

    float restLength = 0.0 (
        customData = {
            string apiName = "restLength"
        }
        displayName = "Rest Length"
        doc = """Tendon rest length.
            Range: (-inf, inf)
            Units: distance"""
    )
    float lowerLimit = -inf (
        customData = {
            string apiName = "lowerLimit"
        }
        displayName = "Lower Limit"
        doc = """Tendon length lower limit.
            Range: (-inf, upperLimit].
            Units: distance"""
    )
    float upperLimit = inf (
        customData = {
            string apiName = "upperLimit"
        }
        displayName = "Upper Limit"
        doc = """Tendon length upper limit.
            Range: [lowerLimit, inf)
            Units: distance"""
    )

    bool tendonEnabled = true (
        customData = {
            string apiName = "tendonEnabled"
        }
        displayName = "Tendon Enabled"
        doc = """Enables/disables the tendon from contributing to the articulation dynamics."""
    )
}

class "PhysxTendonAttachmentAPI"
(
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.
    
    Applied to an articulation-link rigid-body Xformable.
    
    A tendon attachment is part of a spatial tendon and is attached to an articulation link. The distance between the
    attachment and its parent attachment contributes to the length of the tendon, after scaling by the gearing
    attribute.

    The localPos attribute defines the translational offset of the attachment in the link's local frame; in particular,
    this means that the offset is scaled together with any scaling applied to the link.
    
    An articulation link may have multiple distinct attachments that belong to the same or distinct spatial tendons;
    therefore, the spatial tendon APIs are multi-apply and each attachment must have a unique instance name that is
    used in parent-child relationships of the attachments."""
    
    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix  = "physxTendon"
    }
    inherits = </APISchemaBase>
)
{
    float gearing = 1.0 (
        customData = {
            string apiName = "gearing"
        }
        displayName = "Gearing"
        doc = """Attachment distance scaling factor.
            Range: (-inf, inf)
            Units: unitless"""
    )
    point3f localPos = (0,0,0) (
        customData = {
            string apiName = "localPos"
        }
        displayName = "Local Position"
        doc = """Location of the attachment. Only considered if API is applied to an articulation link (i.e. with a PhysicsRigidBodyAPI).
            Units: (local-frame) distance"""
    )
    rel parentLink (
        customData = {
            string apiName = "parentLink"
        }
        displayName = "Parent Link"
        doc = """Relationship to parent link that has a PhysxTendonAttachmentAPI or PhysxTendonAttachmentRootAPI with instance name parentAttachment applied."""
    )
    uniform token parentAttachment (
        customData = {
            string apiName = "parentAttachment"
        }
        displayName = "Parent Attachment"
        doc = """API instance name of parent attachment at parentLink."""
    )
}

class "PhysxTendonAttachmentRootAPI"
(
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.

    Applied to an articulation-link rigid-body Xformable.

    The root API creates a new spatial tendon tree. The root tendon attachment is the only attachment in a tendon tree
    that does not have a parent, so the parentLink, parentAttachment, and gearing attributes inherited from
    PhysxTendonAttachmentAPI are ignored for a root.

    Spatial tendons create line-of-sight distance constraints between links of a single articulation. In particular,
    spatial tendons run through attachments that are positioned relative to a rigid-body link, and their length is
    defined as a weighted sum of the distance between the attachments in the tendon.

    Spatial tendons may branch, in which case the tendon splits up into multiple conceptual sub-tendons, one for each
    root-to-leaf path in the tendon tree. The tendon tree starts at the root, and its topology is defined by the
    attachments' parentLink rel and parentAttachment token.

    It is possible to create multiple attachments per link, see PhysxTendonAttachmentAPI.

    Details on dynamics:

    The length of a sub-tendon in the tree is

    subTendonLength = sum(gearing[i] * |p[i] - p_parent[i]|)

    where the sum is evaluated along the unique tree path between root and leaf. The gearing[i] is the i-th attachment's
    gearing, and |p[i] - p_parent[i]| is the distance between the positions of the i-th attachment and its parent
    attachment.

    Each subtendon has spring-damper dynamics acting on the length constraint

    constraint = 0 = offset + subTendonLength - restLength

    where the offset is a common summand for all sub-tendons of a spatial tendon, and the restLength is specific to a
    sub-tendon, see the PhysxTendonAttachmentLeafAPI.

    If limits are not active, the sub-tendon force that acts on the leaf is

    F = stiffness * constraint + damping * tendonVelocity

    where tendonVelocity is the sum of the time derivatives of the line-of-sight distances between
        1) the leaf and its parent attachment and
        2) the tendon root and its first child attachment on the path to the leaf.
    Stiffness and damping are common parameters for all sub-tendons.

    The 3D force applied at the leaf attachment is equal to 

    F * (p_parent - p_leaf).

    where p_leaf and p_parent are the leaf's position and its parent's position, respectively. The reaction force acting
    on the root attachment is

    F * (p_child_leaf - p_root)

    where p_child_leaf is the position of the root's child attachment that leads to the leaf that produces F,
    and p_root is the root attachment position. The tendon force is not further propagated through the tendon, so at
    intermediate attachments (i.e. created by PhysxTendonAttachmentAPI) no forces are applied.

    Note that a spatial tendon may both pull and push on the leaf and root attachments. A string-like, one-sided constraint
    can be implemented using the sub-tendon's length limits.

    Sub-tendon length limits constrain the offset length

    lowerLimit <= subTendonLength + offset<= upperLimit

    and, when active, add a restoring spring force parametrized by limitStiffness to the tendon force, analogous to the
    length constraint force above. Limit dynamics are damped by the tendon-length damping that is applied regardless of
    a limit being active. Limit parameters are attributes of the PhysxTendonAttachmentLeafAPI."""
    
    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix  = "physxTendon"
    }
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxTendonAttachmentAPI"]
)
{
    bool tendonEnabled = true (
        customData = {
            string apiName = "tendonEnabled"
        }
        displayName = "Tendon Enabled"
        doc = """Enables/disables the tendon from contributing to the articulation dynamics."""
    )

    float stiffness = 0.0 (
        customData = {
            string apiName = "stiffness"
        }
        displayName = "Stiffness"
        doc = """Common sub-tendon length spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )

    float damping = 0.0 (
        customData = {
            string apiName = "damping"
        }
        displayName = "Damping"
        doc = """Common sub-tendon length damping.
            Range: [0, inf)
            Units: force / distance * time = mass / time"""
    )

    float limitStiffness = 0.0 (
        customData = {
            string apiName = "limitStiffness"
        }
        displayName = "Limit Stiffness"
        doc = """Common sub-tendon length-limit spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )

    float offset = 0.0 (
        customData = {
            string apiName = "offset"
        }
        displayName = "Offset"
        doc = """Common sub-tendon length offset.
            Range: (-inf, inf)
            Units: distance"""
    )
}

class "PhysxTendonAttachmentLeafAPI"
(
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.
    
    Applied to an articulation-link rigid-body Xformable.
    
    The leaf API creates a new sub-tendon between the leaf and the root attachment. A leaf cannot have any children,
    i.e. there cannot be another attachment API that refers to a leaf as parent."""

    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix  = "physxTendon"
    }
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxTendonAttachmentAPI"]
)
{
    float restLength = -inf (
        customData = {
            string apiName = "restLength"
        }
        displayName = "Rest Length"
        doc = """Sub-tendon rest length. If set to a negative value, the rest length is computed internally from the articulation pose and the attachment positions at simulation start.
            Range: [0, inf)
            Units: distance"""
    )
    float lowerLimit = -inf (
        customData = {
            string apiName = "lowerLimit"
        }
        displayName = "Lower Length Limit"
        doc = """Sub-tendon length lower limit.
            Range: (-inf, upperLimit]
            Units: distance"""
    )
    float upperLimit = inf (
        customData = {
            string apiName = "upperLimit"
        }
        displayName = "Upper Length Limit"
        doc = """Sub-tendon length upper limit.
            Range: [lowerLimit, inf)
            Units: distance"""
    )
}

//
// vehicles
//

class "PhysxVehicleContextAPI"
(
    doc = """PhysX vehicles general settings. Has to be applied to a PhysicsScene prim."""
    inherits = </APISchemaBase>
)
{
    uniform token physxVehicleContext:updateMode = "velocityChange" (
        allowedTokens = ["velocityChange", "acceleration"]
        customData = {
            string apiName = "updateMode"
        }
        displayName = "Update Mode"
        doc = """The dynamics of the vehicle simulation can get applied to the PhysX rigid 
              body by either applying an acceleration or by using a velocity delta."""
    )

    float3 physxVehicleContext:upAxis (
        customData = {
            string apiName = "upAxis"
        }
        displayName = "Up Axis"
        doc = """Deprecated. Please use verticalAxis instead.
              
              The normalized vector defining the general up direction to use for vehicles.
              Has to match one of the base axes (1,0,0), (0,1,0) etc. Arbitrary axes are not
              supported.

              Note: will be ignored if verticalAxis is used."""
    )
    
    float3 physxVehicleContext:forwardAxis (
        customData = {
            string apiName = "forwardAxis"
        }
        displayName = "Forward Axis"
        doc = """Deprecated. Please use longitudinalAxis instead.
              
              The normalized vector defining the general forward direction to use for vehicles.
              Has to match one of the base axes (1,0,0), (0,1,0) etc. Arbitrary axes are not
              supported.

              Note: will be ignored if longitudinalAxis is used."""
    )
    
    uniform token physxVehicleContext:verticalAxis = "undefined" (
        allowedTokens = ["posX", "negX", "posY", "negY", "posZ", "negZ", "undefined"]
        customData = {
            string apiName = "verticalAxis"
        }
        displayName = "Vertical Axis"
        doc = """The axis defining the general up direction to use for vehicles.

              Note: the "undefined" token value is only a valid option for indicating that the
              deprecated attribute upAxis should be used instead. Else, a valid axis has to be
              chosen."""
    )
    
    uniform token physxVehicleContext:longitudinalAxis = "undefined" (
        allowedTokens = ["posX", "negX", "posY", "negY", "posZ", "negZ", "undefined"]
        customData = {
            string apiName = "longitudinalAxis"
        }
        displayName = "Longitudinal Axis"
        doc = """The axis defining the general forward direction to use for vehicles.

              Note: the "undefined" token value is only a valid option for indicating that the
              deprecated attribute forwardAxis should be used instead. Else, a valid axis has to
              be chosen."""
    )
}

class PhysxVehicleTireFrictionTable "PhysxVehicleTireFrictionTable"
(
    doc = """Table defining the friction values of a tire against a given set of ground materials."""
    inherits = </Typed>
)
{
    rel groundMaterials (
        displayName = "Ground Materials"
        doc = """Relationships to Material instances that have PhysicsMaterialAPI applied. For each material, a friction value has to be specified in the frictionValues attribute. If a material is encountered that has not been listed, the value declared in defaultFrictionValue will be used."""
    )
    
    float[] frictionValues (
        displayName = "Friction Values"
        doc = """The friction values to use for the tire against the ground materials listed under groundMaterials. The array needs to have the same size as the list of materials specified in groundMaterials."""
    )
    
    float defaultFrictionValue = 1 (
        displayName = "Default Friction Value"
		doc = """The friction value to use for the tire against the ground if the material of the ground surface is not among the materials
        listed in groundMaterials. The value has to be greater or equal 0."""
	)
}

class "PhysxVehicleWheelAPI"
(
    doc = """Properties of a PhysX vehicle wheel. If the wheel setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI applied.
             If the intent is to share the wheel setup, PhysxVehicleWheelAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
    inherits = </APISchemaBase>
)
{
    float physxVehicleWheel:radius (
        customData = {
            string apiName = "radius"
        }
        displayName = "Radius"
        doc = """The radius of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleWheel:width (
        customData = {
            string apiName = "width"
        }
        displayName = "Width"
        doc = """The width of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleWheel:mass (
        customData = {
            string apiName = "mass"
        }
        displayName = "Mass"
        doc = """The mass of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleWheel:moi (
        customData = {
            string apiName = "moi"
        }
        displayName = "Moment of Inertia"
        doc = """The moment of inertia (metal wheel plus tire) about the rolling axis (units: 
              mass * distance * distance).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleWheel:dampingRate (
        customData = {
            string apiName = "dampingRate"
        }
        displayName = "Damping Rate"
        doc = """The damping rate applied to the wheel (units: torque * seconds = mass * distance * distance / seconds).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleWheel:maxBrakeTorque (
        customData = {
            string apiName = "maxBrakeTorque"
        }
        displayName = "Max Brake Torque"
        doc = """Deprecated. Please use PhysxVehicleBrakesAPI instead.
              
              The maximum brake torque that can be applied to the wheel
              (units: mass * distance * distance / seconds / seconds).
              
              Note: will be ignored if PhysxVehicleBrakesAPI is used."""
    )
    
    float physxVehicleWheel:maxHandBrakeTorque (
        customData = {
            string apiName = "maxHandBrakeTorque"
        }
        displayName = "Max Handbrake Torque"
        doc = """Deprecated. Please use PhysxVehicleBrakesAPI instead.
              
              The maximum hand brake torque that can be applied to the wheel
              (units: mass * distance * distance / seconds / seconds).
              
              Note: will be ignored if PhysxVehicleBrakesAPI is used."""
    )
    
    float physxVehicleWheel:maxSteerAngle (
        customData = {
            string apiName = "maxSteerAngle"
        }
        displayName = "Max Steer Angle"
        doc = """Deprecated. Please use PhysxVehicleSteeringAPI instead.
        
              The maximum steer angle (in radians) that can be achieved by the wheel.
        
              Note: will be ignored if PhysxVehicleSteeringAPI is used."""
    )
    
    float physxVehicleWheel:toeAngle (
        customData = {
            string apiName = "toeAngle"
        }
        displayName = "Toe Angle"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The wheel toe angle (in radians).
        
              Note: currently, this attribute is only considered for vehicles using the
                    PhysxVehicleDriveStandard drive type.
              
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
}

class "PhysxVehicleTireAPI"
(
    doc = """Properties of a PhysX vehicle tire. If the tire setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI applied.
             If the intent is to share the tire setup, PhysxVehicleTireAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
    inherits = </APISchemaBase>
)
{
    float physxVehicleTire:latStiffX = 2 (
        customData = {
            string apiName = "latStiffX"
        }
        displayName = "Lateral Stiffness X"
        doc = """Deprecated. Please use lateralStiffnessGraph instead.
              
              Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and 
              flattens at large loads. The parameter describes the minimum normalized load (load/restLoad)
              that gives a flat lateral stiffness response to load.
              
              Note: will be ignored if lateralStiffnessGraph is used."""
    )
    
    float physxVehicleTire:latStiffY (
        customData = {
            string apiName = "latStiffY"
        }
        displayName = "Lateral Stiffness Y"
        doc = """Deprecated. Please use lateralStiffnessGraph instead.
              
              Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and 
              flattens at large loads. The parameter describes the maximum possible value of lateralStiffness/restLoad
              that occurs when (load/restLoad) >= latStiffX. If load/restLoad is greater than latStiffX then
              the lateral stiffness is latStiffY*restLoad, else the lateral stiffness is latStiffY*(load/latStiffX).
              
              Note: will be ignored if lateralStiffnessGraph is used.
              
              Note: if not defined, the value 17.095 will be used."""
    )
    
    float2 physxVehicleTire:lateralStiffnessGraph = (0, 0) (
        customData = {
            string apiName = "lateralStiffnessGraph"
        }
        displayName = "Lateral Stiffness Graph"
        doc = """Tire lateral stiffness is represented as a graph of tire load that has linear behavior
              near zero load and flattens at large loads. The first value of the parameter describes the
              minimum normalized load (load/restLoad) that gives a flat lateral stiffness response to load.
              This value has to be greater or equal 0. The second value of the parameter defines the lateral
              stiffness when the response is flat (the max lateral stiffness, units: mass * distance / seconds / seconds).
              This value has to be positive.
              
              Note: the default value (0, 0) is not a valid value as such but indicates that the
              deprecated attributes latStiffX and latStiffY should be used instead."""
    )
    
    float physxVehicleTire:longitudinalStiffnessPerUnitGravity (
        customData = {
            string apiName = "longitudinalStiffnessPerUnitGravity"
        }
        displayName = "Longitudinal Stiffness per Unit Gravity"
        doc = """Deprecated. Please use longitudinalStiffness instead.
              
              Tire longitudinal stiffness per unit gravitational acceleration. Longitudinal stiffness of 
              the tire is calculated as gravitationalAcceleration*longitudinalStiffnessPerUnitGravity.
              
              Note: will be ignored if longitudinalStiffness is used.
              
              Note: if not defined, the value 500 will be used."""
    )
    
    float physxVehicleTire:longitudinalStiffness = 0 (
        customData = {
            string apiName = "longitudinalStiffness"
        }
        displayName = "Longitudinal Stiffness"
        doc = """Tire longitudinal stiffness (units: mass * distance / seconds / seconds).
              The value has to be positive. The resulting longitudinal force can be approximated as: 
              longitudinalStiffness*longitudinalSlip.
              
              Note: the default value 0 is not a valid value as such but indicates that the deprecated
              attribute longitudinalStiffnessPerUnitGravity should be used instead."""
    )
    
    float physxVehicleTire:camberStiffnessPerUnitGravity = 0 (
        customData = {
            string apiName = "camberStiffnessPerUnitGravity"
        }
        displayName = "Camber Stiffness per Unit Gravity"
        doc = """Deprecated. Please use camberStiffness instead.
              
              Tire camber stiffness per unit gravitational acceleration. Camber stiffness of the tire is
              calculated as gravitationalAcceleration*camberStiffnessPerUnitGravity.
              
              Note: will be ignored if camberStiffness is used."""
    )
    
    float physxVehicleTire:camberStiffness = -1 (
        customData = {
            string apiName = "camberStiffness"
        }
        displayName = "Camber Stiffness"
        doc = """Tire camber stiffness (units: mass * distance / seconds / seconds / radians).
              The value has to be greater or equal 0. Camber force can be approximated as: 
              camberStiffness*camberAngle.
              
              Note: the default value -1 is not a valid value as such but indicates that the 
              deprecated attribute camberStiffnessPerUnitGravity should be used instead."""
    )
    
    float2[] physxVehicleTire:frictionVsSlipGraph (
        customData = {
            string apiName = "frictionVsSlipGraph"
        }
        displayName = "Friction vs Slip Graph"
        doc = """Graph of friction vs longitudinal slip with 3 points. The friction value extracted from this
              graph will be multiplied with the friction value of the combination of ground material and tire
              type. The array is expected to have 3 entries/points. For the first point, the first value is 
              always zero and the second value is the friction available at zero longitudinal slip. For the
              second point, the first value is the longitudinal slip with maximum friction and the second
              value is the maximum friction. For the third point, the first value is the end point of the graph
              and the second value is the friction for slips greater than the end point of the graph. Note that
              the friction value of the first point is typically smaller than the friction value of the second
              point and the friction value of the second point is typically larger than the friction value of
              the third point.
              
              Note: if not defined, the following values will be used: [(0.0, 1.0), (0.1, 1.0), (1.0, 1.0)]."""
    )

    rel physxVehicleTire:frictionTable (
        customData = {
            string apiName = "frictionTable"
        }
        displayName = "Friction Table"
        doc = """A relationship to a PhysxVehicleTireFrictionTable instance.
        
              Note: if not defined, a default friction table will be used."""
    )

    float physxVehicleTire:restLoad = 0 (
        customData = {
            string apiName = "restLoad"
        }
        displayName = "Rest Load"
        doc = """The load that develops on the tire when the vehicle is at rest on a flat plane
                 (units: force = mass * distance / seconds / seconds). The value has to be greater or equal 0.
                 If set to 0, the rest load will get computed automatically using the approximation of:
                 gravitational acceleration * sprungMass.
                 
                 Note: it is not possible for a vehicle to have some rest load values being user-defined
                 and some being computed automatically. Either all values have to be user-defined or all
                 have to be set to 0 for auto-computation."""
    )
}

class "PhysxVehicleSuspensionAPI"
(
    doc = """Properties of a PhysX vehicle wheel suspension. If the suspension setup does not need to be shared 
             among vehicle instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI
             applied. If the intent is to share the suspension setup, PhysxVehicleSuspensionAPI can be 
             applied to a separate prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
    inherits = </APISchemaBase>
)
{
    float physxVehicleSuspension:springStrength (
        customData = {
            string apiName = "springStrength"
        }
        displayName = "Spring Strength"
        doc = """Spring strength of suspension unit (units: force / distance = mass / seconds / seconds).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleSuspension:springDamperRate (
        customData = {
            string apiName = "springDamperRate"
        }
        displayName = "Spring Damper Rate"
        doc = """Spring damper rate of suspension unit (units: force * seconds / distance = mass / seconds).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleSuspension:travelDistance (
        customData = {
            string apiName = "travelDistance"
        }
        displayName = "Travel Distance"
        doc = """Distance the wheel can travel along the suspension when going from max compression to 
              max droop (units: distance). The value has to be positive.
              
              Note: either this attribute or the deprecated maxCompression/maxDroop have to
              to be specified (with the former taking precedence). When migrating from the
              deprecated attributes, travelDistance can be set to the sum of maxCompression
              and maxDroop."""
    )
    
    float physxVehicleSuspension:maxCompression (
        customData = {
            string apiName = "maxCompression"
        }
        displayName = "Max Compression"
        doc = """Deprecated. Please use travelDistance instead.
        
              Maximum compression from rest state allowed by suspension spring (units: distance).
              The value has to be positive.
              
              Note: will be ignored if travelDistance is authored."""
    )
    
    float physxVehicleSuspension:maxDroop (
        customData = {
            string apiName = "maxDroop"
        }
        displayName = "Max Droop"
        doc = """Deprecated. Please use travelDistance instead.
              
              Maximum elongation from rest state allowed by suspension spring (units: distance).
              The value has to be positive unless it should get computed automatically in which case any
              negative number can be used to indicate as much. It is highly recommended to chose a value
              close to: sprungMass * gravity / springStrength.
              
              Note: will be ignored if travelDistance is authored."""
    )
    
    float physxVehicleSuspension:sprungMass = 0 (
        customData = {
            string apiName = "sprungMass"
        }
        displayName = "Sprung Mass"
        doc = """Mass of vehicle that is supported by suspension spring (units: mass).
              If set to 0, the sprung mass will get computed automatically.
              
              Note: it is not possible for a vehicle to have some sprung mass values being user-defined and some 
              being computed automatically. Either all values have to be user-defined or all have to be set to 0 
              for auto-computation."""
    )
    
    float physxVehicleSuspension:camberAtRest (
        customData = {
            string apiName = "camberAtRest"
        }
        displayName = "Camber at Rest"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at its rest position.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    
    float physxVehicleSuspension:camberAtMaxCompression (
        customData = {
            string apiName = "camberAtMaxCompression"
        }
        displayName = "Camber at Max Compression"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at maximum compression.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    
    float physxVehicleSuspension:camberAtMaxDroop (
        customData = {
            string apiName = "camberAtMaxDroop"
        }
        displayName = "Camber at Max Droop"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at maximum droop.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
}

class "PhysxVehicleWheelAttachmentAPI"
(
    doc = """For every wheel of a vehicle, this class defines the attachment properties. Has to 
            be applied to a prim that is a descendant of a prim with PhysxVehicleAPI applied. If the wheel
            attachment prim (the prim with PhysxVehicleWheelAttachmentAPI applied) is a UsdGeomXformable,
            then the position and orientation of the prim will be set by the vehicle simulation. If the
            wheel attachment prim has PhysicsCollisionAPI applied, then none of its descendants are allowed
            to have PhysicsCollisionAPI applied. If the wheel attachment prim is a UsdGeomXformable but does
            not have PhysicsCollisionAPI applied, then exactly one direct child prim among all descendants
            is allowed to have PhysicsCollisionAPI applied. That prim will be interpreted as the collision
            geometry of the wheel and its position and orientation will be set by the vehicle simulation
            too. Note that the relative transform between the collision geometry prim and the wheel attachment
            prim at the start of the simulation will be maintained (the relative transform with respect to
            the center of mass frame of the vehicle rigid body that is). If there is no desire to have the
            vehicle simulation control the transform of the wheel attachment prim, then a prim type that is
            not a UsdGeomXformable should be chosen."""
    inherits = </APISchemaBase>
)
{
    int physxVehicleWheelAttachment:index = -1 (
        customData = {
            string apiName = "index"
        }
        displayName = "Index"
        doc = """The index of the wheel attachment. Some other components will reference the wheel attachments
              based on this index. Either all indices of a vehicle's wheel attachments need to be -1 or they
              need to cover all entries in the group {0, .., (numberOfWheels-1)}. All indices being -1 covers 
              the case where wheels are controlled directly through PhysxVehicleWheelControllerAPI, for example,
              or when deprecated APIs are used still."""
    )

    rel physxVehicleWheelAttachment:wheel (
        customData = {
            string apiName = "wheel"
        }
        displayName = "Wheel"
        doc = """A relationship to a PhysxVehicleWheelAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleWheelAPI
                    applied (none or both of the two is invalid)."""
    )
    
    rel physxVehicleWheelAttachment:tire (
        customData = {
            string apiName = "tire"
        }
        displayName = "Tire"
        doc = """A relationship to a PhysxVehicleTireAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleTireAPI
                    applied (none or both of the two is invalid)."""
    )
    
    rel physxVehicleWheelAttachment:suspension (
        customData = {
            string apiName = "suspension"
        }
        displayName = "Suspension"
        doc = """A relationship to a PhysxVehicleSuspensionAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleSuspensionAPI
                    applied (none or both of the two is invalid)."""
    )
    
    vector3f physxVehicleWheelAttachment:suspensionTravelDirection (
        customData = {
            string apiName = "suspensionTravelDirection"
        }
        displayName = "Suspension Travel Direction"
        doc = """The direction of the suspension travel (towards the wheel). The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the direction is specified. If set to true, the direction is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: this attribute has to be specified (there is no default)."""
    )
    
    point3f physxVehicleWheelAttachment:suspensionFramePosition (
        customData = {
            string apiName = "suspensionFramePosition"
        }
        displayName = "Suspension Frame Position"
        doc = """The point of the suspension at max compression. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the position is specified. If set to true, the position is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer. Camber, steer and toe angles are all applied in the suspension
              frame. The vehicle frame transform of the wheel will be defined by: centerOfMassFrame * 
              suspensionFrame * wheelFrame (if physxVehicle:referenceFrameIsCenterOfMass is true,
              else centerOfMassFrame has to be omitted).
              
              Note: either this attribute or the deprecated wheelCenterOfMassOffset have to
              to be specified (with the former taking precedence)."""
    )
    
    quatf physxVehicleWheelAttachment:suspensionFrameOrientation = (1, 0, 0, 0) (
        customData = {
            string apiName = "suspensionFrameOrientation"
        }
        displayName = "Suspension Frame Orientation"
        doc = """The orientation of the suspension frame. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the orientation is specified. If set to true, the orientation is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer. Camber, steer and toe angles are all applied in the suspension
              frame. The vehicle frame transform of the wheel will be defined by: centerOfMassFrame * 
              suspensionFrame * wheelFrame (if physxVehicle:referenceFrameIsCenterOfMass is true,
              else centerOfMassFrame has to be omitted)."""
    )
    
    float3 physxVehicleWheelAttachment:suspensionForceAppPointOffset (
        customData = {
            string apiName = "suspensionForceAppPointOffset"
        }
        displayName = "Suspension Force Application Point Offset"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The location where the suspension force gets applied. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    
    float3 physxVehicleWheelAttachment:wheelCenterOfMassOffset (
        customData = {
            string apiName = "wheelCenterOfMassOffset"
        }
        displayName = "Wheel Center of Mass Offset"
        doc = """Deprecated. Please use suspensionFramePosition instead.
              
              The location of the wheel centre when at rest. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if suspensionFramePosition is authored."""
    )

    float3 physxVehicleWheelAttachment:tireForceAppPointOffset (
        customData = {
            string apiName = "tireForceAppPointOffset"
        }
        displayName = "Tire Force Application Point Offset"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The location where the tire force gets applied. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    
    point3f physxVehicleWheelAttachment:wheelFramePosition = (0, 0, 0) (
        customData = {
            string apiName = "wheelFramePosition"
        }
        displayName = "Wheel Frame Position"
        doc = """A position offset of the wheel center relative to the suspension frame.
              Non-zero values might be used, for example, if the steer axis should not go
              through the wheel center."""
    )
    
    quatf physxVehicleWheelAttachment:wheelFrameOrientation = (1, 0, 0, 0) (
        customData = {
            string apiName = "wheelFrameOrientation"
        }
        displayName = "Wheel Frame Orientation"
        doc = """An orientation adjustment of the wheel relative to the suspension frame.
              The rotation angle around the wheel's lateral axis is applied in this frame."""
    )

    bool physxVehicleWheelAttachment:driven (
        customData = {
            string apiName = "driven"
        }
        displayName = "Driven"
        doc = """Deprecated. Please use PhysxVehicleMultiWheelDifferentialAPI instead.
        
                 True if the tire is driven by the engine through the transmission. Will be ignored if the vehicle
                 has no drive specified (see PhysxVehicleAPI:drive) or if PhysxVehicleMultiWheelDifferentialAPI
                 is used instead."""
    )

    rel physxVehicleWheelAttachment:collisionGroup (
        customData = {
            string apiName = "collisionGroup"
        }
        displayName = "Collision Group"
        doc = "A relationship to a PhysicsCollisionGroup instance that defines what the wheel/suspension scene queries should treat as a ground surface to collide against. If not specified, no specific filtering will be applied."
    )
}

class "PhysxVehicleSuspensionComplianceAPI"
(
    doc = """Compliance describes how toe and camber angle and force application points are 
          affected by suspension compression. Each compliance term is in the form of a graph
          with up to 3 points. The points in the graph consist of a normalized jounce value
          (with 0 meaning fully elongated and 1 fully compressed suspension) and a corresponding
          compliance value (which can be an angle or point etc. depending on the specific
          compliance term). The sequence of points must respresent monotonically increasing
          values of normalized jounce. The actual compliance value will be computed by linear
          interpolation based on the current normalized jounce. If any graph has zero points
          in it, a value of 0.0 is used for the compliance value. If any graph has 1 point
          in it, the compliance value of that point is used directly. This API schema has to
          be applied to a prim with PhysxVehicleWheelAttachmentAPI applied. If defined, then
          this setup takes precedence over the deprecated attributes suspensionForceAppPointOffset
          and tireForceAppPointOffset of the PhysxVehicleWheelAttachmentAPI API schema, the
          deprecated attributes camberAtRest, camberAtMaxCompression, camberAtMaxDroop of the
          PhysxVehicleSuspensionAPI API schema as well as the deprecated attribute toeAngle
          of the PhysxVehicleWheelAPI API schema."""
    inherits = </APISchemaBase>
)
{
    float2[] physxVehicleSuspensionCompliance:wheelToeAngle (
        customData = {
            string apiName = "wheelToeAngle"
        }
        displayName = "Wheel Toe Angle"
        doc = """A graph of toe angle against normalized jounce with the toe angle expressed
              in radians in the range [-pi, pi]. See the class documentation for general info
              about the nature of these graphs and the data requirements.
              
              Note: the toe angle is applied in the suspension frame (see PhysxVehicleWheelAttachmentAPI)."""
    )
    
    float2[] physxVehicleSuspensionCompliance:wheelCamberAngle (
        customData = {
            string apiName = "wheelCamberAngle"
        }
        displayName = "Wheel Camber Angle"
        doc = """A graph of camber angle against normalized jounce with the camber angle expressed
              in radians in the range [-pi, pi]. See the class documentation for general info
              about the nature of these graphs and the data requirements.
              
              Note: the camber angle is applied in the suspension frame (see PhysxVehicleWheelAttachmentAPI)."""
    )
    
    float4[] physxVehicleSuspensionCompliance:suspensionForceAppPoint (
        customData = {
            string apiName = "suspensionForceAppPoint"
        }
        displayName = "Suspension Force Application Point"
        doc = """Suspension forces are applied at an offset from the suspension frame (see 
              PhysxVehicleWheelAttachmentAPI). An entry in this array defines this offset for a
              given normalized jounce value (which is the first element in the float4 while
              the other 3 elements are used to store the x, y, z coordinates of the offset).
              See the class documentation for general info about the nature of these compliance
              terms and the data requirements."""
    )
    
    float4[] physxVehicleSuspensionCompliance:tireForceAppPoint (
        customData = {
            string apiName = "tireForceAppPoint"
        }
        displayName = "Tire Force Application Point"
        doc = """Tire forces are applied at an offset from the suspension frame (see 
              PhysxVehicleWheelAttachmentAPI). An entry in this array defines this offset for a
              given normalized jounce value (which is the first element in the float4 while
              the other 3 elements are used to store the x, y, z coordinates of the offset).
              See the class documentation for general info about the nature of these compliance
              terms and the data requirements."""
    )
}

class "PhysxVehicleEngineAPI"
(
    doc = """Properties of a PhysX vehicle engine. If the engine setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the engine setup, PhysxVehicleEngineAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
    inherits = </APISchemaBase>
)
{
    float physxVehicleEngine:moi (
        customData = {
            string apiName = "moi"
        }
        displayName = "Moment of Inertia"
        doc = """The moment of inertia of the engine around the axis of rotation (units: 
                 mass * distance * distance). The value has to be positive.
        
                 Note: if not defined, the value 1.0 will be used. This default value is in meter length scale 
                 and kilograms and will get adjusted if other units are used."""
    )
    
    float physxVehicleEngine:peakTorque = -1 (
        customData = {
            string apiName = "peakTorque"
        }
        displayName = "Peak Torque"
        doc = """Maximum torque available to apply to the engine when the accelerator pedal is at maximum
                 (units: mass * distance * distance / seconds / seconds). The value has to be greater or
                 equal 0.
                 
                 Note: the torque available is the value of the accelerator pedal (in range [0, 1]) multiplied
                 by the normalized torque as computed from torqueCurve (see corresponding attribute)
                 multiplied by peakTorque.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 500.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
    
    float physxVehicleEngine:maxRotationSpeed = 600.0 (
        customData = {
            string apiName = "maxRotationSpeed"
        }
        displayName = "Max Rotation Speed"
        doc = """Maximum rotation speed of the engine (units: radians / seconds). The value has to be greater
                 or equal 0."""
    )
    
    float physxVehicleEngine:idleRotationSpeed = 0 (
        customData = {
            string apiName = "idleRotationSpeed"
        }
        displayName = "Idle Rotation Speed"
        doc = """Rotation speed of the engine when idling (units: radians / seconds). The value has to be greater or equal 0."""
    )
    
    float2[] physxVehicleEngine:torqueCurve (
        customData = {
            string apiName = "torqueCurve"
        }
        displayName = "Torque Curve"
        doc = """Graph of normalized torque (torque / peakTorque) against normalized engine speed (engineRotationSpeed / maxRotationSpeed).
                 
                 Note: the normalized engine speed is the x-axis of the graph, while the normalized torque is the y-axis of the graph.
                 No more than 8 data points are supported.
                 
                 Note: if not defined, the following values will be used: [(0.0, 0.8), (0.33, 1.0), (1.0, 0.8)]."""
    )
    
    float physxVehicleEngine:dampingRateFullThrottle = -1 (
        customData = {
            string apiName = "dampingRateFullThrottle"
        }
        displayName = "Damping Rate at Full Throttle"
        doc = """Damping rate of engine when full throttle is applied (units: 
                 torque * seconds = mass * distance * distance / seconds). The value has to be greater
                 or equal 0.
                 
                 Note: if the clutch is engaged (any gear except neutral) then the damping rate applied 
                 at run-time is an interpolation between dampingRateZeroThrottleClutchEngaged (see 
                 corresponding attribute) and dampingRateFullThrottle:
                 dampingRateZeroThrottleClutchEngaged + 
                 ((dampingRateFullThrottle-dampingRateZeroThrottleClutchEngaged) * acceleratorPedal).
                 
                 Note: if the clutch is disengaged (in neutral gear) the damping rate applied at run-time
                 is an interpolation between dampingRateZeroThrottleClutchDisengaged (see corresponding 
                 attribute) and dampingRateFullThrottle:
                 dampingRateZeroThrottleClutchDisengaged +
                 ((dampingRateFullThrottle-dampingRateZeroThrottleClutchDisengaged) * acceleratorPedal).
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 0.15
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
    
    float physxVehicleEngine:dampingRateZeroThrottleClutchEngaged = -1 (
        customData = {
            string apiName = "dampingRateZeroThrottleClutchEngaged"
        }
        displayName = "Damping Rate at Zero Throttle with Clutch Engaged"
        doc = """Damping rate of engine when no throttle is applied and the clutch is engaged (units: 
                 torque * seconds = mass * distance * distance / seconds). See attribute "dampingRateFullThrottle"
                 for information about the effect of the value. The value has to be greater or equal 0.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 2.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
    
    float physxVehicleEngine:dampingRateZeroThrottleClutchDisengaged = -1 (
        customData = {
            string apiName = "dampingRateZeroThrottleClutchDisengaged"
        }
        displayName = "Damping Rate at Zero Throttle with Clutch Disengaged"
        doc = """Damping rate of engine when no throttle is applied and the clutch is disengaged (units: 
                 torque * seconds = mass * distance * distance / seconds). See attribute "dampingRateFullThrottle"
                 for information about the effect of the value. The value has to be greater or equal 0.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 0.35
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
}

class "PhysxVehicleGearsAPI"
(
    doc = """Properties of PhysX vehicle gears. If the gears setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the gears setup, PhysxVehicleGearsAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
    inherits = </APISchemaBase>
)
{
    float[] physxVehicleGears:ratios (
        customData = {
            string apiName = "ratios"
        }
        displayName = "Ratios"
        doc = """The gear ratios. First entry is for reverse, then there is support for up to 30 gears
                 (neutral has a fixed value of 0 and is not represented in this array). The value for
                 reverse has to be negative, else a positive value is expected and the ratios have to
                 form a descending sequence.
                 
                 Note: if not defined, the following values will be used: [-4.0, 4.0, 2.0, 1.5, 1.1, 1.0]."""
    )
    
    float physxVehicleGears:ratioScale (
        customData = {
            string apiName = "ratioScale"
        }
        displayName = "Ratio Scale"
        doc = """Multiplier for gear ratio values. Final gear ratio is computed as ratios[currentGear] * ratioScale.
                 The value has to be positive.
                 
                 Note: if not defined, the value 4.0 will be used."""
    )
    
    float physxVehicleGears:switchTime (
        customData = {
            string apiName = "switchTime"
        }
        displayName = "Switch Time"
        doc = """Time it takes to switch gear (units: seconds).
        
                 Note: if not defined, the value 0.5 will be used."""
    )
}

class "PhysxVehicleAutoGearBoxAPI"
(
    doc = """Properties of the PhysX vehicle automatic gear shift box. If the automatic gear shift box setup
             does not need to be shared among vehicle instances, it can be applied to the prim which has 
             PhysxVehicleDriveStandardAPI applied. If the intent is to share the automatic gear shift box
             setup, PhysxVehicleAutoGearBoxAPI can be applied to a separate prim which can be linked to 
             (see PhysxVehicleDriveStandardAPI)."""
    inherits = </APISchemaBase>
)
{
    float[] physxVehicleAutoGearBox:upRatios (
        customData = {
            string apiName = "upRatios"
        }
        displayName = "Up Ratios"
        doc = """Value of normalized engine speed (engineRotationSpeed / maxRotationSpeed) that is high
                 enough to increment gear. The first entry is for first gear and then up to the
                 second highest gear. When (engineRotationSpeed / maxRotationSpeed) > upRatios[currentGear]
                 the autobox will begin a transition to currentGear+1 unless currentGear is the highest
                 possible gear or neutral or reverse.
                 
                 Note: if not defined, the following values will be used: [0.65, 0.65, 0.65, 0.65]."""
    )
    
    float[] physxVehicleAutoGearBox:downRatios (
        customData = {
            string apiName = "downRatios"
        }
        displayName = "Down Ratios"
        doc = """Value of normalized engine speed (engineRotationSpeed / maxRotationSpeed) that is low
                 enough to decrement gear. The first entry is for second gear then up to the highest gear.
                 When (engineRotationSpeed / maxRotationSpeed) < downRatios[currentGear] the autobox will
                 begin a transition to currentGear-1 unless currentGear is first gear or neutral or reverse.
                 
                 Note: if not defined, the following values will be used: [0.5, 0.5, 0.5, 0.5]."""
    )
    
    float physxVehicleAutoGearBox:latency (
        customData = {
            string apiName = "latency"
        }
        displayName = "Latency"
        doc = """The latency time of the automatic gear shift box (units: seconds). This is the minimum
                 time that must pass between each gear change that is initiated by the automatic gear shift
                 box.
                 
                 Note: if not defined, the value 2.0 will be used."""
    )
}

class "PhysxVehicleClutchAPI"
(
    doc = """Properties of the PhysX vehicle clutch. If the clutch setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the clutch setup, PhysxVehicleClutchAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
    inherits = </APISchemaBase>
)
{
    float physxVehicleClutch:strength (
        customData = {
            string apiName = "strength"
        }
        displayName = "Strength"
        doc = """Strength of clutch (units: torque * seconds = mass * distance * distance / seconds).
              The value has to be positive.
              The clutch is the mechanism that couples the engine to the wheels. A stronger clutch more
              strongly couples the engine to the wheels, while a clutch of strength zero completely
              decouples the engine from the wheels. Stronger clutches more quickly bring the wheels and
              engine into equilibrium, while weaker clutches take longer, resulting in periods of clutch
              slip and delays in power transmission from the engine to the wheels. The torque generated
              by the clutch is proportional to the clutch strength and the velocity difference between
              the engine's rotational speed and the rotational speed of the driven wheels after accounting
              for the gear ratio. The torque at the clutch is applied negatively to the engine and
              positively to the driven wheels.
              
              Note: if not defined, the value 10.0 will be used. This default value is in meter length scale 
              and kilograms and will get adjusted if other units are used."""
    )
}

class "PhysxVehicleDriveBasicAPI"
(
    doc = """Very simple drive model for a PhysX vehicle. A torque will be directly applied to the wheels
             that are marked as driven (see PhysxVehicleMultiWheelDifferentialAPI or deprecated attribute
             "driven" in PhysxVehicleWheelAttachmentAPI).
             
             If the drive setup does not need to be shared among vehicle instances, it can be applied to the
             prim which has PhysxVehicleAPI applied. If the intent is to share the drive setup, PhysxVehicleDriveBasicAPI
             can be applied to a separate prim which can be linked to (see PhysxVehicleAPI)."""
    inherits = </APISchemaBase>
)
{
    float physxVehicleDriveBasic:peakTorque = -1 (
        customData = {
            string apiName = "peakTorque"
        }
        displayName = "Peak Torque"
        doc = """Maximum torque to generate when the accelerator pedal is at maximum
                 (units: mass * distance * distance / seconds / seconds). The value has to be greater or equal 0.
                 
                 Note: PhysxVehicleMultiWheelDifferentialAPI can be used to specify which wheels are connected
                 to the drive as well as how the torque should be distributed among those wheels. If the
                 deprecated attribute "driven" of PhysxVehicleWheelAttachmentAPI is used, then each driven
                 wheel can experience a torque up to the value defined in this attribute.
                 
                 Note: the applied torque is the value of the accelerator pedal (in range [0, 1]) multiplied
                 by peakTorque.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 1000.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
}

class "PhysxVehicleDriveStandardAPI"
(
    doc = """Standard drive model for a PhysX vehicle. The available drive torque will be split equally
             between all the wheels that are marked as driven (see PhysxVehicleMultiWheelDifferentialAPI
             or deprecated attribute "driven" in PhysxVehicleWheelAttachmentAPI) unless the torque
             distributon is configured explicitly (see PhysxVehicleMultiWheelDifferentialAPI for details).
             
             If the drive setup does not need to be shared among vehicle instances, it can be applied to the
             prim which has PhysxVehicleAPI applied. If the intent is to share the drive setup, PhysxVehicleDriveStandardAPI
             can be applied to a separate prim which can be linked to (see PhysxVehicleAPI)."""
    inherits = </APISchemaBase>
)
{
    rel physxVehicleDriveStandard:engine (
        customData = {
            string apiName = "engine"
        }
        displayName = "Engine"
        doc = """A relationship to a PhysxVehicleEngineAPI prim that describes the engine.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleEngineAPI
                    applied (none or both of the two is invalid)."""
    )
    
    rel physxVehicleDriveStandard:gears (
        customData = {
            string apiName = "gears"
        }
        displayName = "Gears"
        doc = """A relationship to a PhysxVehicleGearsAPI prim that describes the gears.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleGearsAPI
                    applied (none or both of the two is invalid)."""
    )
    
    rel physxVehicleDriveStandard:autoGearBox (
        customData = {
            string apiName = "autoGearBox"
        }
        displayName = "Auto Gear Box"
        doc = """A relationship to a PhysxVehicleAutoGearBoxAPI prim that describes the automatic gear shift box.
                 This relationship is optional and should be omitted if no automatic gear shift is desired. It is
                 also possible to apply PhysxVehicleAutoGearBoxAPI to the prim directly. In that case the relationship
                 must not be defined."""
    )
    
    rel physxVehicleDriveStandard:clutch (
        customData = {
            string apiName = "clutch"
        }
        displayName = "Clutch"
        doc = """A relationship to a PhysxVehicleClutchAPI prim that describes the clutch.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleClutchAPI
                    applied (none or both of the two is invalid)."""
    )
}

class "PhysxVehicleMultiWheelDifferentialAPI"
(
    doc = """Describes which wheels of a vehicle are driven as well as the distribution of the
          drive torque among those wheels. Has to be applied to a prim with PhysxVehicleAPI applied.
          Can only be used for vehicles that have a drive (see PhysxVehicleDriveBasicAPI or
          PhysxVehicleDriveStandardAPI)."""
    inherits = </APISchemaBase>
)
{
    int[] physxVehicleMultiWheelDifferential:wheels (
        customData = {
            string apiName = "wheels"
        }
        displayName = "Wheels"
        doc = """List of indices, referencing the wheels that are driven (receiving torque from the engine). The
              indices refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI."""
    )
    
    float[] physxVehicleMultiWheelDifferential:torqueRatios (
        customData = {
            string apiName = "torqueRatios"
        }
        displayName = "Torque Ratios"
        doc = """Defines how the drive torque should get distributed among the wheels specified in the "wheels"
              attribute. The provided ratios must be in range [-1, 1] and under normal circumstances the absolute
              values should sum up to 1. If the attribute is defined, then the length of the array needs to match
              the length of the "wheels" array. If the attribute is not defined, the torque will get split equally
              among all driven wheels."""
    )

    float[] physxVehicleMultiWheelDifferential:averageWheelSpeedRatios (
        customData = {
            string apiName = "averageWheelSpeedRatios"
        }
        displayName = "Average Wheel Speed Ratios"
        doc = """Defines how the speeds of the driven wheels get weighted when computing the average wheel
              speed at the clutch (for computing clutch slip). The provided ratios must be in range [0, 1]
              and under normal circumstances sum up to 1. If the attribute is defined, then the length of 
              the array needs to match the length of the "wheels" array. If the attribute is not defined, 
              the wheel speeds of all driven wheels will get weighted equally.
              
              Note: if a vehicle is using a PhysxVehicleDriveBasicAPI drive, then this attribute should not
                    be used."""
    )
}

class "PhysxVehicleTankDifferentialAPI"
(
	doc = """Differential to set up a wheeled tank vehicle. Describes which wheels of a vehicle are part of
          the tank tracks. The wheels in each tank track have a constraint applied to them to enforce the
          rule that they all have the same longitudinal speed at the contact point between the wheel and the
          tank track. Driven wheels that are not part of a tank track receive the torque split specified in
          physxVehicleMultiWheelDifferential:torqueRatios. Has to be applied to a prim with PhysxVehicleAPI
          applied. Can only be used for vehicles that have a standard drive (see PhysxVehicleDriveStandardAPI)."""
	inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxVehicleMultiWheelDifferentialAPI"]
)
{
    int[] physxVehicleTankDifferential:numberOfWheelsPerTrack (
		customData = {
			string apiName = "numberOfWheelsPerTrack"
		}
        displayName = "Number Of Wheels Per Track"
		doc = """For each track, this array holds the number of wheels assigned to that track."""
	)
    
    int[] physxVehicleTankDifferential:thrustIndexPerTrack (
		customData = {
			string apiName = "thrustIndexPerTrack"
		}
        displayName = "Thrust Index Per Track"
		doc = """For each track, this array holds the index of the thrust control (0 or 1, see PhysxVehicleTankControllerAPI)
              that drives the track. The length of the array needs to match the length of the 
              "numberOfWheelsPerTrack" array."""
	)
    
    int[] physxVehicleTankDifferential:trackToWheelIndices (
		customData = {
			string apiName = "trackToWheelIndices"
		}
        displayName = "Track To Wheel Indices"
		doc = """For each track, this array holds the start index of the list describing the wheels that
              are assigned to that track (e.g., the list of wheel indices assigned to the track with index
              2 starts at: wheelIndicesInTrackOrder[trackToWheelIndices[2]]). The length of the array needs
              to match the length of the "numberOfWheelsPerTrack" array."""
	)

    int[] physxVehicleTankDifferential:wheelIndicesInTrackOrder (
		customData = {
			string apiName = "wheelIndicesInTrackOrder"
		}
        displayName = "Wheel Indices In Track Order"
		doc = """The wheels (identified by wheel attachment indices, see attribtue "index" of 
              PhysxVehicleWheelAttachmentAPI) assigned to track 0, followed by the wheels assigned to
              track 1 and so on. The length of the array is expected to be equal (or larger than) the number
              of wheels that are assigned to tracks."""
	)
}

class "PhysxVehicleBrakesAPI"
(
    doc = """Describes a braking system for a vehicle by specifying which wheels are connected to the
          brake control and by defining the brake torque that gets applied to those wheels. Currently,
          up to two braking systems are supported. Use the instance name TfToken "brakes0" and "brakes1"
          of this multipleApply schema to distinguish between the two braking systems. Note that system
          "brakes0" will be coupled to the brake control brake0 while system "brakes1" will be coupled
          to the brake control brake1 (see PhysxVehicleControllerAPI for the brake controls). An example
          for using two systems is to provide brake and handbrake control (the former applying brake
          torque to all wheels and the latter applying brake torque to the rear wheels only). This API
          schema has to be applied to a prim with PhysxVehicleAPI applied. Can only be used for vehicles
          that have a drive (see PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI)."""
    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "physxVehicleBrakes"
    }
    inherits = </APISchemaBase>
)
{
    int[] wheels (
        customData = {
            string apiName = "wheels"
        }
        displayName = "Wheels"
        doc = """List of indices, referencing the wheels that receive brake torque. The indices
              refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI. If not specified,
              each wheel will receive a brake torque using a torque multiplier of 1 (see attribute
              torqueMultipliers)."""
    )
    
    float maxBrakeTorque = 0 (
        customData = {
            string apiName = "maxBrakeTorque"
        }
        displayName = "Max Brake Torque"
        doc = """The maximum brake torque that can be generated by the braking system
              (units: mass * distance * distance / seconds / seconds). Has to be greater or equal
              zero. For braking system "brakes0", the brake torque applied to wheels[i] will be
              defined by maxBrakeTorque * torqueMultipliers[i] * physxVehicleController:brake0
              (see PhysxVehicleControllerAPI)."""
    )

    float[] torqueMultipliers (
        customData = {
            string apiName = "torqueMultipliers"
        }
        displayName = "Torque Multipliers"
        doc = """Defines how much of the max brake torque can be delivered to the wheels that are
              connected to the braking system. The values are unitless multipliers and have to be
              greater or equal to zero. See maxBrakeTorque for how these multipliers affect the
              brake torque applied to a wheel. If the attribute is defined, then the length of the
              array needs to match the length of the "wheels" array. If the attribute is not defined,
              a multiplier value of 1 will be used for all connected wheels."""
    )
}

class "PhysxVehicleSteeringAPI"
(
    doc = """Describes a steering system for a vehicle by specifying which wheels are connected to the
          steer control and by defining the maximum steer angle for those wheels (see PhysxVehicleControllerAPI
          for the steer control). This API schema has to be applied to a prim with PhysxVehicleAPI applied.
          Can only be used for vehicles that have a drive (see PhysxVehicleDriveBasicAPI or
          PhysxVehicleDriveStandardAPI)."""
    inherits = </APISchemaBase>
)
{
    int[] physxVehicleSteering:wheels (
        customData = {
            string apiName = "wheels"
        }
        displayName = "Wheels"
        doc = """List of indices, referencing the wheels that are going to be steered. The indices
              refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI. If not specified,
              every wheel will be affected by the steer control using an angle multiplier of 1
              (see attribute angleMultipliers)."""
    )
    
    float physxVehicleSteering:maxSteerAngle = 0 (
        customData = {
            string apiName = "maxSteerAngle"
        }
        displayName = "Max Steer Angle"
        doc = """The maximum steer angle (in radians) that can be achieved by the wheels.
              Has to be in range [-pi, pi] when multiplied by the attribute angleMultipliers.
              The steer angle of wheels[i] will be defined by maxSteerAngle * angleMultipliers[i] * 
              physxVehicleController:steer (see PhysxVehicleControllerAPI)."""
    )

    float[] physxVehicleSteering:angleMultipliers (
        customData = {
            string apiName = "angleMultipliers"
        }
        displayName = "Angle Multipliers"
        doc = """Allows to adjust the max steer angle for each wheel that is steered. The values are
              unitless multipliers. See maxSteerAngle for how these multipliers affect the steer
              angle of a wheel. If the attribute is defined, then the length of the array needs
              to match the length of the "wheels" array. If the attribute is not defined,
              a multiplier value of 1 will be used for all steered wheels."""
    )
}

class "PhysxVehicleAckermannSteeringAPI"
(
    doc = """Describes a steering system with Ackermann correction for two wheels. This system will
          result in asymmetric steer angles such that the line defined by the non-steered wheel axle
          and the lateral lines of the steered wheels meet at the same point. As a consequence, when
          following the path around a curve, the inner wheel will turn more than the outer one. This
          avoids that some wheels need to slip sideways to stay on the path. The specified wheels
          will be connected to the steer control (see PhysxVehicleControllerAPI). This API schema
          has to be applied to a prim with PhysxVehicleAPI applied. Can only be used for vehicles that
          have a drive (see PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI). This API
          schema can not be combined with PhysxVehicleSteeringAPI, only one or the other is allowed."""
    inherits = </APISchemaBase>
)
{
    int physxVehicleAckermannSteering:wheel0 (
        customData = {
            string apiName = "wheel0"
        }
        displayName = "Wheel 0"
        doc = """The index of the wheel that is negative along the lateral axis and should get
              connected to the steering system. The index refers to the attribute "index" of
              PhysxVehicleWheelAttachmentAPI.
              
              Note: this attribute has to be specified (there is no default)."""
    )
    
    int physxVehicleAckermannSteering:wheel1 (
        customData = {
            string apiName = "wheel1"
        }
        displayName = "Wheel 1"
        doc = """The index of the wheel that is positive along the lateral axis and should get
              connected to the steering system. The index refers to the attribute "index" of
              PhysxVehicleWheelAttachmentAPI.
              
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleAckermannSteering:maxSteerAngle = 0 (
        customData = {
            string apiName = "maxSteerAngle"
        }
        displayName = "Max Steer Angle"
        doc = """The maximum steer angle (in radians) that can be achieved by the wheels.
              Has to be in range [-pi, pi]. The steer angle of wheel0 will be defined by 
              maxSteerAngle * ackermann_correction(0) * physxVehicleController:steer (see PhysxVehicleControllerAPI)."""
    )
    
    float physxVehicleAckermannSteering:wheelBase (
        customData = {
            string apiName = "wheelBase"
        }
        displayName = "Wheel Base"
        doc = """The longitudinal distance between the axle that is affected by Ackermann
              correction and a reference axle (units: distance). The value has to be greater
              than zero.
              
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleAckermannSteering:trackWidth (
        customData = {
            string apiName = "trackWidth"
        }
        displayName = "Track Width"
        doc = """The width of the axle defined by wheel0 and wheel1 (units: distance).
              The value has to be greater than zero.
              
              Note: this attribute has to be specified (there is no default)."""
    )
    
    float physxVehicleAckermannSteering:strength = 1 (
        customData = {
            string apiName = "strength"
        }
        displayName = "Strength"
        doc = """The strength of the Ackermann correction with 0 denoting no correction and
              1 denoting perfect correction. The value has to be in range [0, 1]."""
    )
}

class "PhysxVehicleAPI"
(
    doc = """PhysX vehicle. Has to be applied to a prim with PhysicsRigidBodyAPI applied. Wheels can be added by applying PhysxVehicleWheelAttachmentAPI to a prim that is a descendant of the "vehicle" prim.
    
          Note: if the prim has PhysxRigidBodyAPI applied, it should be configured such that disableGravity is set to true since the vehicle simulation will take gravity into account already."""
    inherits = </APISchemaBase>
)
{
    bool physxVehicle:vehicleEnabled = true (
        customData = {
            string apiName = "vehicleEnabled"
        }
        displayName = "Vehicle Simulation Enabled"
        doc = """Defines whether the vehicle simulation update loop will run for the vehicle or not.
              
              Note: if set to false, the prim's rigid body will still get simulated (the PhysicsRigidBodyAPI API schema
              can be used to turn the body into a kinematic or set velocities to zero at that point).
              
              Note: it is an illegal setup to have a vehicle enabled, while the prim's rigid body is disabled or kinematic."""
    )

    rel physxVehicle:drive (
        customData = {
            string apiName = "drive"
        }
        displayName = "Drive"
        doc = """A relationship to a PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI prim that describes the 
                 drive model. If none is specified, it is up to the user to apply torque to the wheels. It is also
                 possible to apply PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI to the prim directly. In 
                 that case the relationship must not be defined."""
    )
    
    uniform token physxVehicle:suspensionLineQueryType = "raycast" (
        allowedTokens = ["raycast", "sweep"]
        customData = {
            string apiName = "suspensionLineQueryType"
        }
        displayName = "Suspension Line Query Type"
        doc = """Collision of the wheels with the ground surface is detected through scene queries along the suspension direction. 
              This attribute defines whether a raycast or a sweep should be used as the query type. Raycasts are faster while sweeps
              can represent the wheel shape better and thus react earlier to ground surface changes."""
    )
    
    bool physxVehicle:limitSuspensionExpansionVelocity = false (
        customData = {
            string apiName = "limitSuspensionExpansionVelocity"
        }
        displayName = "Limit Suspension Expansion Velocity"
        doc = """Limit the suspension expansion dynamics.
              
              When a hit with the ground is detected, the suspension jounce will be set such that the wheel
	          is placed on the ground. This can result in large changes to jounce within a single simulation
              frame, if the ground surface has high frequency or if the simulation time step is large. As a
              result, large damping forces can evolve and cause undesired behavior. If this parameter is set
              to true, the suspension expansion speed will be limited to what can be achieved given the time
              step, suspension stiffness etc. As a consequence, handling of the vehicle will be affected as
              the wheel might loose contact with the ground more easily.
              
              Note: this will apply to the suspensions of all wheels."""
    )
    
    float physxVehicle:subStepThresholdLongitudinalSpeed (
        customData = {
            string apiName = "subStepThresholdLongitudinalSpeed"
        }
        displayName = "Sub-step Threshold Longitudinal Speed"
        doc = """Threshold speed that is used to categorize vehicle speed as low speed or high speed for
              choosing the sub-step count (units: distance / seconds).
              
              Note: if not defined, the value 5.0 will be used. This default value is in meter length scale 
              and will get adjusted if another unit is used."""
    )
    
    int physxVehicle:lowForwardSpeedSubStepCount (
        customData = {
            string apiName = "lowForwardSpeedSubStepCount"
        }
        displayName = "Low Forward Speed Sub-step Count"
        doc = """Number of sub-steps performed in the vehicle dynamics update for vehicles that have
              longitudinal speed lower than subStepThresholdLongitudinalSpeed.
              
              Note: if not defined, the value 3 will be used."""
    )
    
    int physxVehicle:highForwardSpeedSubStepCount (
        customData = {
            string apiName = "highForwardSpeedSubStepCount"
        }
        displayName = "High Forward Speed Sub-step Count"
        doc = """Number of sub-steps performed in the vehicle dynamics update for vehicles that have
              longitudinal speed greater than subStepThresholdLongitudinalSpeed.
              
              Note: if not defined, the value 1 will be used."""
    )
    
    float physxVehicle:minLongitudinalSlipDenominator (
        customData = {
            string apiName = "minLongitudinalSlipDenominator"
        }
        displayName = "Min Longitudinal Slip Denominator"
        doc = """Deprecated. Please use minPassiveLongitudinalSlipDenominator instead.
              
              The minimum denominator used in the longitudinal slip calculation (units: distance / seconds).
              For low longitudinal velocities, the computation of the longitudinal slip can become 
              unstable. This value defines the minimum velocity to use when computing the longitudinal slip.
              
              Note: will be ignored if minPassiveLongitudinalSlipDenominator is used.
              
              Note: if not defined, the value 4.0 will be used. This default value is in meter length scale 
              and will get adjusted if another unit is used."""
    )
    
    float physxVehicle:minPassiveLongitudinalSlipDenominator = 0 (
        customData = {
            string apiName = "minPassiveLongitudinalSlipDenominator"
        }
        displayName = "Min Passive Longitudinal Slip Denominator"
        doc = """The minimum denominator used in the longitudinal slip calculation when a wheel experiences no
              drive and no brake torque (units: distance / seconds). For low longitudinal velocities, the
              computation of the longitudinal slip can become unstable. This value defines the minimum velocity
              to use when computing the longitudinal slip. The value has to be positive.
              
              Note: the default value 0 is not a valid value as such but indicates that the deprecated
              attribute minLongitudinalSlipDenominator should be used instead.
              
              Note: it is recommended to have minActiveLongitudinalSlipDenominator < minPassiveLongitudinalSlipDenominator."""
    )
    
    float physxVehicle:minActiveLongitudinalSlipDenominator = 0 (
        customData = {
            string apiName = "minActiveLongitudinalSlipDenominator"
        }
        displayName = "Min Active Longitudinal Slip Denominator"
        doc = """The minimum denominator used in the longitudinal slip calculation when a wheel experiences
              drive or brake torque (units: distance / seconds). For low longitudinal velocities, the
              computation of the longitudinal slip can become unstable. This value defines the minimum velocity
              to use when computing the longitudinal slip. The value has to be positive.
              
              Note: the default value 0 is not a valid value as such but will result in the value 0.1 being
              used (in meter length scale or the equivalent if another unit is used).
              
              Note: it is recommended to have minActiveLongitudinalSlipDenominator < minPassiveLongitudinalSlipDenominator."""
    )
    
    float physxVehicle:minLateralSlipDenominator = 0 (
        customData = {
            string apiName = "minLateralSlipDenominator"
        }
        displayName = "Min Lateral Slip Denominator"
        doc = """The minimum denominator used in the lateral slip calculation (units: distance / seconds).
              For low longitudinal velocities, the computation of the lateral slip can become unstable.
              This value defines the minimum longitudinal velocity to use when computing the lateral slip.
              The value has to be positive.
              
              Note: the default value 0 is not a valid value as such but will result in the value 1.0 being
              used (in meter length scale or the equivalent if another unit is used).
              
              Note: larger simulation timesteps typically require larger values of minLateralSlipDenominator."""
    )
    
    float physxVehicle:longitudinalStickyTireThresholdSpeed = -1 (
        customData = {
            string apiName = "longitudinalStickyTireThresholdSpeed"
        }
        displayName = "Longitudinal Sticky Tire Threshold Speed"
        doc = """The longitudinal sticky tire threshold speed (units: distance / seconds). Has to be greater 
              or equal 0. A tire enters the "sticky tire" regime when its longitudinal speed has been below
              this threshold for a continuous time specified by longitudinalStickyTireThresholdTime. At low
              speeds with no significant brake or drive torque, numerical error begins to dominate and it
              can be difficult to bring the vehicle to rest. A solution to this problem is to recognise that
              the vehicle is close to rest and to replace the tire forces with velocity constraints that will
              bring the vehicle to rest. For the purpose of this documentation, this regime is referred to as
              the "sticky tire" regime.
              
              Note: the default value -1 is not a valid value as such but will result in the value 0.2 being
              used (in meter length scale or the equivalent if another unit is used)."""
    )
    
    float physxVehicle:longitudinalStickyTireThresholdTime = 1 (
        customData = {
            string apiName = "longitudinalStickyTireThresholdTime"
        }
        displayName = "Longitudinal Sticky Tire Threshold Time"
        doc = """The longitudinal sticky tire threshold time (in seconds). Has to be greater or equal 0.
              A tire enters the "sticky tire" regime when it has been below the speed specified by
              longitudinalStickyTireThresholdSpeed for this continuous time. More details on the
              "sticky tire" regime can be found in the documentation of the longitudinalStickyTireThresholdSpeed
              attribute."""
    )
    
    float physxVehicle:longitudinalStickyTireDamping = 200 (
        customData = {
            string apiName = "longitudinalStickyTireDamping"
        }
        displayName = "Longitudinal Sticky Tire Damping"
        doc = """The longitudinal sticky tire damping (per seconds). Has to be greater or equal 0.
              Describes the rate at which the velocity constraint approaches zero when entering the "sticky tire"
              regime. More details on the "sticky tire" regime can be found in the documentation of the
              longitudinalStickyTireThresholdSpeed attribute.
              
              Note: larger values of damping lead to faster approaches to zero. Since the damping behaves
                    like a stiffness with respect to the velocity, too large a value can lead to instabilities."""
    )
    
    float physxVehicle:lateralStickyTireThresholdSpeed = -1 (
        customData = {
            string apiName = "lateralStickyTireThresholdSpeed"
        }
        displayName = "Lateral Sticky Tire Threshold Speed"
        doc = """The lateral sticky tire threshold speed (units: distance / seconds). See documentation about
              longitudinalStickyTireThresholdSpeed as it is the same concept. Note that the lateral part
              can only enter the "sticky tire" regime if the longitudinal speed is below longitudinalStickyTireThresholdSpeed.
              
              Note: the default value -1 is not a valid value as such but will result in the value 0.2 being
              used (in meter length scale or the equivalent if another unit is used)."""
    )
    
    float physxVehicle:lateralStickyTireThresholdTime = 1 (
        customData = {
            string apiName = "lateralStickyTireThresholdTime"
        }
        displayName = "Lateral Sticky Tire Threshold Time"
        doc = """The lateral sticky tire threshold time (in seconds). See documentation about
              longitudinalStickyTireThresholdTime as it is the same concept."""
    )
    
    float physxVehicle:lateralStickyTireDamping = 20 (
        customData = {
            string apiName = "lateralStickyTireDamping"
        }
        displayName = "Lateral Sticky Tire Damping"
        doc = """The lateral sticky tire damping (per seconds). See documentation about
              longitudinalStickyTireDamping as it is the same concept.
              
              Note: larger values of damping lead to faster approaches to zero. Since the damping behaves
                    like a stiffness with respect to the velocity, too large a value can lead to instabilities."""
    )
}

class "PhysxVehicleControllerAPI"
(
    doc = """PhysX vehicle controller that samples user input to drive the vehicle. Has to be applied to a prim with PhysxVehicleAPI applied."""
    inherits = </APISchemaBase>
)
{
    float physxVehicleController:accelerator = 0 (
        customData = {
            string apiName = "accelerator"
        }
        displayName = "Accelerator"
        doc = """Driven vehicle. Throttle input, 0.0 to 1.0."""
    )
    
    float physxVehicleController:brake0 = 0 (
        customData = {
            string apiName = "brake0"
        }
        displayName = "Brake 0"
        doc = """Brake control for braking system "brakes0" (see PhysxVehicleBrakesAPI)
                 that triggers the connected brakes and defines the brake strength.
                 Value has to be in range [0.0, 1.0]."""
    )
    
    float physxVehicleController:brake1 = 0 (
        customData = {
            string apiName = "brake1"
        }
        displayName = "Brake 1"
        doc = """Brake control for braking system "brakes1" (see PhysxVehicleBrakesAPI)
                 that triggers the connected brakes and defines the brake strength.
                 Value has to be in range [0.0, 1.0]."""
    )
    
    float physxVehicleController:brake = 0 (
        customData = {
            string apiName = "brake"
        }
        displayName = "Brake"
        doc = """Deprecated. Please use brake0/brake1 instead.
              
              Driven vehicle. Brake input, 0.0 to 1.0."""
    )
    
    float physxVehicleController:handbrake = 0 (
        customData = {
            string apiName = "handbrake"
        }
        displayName = "Handbrake"
        doc = """Deprecated. Please use brake0/brake1 instead.
              
              Driven vehicle. Handbrake input, 0.0 to 1.0."""
    )
    
    float physxVehicleController:steer = 0 (
        customData = {
            string apiName = "steer"
        }
        displayName = "Steer"
        doc = """Steer control for the steering system (see PhysxVehicleSteeringAPI).
                 Defines the extent of the wheels' steer angles with respect to the
                 maximum steer angle. Value has to be in range [-1.0, 1.0]."""
    )
    
    float physxVehicleController:steerLeft = 0 (
        customData = {
            string apiName = "steerLeft"
        }
        displayName = "Steer Left"
        doc = """Deprecated. Please use steer instead.
              
              Driven vehicle. Left steering input. 0.0 to 1.0. Net steering is the aggregate of steerRight and steerLeft."""
    )
    
    float physxVehicleController:steerRight = 0 (
        customData = {
            string apiName = "steerRight"
        }
        displayName = "Steer Right"
        doc = """Deprecated. Please use steer instead.
              
              Driven vehicle. Right steering input, 0.0 to 1.0. Net steering is the aggregate of steerRight and steerLeft."""
    )

    int physxVehicleController:targetGear = 255 (
        customData = {
            string apiName = "targetGear"
        }
        displayName = "Target Gear"
        doc = """Driven vehicle. Desired gear to shift into. -1 = Reverse, 0 = Neutral, 1 = First etc.
              The special value 255 is used to denote automatic forward gear shifting (similar to <D> in
              automatic transmissions).
              
              Note: if set to automatic gear shifting, the vehicle is expected to have an autobox
                    defined (see PhysxVehicleAutoGearBoxAPI).
        
              Note: please be aware that the target gear definition differs from the PhysX vehicle API."""
    )
}

class "PhysxVehicleTankControllerAPI"
(
	doc = """PhysX vehicle tank controller to divert torque from the engine to the wheels of the tracks
          of a wheel based tank vehicle (see PhysxVehicleTankDifferentialAPI). Note that the "accelerator"
          attribute of PhysxVehicleControllerAPI still drives the engine torque whereas the thrust controls
          introduced here define how that torque gets diverted to the wheels, so both controls need to
          be used to drive a wheel based tank vehicle usually. This API schema has to be applied to a prim
          with PhysxVehicleAPI applied. Can only be used for vehicles that have a standard drive and a
          tank differential defined (see PhysxVehicleDriveStandardAPI, PhysxVehicleTankDifferentialAPI)."""
	inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxVehicleControllerAPI"]
)
{
    float physxVehicleTankController:thrust0 = 0 (
		customData = {
			string apiName = "thrust0"
		}
        displayName = "Thrust 0"
		doc = """Magnitude of thrust to apply to the tracks that are assigned to thrust control 0.
              Values have to be in [-1.0, 1.0] with the sign dictating whether the thrust will be
              applied positively or negatively with respect to the gearing ratio."""
	)
    
    float physxVehicleTankController:thrust1 = 0 (
		customData = {
			string apiName = "thrust1"
		}
        displayName = "Thrust 1"
		doc = """Magnitude of thrust to apply to the tracks that are assigned to thrust control 1.
              Values have to be in [-1.0, 1.0] with the sign dictating whether the thrust will be
              applied positively or negatively with respect to the gearing ratio."""
	)
}

class "PhysxVehicleWheelControllerAPI"
(
    doc = """PhysX wheel controller that samples user input and allows direct control of the wheel torques and steer angle to drive the vehicle. Has to be applied to a prim with PhysxVehicleWheelAttachmentAPI applied and be a descendant of a prim with a PhysxVehicleAPI applied."""
    inherits = </APISchemaBase>
)
{
    float physxVehicleWheelController:driveTorque = 0 (
        customData = {
            string apiName = "driveTorque"
        }
        displayName = "Drive Torque"
        doc = "Torque to increase wheel angular rate and speed up (units: mass * distance * distance / seconds / seconds)."
    )
    
    float physxVehicleWheelController:brakeTorque = 0 (
        customData = {
            string apiName = "brakeTorque"
        }
        displayName = "Brake Torque"
        doc = """Torque to decrease wheel angular rate and slow down (units: mass * distance * distance / seconds / seconds).
              The value has to be greater or equal zero."""
    )
    
    float physxVehicleWheelController:steerAngle = 0 (
        customData = {
            string apiName = "steerAngle"
        }
        displayName = "Steer Angle"
        doc = "Steer angle of the wheel in radians."
    )
}

class "PhysxVehicleNonlinearCommandResponseAPI"
(
    doc = """Describes a system of graphs to define nonlinear responses to PhysxVehicleControllerAPI
          command values like accelerator, brake0, brake1 and steer. The normalized response will be
          a function of the command value and the longitudinal vehicle speed. The response will be
          computed by interpolating between the points of the graph and then interpolating those
          results again between the closest graphs. One example usage of nonlinear command response
          is a brake pedal that has an almost flat response when tipped slightly but a very strong
          response from a certain point on. Another example is the steering wheel showing a strong
          response for a large input at low speed but only a weak response at high speed.

          This multipleApply schema can be used to control the response to steering (use instance name
          TfToken "steer") and braking (use instance name TfTokens "brakes0" or "brakes1"). It can
          also control the response to the accelerator but only in combination with the basic drive (use
          instance name TfToken "drive"). Furthermore, this API has to be applied to the appropriate
          prims to take effect: "steer" has to be applied to a prim that has PhysxVehicleSteeringAPI or
          PhysxVehicleAckermannSteeringAPI applied. "brakes0"/"brakes1" have to be applied to a prim that
          has PhysxVehicleBrakesAPI:brakes0/brakes1 applied. "drive" has to be applied to a prim that
          has PhysxVehicleDriveBasicAPI applied."""
    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "physxVehicleNCR"
    }
    inherits = </APISchemaBase>
)
{
    float[] commandValues (
        customData = {
            string apiName = "commandValues"
        }
        displayName = "Command Values"
        doc = """The command values to define response graphs for. Each listed command value
              (in range [0, 1], steer commands are treated symmetrically) has to point to a graph
              in speedResponses. The command values refer to steer, brake0 etc. The values
              have to be strictly increasing. The number of entries has to match the number of
              entries in speedResponsesPerCommandValue and is limited to 8. Every command value
              needs at least one entry in speedResponses."""
    )
    
    int[] speedResponsesPerCommandValue (
        customData = {
            string apiName = "speedResponsesPerCommandValue"
        }
        displayName = "Speed Responses Per Command Value"
        doc = """List of indices pointing to the start of a response graph for a certain command
              value. The index values have to be strictly increasing. The graph for command
              value commandValues[i] starts at entry speedResponses[speedResponsesPerCommandValue[i]]
              and stops at entry speedResponses[speedResponsesPerCommandValue[i+1] - 1]. The
              number of entries has to match the number of entries in commandValues and has the
              same maximum limit."""
    )
    
    float2[] speedResponses (
        customData = {
            string apiName = "speedResponses"
        }
        displayName = "Speed Responses"
        doc = """List of pairs that define points in graphs of longitudinal speed vs. normalized
              response. The first value of the pair is the longitudinal speed, the second value
              is the expected response (in range [0, 1]). The longitudinal speed values within
              a graph have to be strictly increasing. The maximum allowed number of entries is 64.
              See speedResponsesPerCommandValue for how the different graphs are accessed."""
    )
}

class "PhysxCameraAPI"
(
    doc = """PhysX camera."""
    inherits = </APISchemaBase>
)
{
    bool alwaysUpdateEnabled = True (
        customData = {
            string apiName = "alwaysUpdateEnabled"
        }

        displayName = "Always Update Enabled"
        doc = """When enabled, always update this camera whether it is the active camera or not. This prevents cameras from slewing 
                 into position when switching to a new active camera. When disabled, only the active camera is updated, saving time."""
    )
 
    rel physxCamera:subject (
        displayName = "Subject"
        doc = "Reference to the subject this camera is to track."
    )
}

class "PhysxCameraFollowAPI"
(
	doc = """PhysX camera that follows behind the subject as it moves."""
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxCameraAPI"]
)
{
    float physxFollowCamera:yawAngle (
        customData = {
            string apiName = "yawAngle"
        }
        displayName = "Yaw Angle"
        doc = """The yaw angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 0 degrees"""
    )
    
    float physxFollowCamera:pitchAngle (
        customData = {
            string apiName = "pitchAngle"
        }
        displayName = "Pitch Angle"
        doc = """The pitch angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 15 degrees"""
    )
         
    float physxFollowCamera:pitchAngleTimeConstant (
        customData = {
            string apiName = "pitchAngleTimeConstant"
        }
        displayName = "Pitch Angle Time Constant"
        doc = """Time constant to filter the pitch angle, in seconds. Used to pitch the camera up and down when driving up or down hills. e.g. 0.2 seconds"""
    )
    
    float physxFollowCamera:slowSpeedPitchAngleScale (
        customData = {
            string apiName = "slowSpeedPitchAngleScale"
        }
        displayName = "Slow Speed Pitch Angle Scale"
        doc = """Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 0.5"""
    )
         
    float physxFollowCamera:slowPitchAngleSpeed (
        customData = {
            string apiName = "slowPitchAngleSpeed"
        }
        displayName = "Slow Pitch Angle Speed"
        doc = """Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 1000 cm/sec"""
    )

    float physxFollowCamera:velocityNormalMinSpeed (
        customData = {
            string apiName = "velocityNormalMinSpeed"
        }
        displayName = "Velocity Normal Min Speed"
        doc = """The minimum speed, below which, the subject look vector must be used because the normalized velocity vector is too erratic. e.g. 600.0 cm/sec"""    
    )

    float physxFollowCamera:followMinSpeed (
        customData = {
            string apiName = "followMinSpeed"
        }
        displayName = "Follow Min Speed"
        doc = """The minimum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 300.0 cm/sec"""
    )
    
    float physxFollowCamera:followMinDistance (
        customData = {
            string apiName = "followMinDistance"
        }
        displayName = "Follow Min Distance"
        doc = """The minimum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm"""
    )
    
    float physxFollowCamera:followMaxSpeed (
        customData = {
            string apiName = "followMaxSpeed"
        }
        displayName = "Follow Max Speed"
        doc = """The maximum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm/sec"""
    )
    
    float physxFollowCamera:followMaxDistance (
        customData = {
            string apiName = "followMaxDistance"
        }
        displayName = "Follow Max Distance"
        doc = """The maximum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1000.0 cm"""
    )

    float physxFollowCamera:yawRateTimeConstant (
        customData = {
            string apiName = "yawRateTimeConstant"
        }
        displayName = "Yaw Rate Time Constant"
        doc = """Time constant to filter the subject yaw rate, in seconds. Use to look into turns. e.g. 0.2 sec"""
    )
        
    float physxFollowCamera:followTurnRateGain (
        customData = {
            string apiName = "followTurnRateGain"
        }
        displayName = "Follow Turn Rate Gain"
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera position behind the subject. Can be any positive or negative number. e.g. 0.2"""
    )
    
    float3 physxFollowCamera:cameraPositionTimeConstant (
        customData = {
            string apiName = "cameraPositionTimeConstant"
        }
        displayName = "Camera Position Time Constant"
        doc = """Filter time constant for the position of the camera for each axis, in seconds. e.g. (0.5 sec, 0.1 sec, 0.5 sec)"""
    )
    
    float3 physxFollowCamera:positionOffset (
        customData = {
            string apiName = "positionOffset"
        }
        displayName = "Position Offset"
        doc = """Position offset from the subject center of mass from which the camera follow vector and look vector are computed. e.g. (0.0 cm, 10.0 cm, 0.0 cm)"""
    )

    float physxFollowCamera:lookAheadMinSpeed (
        customData = {
            string apiName = "lookAheadMinSpeed"
        }
        displayName = "Look Ahead Min Speed"
        doc = """The minimum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm/sec"""
    )
    
    float physxFollowCamera:lookAheadMinDistance (
        customData = {
            string apiName = "lookAheadMinDistance"
        }
        displayName = "Look Ahead Min Distance"
        doc = """The minimum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm"""
    )
    
    float physxFollowCamera:lookAheadMaxSpeed (
        customData = {
            string apiName = "lookAheadMaxSpeed"
        }
        displayName = "Look Ahead Max Speed"
        doc = """The maximum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 2000.0 cm"""
    )
    
    float physxFollowFollowCamera:lookAheadMaxDistance (
        customData = {
            string apiName = "lookAheadMaxDistance"
        }
        displayName = "Look Ahead Max Distance"
        doc = """The maximum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g.  500.0 cm"""
    )
    
    float physxFollowCamera:lookAheadTurnRateGain (
        customData = {
            string apiName = "lookAheadTurnRateGain"
        }
        displayName = "Look Ahead Turn Rate Gain"
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera look point left or right. Can be any positive or negative number. e.g. 0.2"""
    )
        
    float physxFollowCamera:lookPositionHeight (
        customData = {
            string apiName = "lookPositionHeight"
        }
        displayName = "Look Position Height"
        doc = """Distance to elevate the camera look point. e.g. 50.0 cm"""
    )
    
    float3 physxFollowCamera:lookPositionTimeConstant (
        customData = {
            string apiName = "lookPositionTimeConstant"
        }
        displayName = "Look Position Time Constant"
        doc = """Filter time constant for the camera look point, in seconds. e.g. (0.2 sec, 0.5 sec, 0.2 sec)"""
    )
}

class "PhysxCameraFollowLookAPI"
(
	doc = """PhysX camera that follows behind the subject's forward vector as it moves. Assumes the subject is always upright and does not roll."""
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxCameraFollowAPI"]
)
{
    float physxFollowLookCamera:downHillGroundAngle (
        customData = {
            string apiName = "downHillGroundAngle"
        }
        displayName = "Downhill Ground Angle"
        doc = """The minimum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. -45.0 degrees"""
    )
         
    float physxFollowLookCamera:downHillGroundPitch (
        customData = {
            string apiName = "downHillGroundPitch"
        }
        displayName = "Downhill Ground Pitch"
        doc = """The minimum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"""
    )

    float physxFollowLookCamera:upHillGroundAngle (
        customData = {
            string apiName = "upHillGroundAngle"
        }
        displayName = "Uphill Ground Angle"
        doc = """The maximum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. 45.0 degrees"""
    )
         
    float physxFollowLookCamera:upHillGroundPitch (
        customData = {
            string apiName = "upHillGroundPitch"
        }
        displayName = "Uphill Ground Pitch"
        doc = """The maximum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"""
    )

    float physxFollowLookCamera:velocityBlendTimeConstant (
        customData = {
            string apiName = "velocityBlendTimeConstant"
        }
        displayName = "Velocity Blend Time Constant"
        doc = """Filter time constant to blend between the look and velocity vectors, in seconds. e.g. 0.1 seconds"""
    )
    
    float physxFollowLookCamera:followReverseSpeed (
        customData = {
            string apiName = "followReverseSpeed"
        }
        displayName = "Follow Reverse Speed"
        doc = """The positive, maximum speed, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm/sec"""
    )
    
    float physxFollowLookCamera:followReverseDistance (
        customData = {
            string apiName = "followReverseDistance"
        }
        displayName = "Follow Reverse Distance"
        doc = """The maximum distance, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm"""
    )
}

class "PhysxCameraFollowVelocityAPI"
(
	doc = """PhysX camera that follows behind the subject's velocity vector as it moves, which allows the subject to roll and tumble."""
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxCameraFollowAPI"]
)
{
}

class "PhysxCameraDroneAPI"
(
	doc = """PhysX drone camera that follows its subject from the air as it drives."""
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxCameraAPI"]
)
{
    float physxDroneCamera:followHeight (
        customData = {
            string apiName = "followHeight"
        }
        displayName = "Follow Height"
        doc = """The height above the subject that the drone attmepts to maintain. e.g. 15 meters"""
    )
    
    float physxDroneCamera:followDistance (
        customData = {
            string apiName = "followDistance"
        }
        displayName = "Follow Distance"
        doc = """The distance from the subject that the drone attempts to maintain. e.g. 30 meters"""
    )
         
    float physxDroneCamera:maxDistance (
        customData = {
            string apiName = "maxDistance"
        }
        displayName = "Max Distance"
        doc = """The maximum distance allowed from the subject before the drone resets to the target position. e.g. 100 meters"""
    )
    
    float physxDroneCamera:maxSpeed (
        customData = {
            string apiName = "maxSpeed"
        }
        displayName = "Max Speed"
        doc = """The maximum speed the drone is allowed to move. e.g. 20.0 meters/second"""
    )
         
    float physxDroneCamera:horizontalVelocityGain (
        customData = {
            string apiName = "horizontalVelocityGain"
        }
        displayName = "Horizontal Velocity Gain"
        doc = """The higher the gain, the faster the drone will accelerate towards the target position. e.g. 1.0"""
    )
                
    float physxDroneCamera:verticalVelocityGain (
        customData = {
            string apiName = "verticalVelocityGain"
        }
        displayName = "Vertical Velocity Gain"
        doc = """The higher the gain, the higher the climb or descent rate of the drone to get to the target altitude. e.g. 1.0"""
    )
         
    float physxDroneCamera:feedForwardVelocityGain (
        customData = {
            string apiName = "feedForwardVelocityGain"
        }
        displayName = "Feed Forward Velocity Gain"
        doc = """The higher the gain, the more closely the drone will match the velocity of the subject and the more connected it will appear. e.g. 0.1"""
    )

    float physxDroneCamera:velocityFilterTimeConstant (
        customData = {
            string apiName = "velocityFilterTimeConstant"
        }
        displayName = "Velocity Filter Time Constant"
        doc = """The velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 1.0 seconds"""
    )
         
    float physxDroneCamera:rotationFilterTimeConstant (
        customData = {
            string apiName = "rotationFilterTimeConstant"
        }
        displayName = "Rotation Filter Time Constant"
        doc = """The angular velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 0.2 seconds"""
    )
    
    float3 physxDroneCamera:positionOffset (
        customData = {
            string apiName = "positionOffset"
        }
        displayName = "Position Offset"
        doc = """An offset vector from the subject origin at which the drone looks. e.g. (0.0 m, 0.0 m, 0.0 m)"""
    )
}

// 5.0 particles

class PhysxParticleSystem "PhysxParticleSystem"
(
    customData = {
        string className = "PhysxParticleSystem"
    }

    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    PhysX particle system, used to simulate fluids, cloth and inflatables. This prim allows the user to configure the
    solver parameters that are common to the particle objects associated with this system via their particleSystem relationship."""
    inherits = </Gprim>
)
{
    bool particleSystemEnabled = True (
        customData = {
            string apiName = "particleSystemEnabled"
        }

        displayName = "Particle System Enabled"
        doc = """Enable or disable the particle system."""
    )

    rel simulationOwner (
        customData = {
            string apiName = "simulationOwner"
        }

        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that simulates this particle system. By default,
        this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )

    float contactOffset = -inf (
        customData = {
            string apiName = "contactOffset"
        }

        displayName = "Contact Offset"
        doc = """Contact offset used for collisions with non-particle objects such as rigid or deformable bodies.
            Must be larger than restOffset. Default value -inf results in a simulation-determined value.
            Range: (restOffset, inf)
            Units: distance"""
    )

    float restOffset = -inf (
        customData = {
            string apiName = "restOffset"
        }

        displayName = "Rest Offset"
        doc = """Rest offset used for collisions with non-particle objects such as rigid or deformable bodies.
            Must be smaller than contact offset. Default value -inf results in a simulation-determined value.
            Range: [0, contactOffset)
            Units: distance"""
    )
    
    float particleContactOffset = 0.05 (
        customData = {
            string apiName = "particleContactOffset"
        }

        displayName = "Particle Contact Offset"
        doc = """Contact offset used for interactions between particles. Must be larger than solid and fluid rest offsets.
            Range: (max(solidRestOffset, fluidRestOffset), inf)
            Units: distance"""
    )
    
    float solidRestOffset = -inf (
        customData = {
            string apiName = "solidRestOffset"
        }

        displayName = "Solid Rest Offset"
        doc = """Rest offset used for solid-solid or solid-fluid particle interactions. Must be smaller than particleContactOffset.
            Default value -inf results in a simulation-determined value.
            Range: [0, particleContactOffset)
            Units: distance"""
    )
    
    float fluidRestOffset = -inf (
        customData = {
            string apiName = "fluidRestOffset"
        }

        displayName = "Fluid Rest Offset"
        doc = """Rest offset used for fluid-fluid particle interactions. Must be smaller than particleContactOffset.
            Default value -inf results in a simulation-determined value.
            Range: [0, particleContactOffset)
            Units: distance"""
    )

    bool enableCCD = False (
        customData = {
            string apiName = "enableCCD"
        }

        displayName = "Enable CCD"
        doc = """Enable continuous collision detection for particles to help avoid tunneling effects."""
    )

    int solverPositionIterationCount = 16 (
        customData = {
            string apiName = "solverPositionIterationCount"
        }

        displayGroup = "Advanced"
        displayName = "Solver Position Iteration Count"
        doc = """Number of solver iterations for position.
            Range: [1, 255]"""
    )

    float maxDepenetrationVelocity = inf (
        customData = {
            string apiName = "maxDepenetrationVelocity"
        }

        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum velocity permitted to be introduced by the solver to depenetrate intersecting particles.
            Range: [0, inf)
            Units: distance / seconds"""
    )

    float3 wind = (0.0, 0.0, 0.0) (
        customData = {
            string apiName = "wind"
        }

        displayName = "Wind"
        doc = """The wind applied to the current particle system.
            Range: (-inf, inf)
            Units: distance / seconds"""
    )

    int maxNeighborhood = 96 (
        customData = {
            string apiName = "maxNeighborhood"
        }

        displayGroup = "Advanced"
        displayName = "Max Neighborhood"
        doc = """The particle neighborhood size."""
    )

    float maxVelocity = inf (
        customData = {
            string apiName = "maxVelocity"
        }

        displayName = "Max Velocity"
        doc = """Maximum particle velocity. See also cflCoefficient in PhysxPBDMaterialAPI for limiting particle-particle relative velocity.
            Range: [0, inf)
            Units: distance / seconds"""
    )

    bool globalSelfCollisionEnabled = True (
        customData = {
            string apiName = "globalSelfCollisionEnabled"
        }

        displayGroup = "Advanced"
        displayName = "Global Self Collision Enabled"
        doc = """If True, self collisions follow particle-object-specific settings. If False, all particle self collisions are disabled, regardless of any other settings.
            Improves performance if self collisions are not needed."""
    )

    bool nonParticleCollisionEnabled = True (
        customData = {
            string apiName = "nonParticleCollisionEnabled"
        }

        displayGroup = "Advanced"
        displayName = "Nonparticle-Objects Collision Enabled"
        doc = """Enable or disable particle collision with nonparticle objects for all particles in the system.
            Improves performance if nonparticle collisions are not needed."""
    )
}

class "PhysxParticleIsosurfaceAPI"
(
    customData = {
        string className = "PhysxParticleIsosurfaceAPI"
    }
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Defines settings to extract an isosurface from the fluid particles in the particle system.
    The isosurface extraction is a post-processing step that does not affect the particle dynamics."""
    inherits = </APISchemaBase>
)
{
    bool physxParticleIsosurface:isosurfaceEnabled = True (
        customData = {
            string apiName = "isosurfaceEnabled"
        }

        displayName = "Isosurface Enabled"
        doc = """Enable or disable the creation of an isosurface."""
    )

    uniform int physxParticleIsosurface:maxVertices = 1048576 (
        customData = {
            string apiName = "maxVertices"
        }

        displayName = "Max Vertices"
        doc = """Maximum number of vertices the extracted isosurface can have.
            Range: [3, inf)"""
    )

    uniform int physxParticleIsosurface:maxTriangles = 2097152 (
        customData = {
            string apiName = "maxTriangles"
        }

        displayName = "Max Triangles"
        doc = """Maximum number of triangles the extracted isosurface can have.
            Range: [1, inf)"""
    )

    uniform int physxParticleIsosurface:maxSubgrids = 2048 (
        customData = {
            string apiName = "maxSubgrids"
        }

        displayName = "Max Subgrids"
        doc = """Maximum number of blocks the sparse grid structure can contain.
            Range: [1, inf)"""
    )

    float physxParticleIsosurface:gridSpacing = -inf (
        customData = {
            string apiName = "gridSpacing"
        }

        displayName = "Grid Spacing"
        doc = """Cell Size of the grid used for isosurface extraction. Default value -inf results in a simulation-determined value.
            Range: [0, inf)
            Units: distance"""
    )

    float physxParticleIsosurface:surfaceDistance = -inf (
        customData = {
            string apiName = "surfaceDistance"
        }

        displayName = "Surface Distance"
        doc = """Distance from particle center to isosurface. Default value -inf results in a simulation-determined value.
            Range: [0, 2.5*gridSpacing)
            Units: distance"""
    )

    string physxParticleIsosurface:gridFilteringPasses = "GSRS" (
        customData = {
            string apiName = "gridFilteringPasses"
        }

        displayName = "Grid Filtering Passes"
        doc = """Grid filtering sequence, defined as capital letters "S":Smooth, "G":Grow, "R":Reduce. Up to 32 passes."""
    )

    float physxParticleIsosurface:gridSmoothingRadius = -inf (
        customData = {
            string apiName = "gridSmoothingRadius"
        }

        displayName = "Grid Smoothing Radius"
        doc = """The radius used during the smoothing process on the grid. Default value -inf results in a simulation-determined value.
            Range: [0, inf)
            Units: dimensionless"""
    )

    int physxParticleIsosurface:numMeshSmoothingPasses = 4 (
        customData = {
            string apiName = "numMeshSmoothingPasses"
        }

        displayName = "Mesh Smoothing Passes"
        doc = """Number of smoothing passes applied to the generated isosurface triangle mesh.
            Range: [0, inf)"""
    )

    int physxParticleIsosurface:numMeshNormalSmoothingPasses = 4 (
        customData = {
            string apiName = "numMeshNormalSmoothingPasses"
        }

        displayName = "Mesh Normal Smoothing Passes"
        doc = """Number of smoothing passes applied to the normals of the generated isosurface triangle mesh.
            Range: [0, inf)"""
    )
}

class "PhysxParticleSmoothingAPI"
(
    customData = {
        string className = "PhysxParticleSmoothingAPI"
    }
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Controls smoothing of simulated particle positions in a post-processing step.
    The smoothing post-processing only affects the rendering output including isosurface generation, and not the particle dynamics.
    Affects point based primitives with PhysxParticleSetAPI, which are defined as fluid."""
    inherits = </APISchemaBase>
)
{
    bool physxParticleSmoothing:particleSmoothingEnabled = True (
        customData = {
            string apiName = "particleSmoothingEnabled"
        }

        displayName = "Particle Smoothing Enabled"
        doc = """Enable or disable smoothingStrength of particle positions."""
    )

    float physxParticleSmoothing:strength = 0.8 (
        customData = {
            string apiName = "strength"
        }

        displayName = "Strength"
        doc = """Smoothing coefficient for particle positions.
            Range: [0, 1]
            Units: dimensionless"""
    )
}

class "PhysxParticleAnisotropyAPI"
(
    customData = {
        string className = "PhysxParticleAnisotropyAPI"
    }
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Defines settings to compute anisotropic scaling of particles in a post-processing step.
    The anisotropy post-processing only affects the rendering output including isosurface generation, and not the particle dynamics.
    Affects point instancer primitives with PhysxParticleSetAPI, which are defined as fluid."""
    inherits = </APISchemaBase>
)
{
    bool physxParticleAnisotropy:particleAnisotropyEnabled = True (
        customData = {
            string apiName = "particleAnisotropyEnabled"
        }

        displayName = "Particle Anisotropy Enabled"
        doc = """Enables use of fluid anisotropy information for rendering."""
    )

    float physxParticleAnisotropy:scale = 1.0 (
        customData = {
            string apiName = "scale"
        }

        displayName = "Scale"
        doc = """Scale of anisotropy for rendering.
            Range: [0, inf)
            Units: dimensionless"""
    )
    
    float physxParticleAnisotropy:min = 0.2 (
        customData = {
            string apiName = "min"
        }

        displayName = "Min"
        doc = """Minimum scale of anisotropy relative to fluidRestOffset for rendering.
            Range: [0, max]
            Units: dimensionless"""
    )
    
    float physxParticleAnisotropy:max = 2.0 (
        customData = {
            string apiName = "max"
        }

        displayName = "Max"
        doc = """Maximum scale of anisotropy relative to fluidRestOffset for rendering.
            Range: [min, inf)
            Units: dimensionless"""
    )
}

class "PhysxDiffuseParticlesAPI"
(
    customData = {
        string className = "PhysxDiffuseParticlesAPI"
    }
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomPoints or UsdGeomPointInstancer primitive with PhysxParticleSetAPI. 
    Defines settings that the particle simulation uses to spawn diffuse particles.
    The diffuse particles are a render-only effect and do not affect the particle dynamics."""
    inherits = </APISchemaBase>
)
{
    bool physxDiffuseParticles:diffuseParticlesEnabled = True (
        customData = {
            string apiName = "diffuseParticlesEnabled"
        }

        displayName = "Diffuse Particles Enabled"
        doc = """Enable or disable the creation of diffuse particles."""
    )

    uniform float physxDiffuseParticles:maxDiffuseParticleMultiplier = -inf (
        customData = {
            string apiName = "maxDiffuseParticleMultiplier"
        }

        displayName = "Max Diffuse Particle Multiplier"
        doc = """Maximum number of diffuse particles that can be present in the simulation relative to the number
              of non-diffuse particles.
              Range: [0.0, inf)
              Default value -inf means default is picked by the simulation."""
    )

    float physxDiffuseParticles:threshold = 0.01 (
        customData = {
            string apiName = "threshold"
        }

        displayName = "Threshold"
        doc = """Kinetic energy threshold a particle must reach to spawn a diffuse particle.
            Range: [0, inf)
            Units: energy = mass * distance * distance / seconds / seconds"""
    )

    float physxDiffuseParticles:lifetime = 5 (
        customData = {
            string apiName = "lifetime"
        }

        displayName = "Lifetime"
        doc = """Lifetime of a spawned particle before it is removed again.
            Range: [0, inf)
            Units: seconds"""
    )
    
    float physxDiffuseParticles:airDrag = 0.0 (
        customData = {
            string apiName = "airDrag"
        }

        displayName = "Air Drag"
        doc = """Air drag force factor for spray particles.
            Range: [0, inf)
            Units: dimensionless """
    )
    
    float physxDiffuseParticles:bubbleDrag = 0.5 (
        customData = {
            string apiName = "bubbleDrag"
        }

        displayName = "BubbleDrag"
        doc = """Fluid drag force factor for bubble particles.
            Range: [0, inf)
            Units: dimensionless """
    )

    float physxDiffuseParticles:buoyancy = 0.8 (
        customData = {
            string apiName = "buoyancy"
        }

        displayName = "Buoyancy"
        doc = """Buoyancy force factor for bubble particles.
            Range: [0, inf)
            Units: dimensionless """
    )

    float physxDiffuseParticles:kineticEnergyWeight = 0.01 (
        customData = {
            string apiName = "kineticEnergyWeight"
        }

        displayName = "Kinetic Energy Weight"
        doc = """Contribution from kinetic energy when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    
    float physxDiffuseParticles:pressureWeight = 1.0 (
        customData = {
            string apiName = "pressureWeight"
        }

        displayName = "Pressure Weight"
        doc = """Contribution from pressure when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    
    float physxDiffuseParticles:divergenceWeight = 5.0 (
        customData = {
            string apiName = "divergenceWeight"
        }

        displayName = "Divergence Weight"
        doc = """Contribution from divergence when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )    
    
    float physxDiffuseParticles:collisionDecay = 0.5 (
        customData = {
            string apiName = "collisionDecay"
        }

        displayName = "Collision Decay"
        doc = """Decay factor of diffuse particles' lifetime after they collide with shapes. 0 == lifetime remains unchanged, 1 == particle disappears immediately.
            Range: [0, 1]
            Units: dimensionless"""
    )

    bool physxDiffuseParticles:useAccurateVelocity = False ( 
        customData = {
            string apiName = "useAccurateVelocity"
        }

        displayGroup = "Advanced"
        displayName = "Use Accurate Velocity"
        doc = """Enables accurate particle velocity estimation."""
    )
}

class "PhysxPBDMaterialAPI"
(
    customData = {
        string className = "PhysxPBDMaterialAPI"
    }

    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a USD Material. PhysX position-based-dynamics (PBD) material for particles used to simulate fluids, cloth and inflatables.
    Currently, only a single material per particle system is supported which applies to all objects that are associated with the system."""
    inherits = </APISchemaBase>
)
{
    float physxPBDMaterial:friction = 0.2 (
        customData = {
            string apiName = "friction"
        }

        displayName = "Friction"
        doc = """Friction coefficient. The maximal friction force tangential to the surface is equal to the normal force times
            the friction. The friction takes effect in all interactions between particles and rigids or deformables.
            For solid particle-particle interactions it is multiplied by the particle friction scale.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxPBDMaterial:particleFrictionScale = 1.0 (
        customData = {
            string apiName = "particleFrictionScale"
        }

        displayGroup = "Advanced"
        displayName = "Particle Friction Scale"
        doc = """Coefficient that scales friction for solid particle-particle interations.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxPBDMaterial:damping = 0.0 (
        customData = {
            string apiName = "damping"
        }

        displayName = "Damping"
        doc = """Global velocity damping coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )
    
    float physxPBDMaterial:viscosity = 0.0 (
        customData = {
            string apiName = "viscosity"
        }

        displayName = "Viscosity"
        doc = """Viscosity for fluid particles.
            Range: [0, inf) 
            Units: dimensionless"""
    )

    float physxPBDMaterial:vorticityConfinement = 0.0 (
        customData = {
            string apiName = "vorticityConfinement"
        }

        displayGroup = "Advanced"
        displayName = "Vorticity Confinement"
        doc = """Vorticity confinement for fluid particles. Helps prevent energy loss due to numerical solver by adding vortex-like accelerations to the particles.
            Range: [0, inf)
            Units: dimensionless """
    )

    float physxPBDMaterial:surfaceTension = 0.0 (
        customData = {
            string apiName = "surfaceTension"
        }

        displayName = "Surface Tension"
        doc = """Surface tension for fluid particles.
            Range: [0, inf) 
            Units: 1 / (distance * distance * distance)"""
    )

    float physxPBDMaterial:cohesion = 0.0 (
        customData = {
            string apiName = "cohesion"
        }

        displayName = "Cohesion"
        doc = """Cohesion for interaction between fluid particles.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxPBDMaterial:adhesion = 0.0 (
        customData = {
            string apiName = "adhesion"
        }

        displayGroup = "Advanced"
        displayName = "Adhesion"
        doc = """Adhesion for interactions between particles (solid or fluid), and rigids or deformables.
            Adhesion also applies to solid-solid particle interactions, but is multiplied with the particle adhesion scale.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxPBDMaterial:particleAdhesionScale = 1.0 (
        customData = {
            string apiName = "particleAdhesionScale"
        }

        displayGroup = "Advanced"
        displayName = "Particle Adhesion Scale"
        doc = """Coefficient that scales adhesion for solid particle-particle interations.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxPBDMaterial:adhesionOffsetScale = 0.0 (
        customData = {
            string apiName = "adhesionOffsetScale"
        }

        displayGroup = "Advanced"
        displayName = "Adhesion Offset Scale"
        doc = """Offset scale defining the offset at which adhesion ceases to take effect. For interactions between particles (fluid or solid),
            and rigids or deformables, the adhesion offset is defined relative to the rest offset. For solid particle-particle
            interactions, the adhesion offset is defined relative to the solid rest offset.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxPBDMaterial:gravityScale = 1.0 (
        customData = {
            string apiName = "gravityScale"
        }

        displayGroup = "Advanced"
        displayName = "Gravity Scale"
        doc = """Gravitational acceleration scaling factor. Can be used to approximate lighter-than-air inflatables, for example (-1.0 would invert gravity).
            Range: (-inf, inf)
            Units: dimensionless"""
    )

    float physxPBDMaterial:lift = 0.0 (
        customData = {
            string apiName = "lift"
        }

        displayName = "Lift"
        doc = """Lift coefficient for cloth and inflatable particle objects. Basic aerodynamic lift model coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )    
    
    float physxPBDMaterial:drag = 0.0 (
        customData = {
            string apiName = "drag"
        }

        displayName = "Drag"
        doc = """Drag coefficient for cloth and inflatable particle objects. Basic aerodynamic drag model coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )

    float physxPBDMaterial:density = 0.0 (
        customData = {
            string apiName = "density"
        }

        displayName = "Density"
        doc = """Density used to compute particle object mass. If set to 0.0, the simulation determines a default density.
            A density or mass set with a PhysicsMassAPI on a particle object overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )

    float physxPBDMaterial:cflCoefficient = 1.0 (
        customData = {
            string apiName = "cflCoefficient"
        }

        displayGroup = "Advanced"
        displayName = "CFL Coefficient"
        doc = """This coefficient scales the CFL term used to limit relative motion between fluid particles. A very large value disables the limit.
            Range: [1, inf)
            Units: dimensionless"""
    )
}

class "PhysxParticleAPI"
(
    customData = {
        string className = "PhysxParticleAPI"
    }

    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Do not apply. Provides parameters shared among particle objects."""
    inherits = </APISchemaBase>
)
{
    bool physxParticle:particleEnabled = True (
        customData = {
            string apiName = "particleEnabled"
        }

        displayName = "Particle Enabled"
        doc = """Enable or disable the particle object."""
    )

    rel physxParticle:particleSystem (
        customData = {
            string apiName = "particleSystem"
        }

        displayName = "Particle System"
        doc = """Single particle system that the particle-based object belongs to."""
    )

    bool physxParticle:selfCollision = True (
        customData = {
            string apiName = "selfCollision"
        }

        displayName = "Self Collision"
        doc = """Enables self-collision of the particles or of the particle object."""
    )

    int physxParticle:particleGroup = 0 (
        customData = {
            string apiName = "particleGroup"
        }

        displayGroup = "Advanced"
        displayName = "Particle Group"
        doc = """Group Id of the particles. Particles / objects in different groups in the same system collide with each other.
            Within the same group in the same system, the collision behavior is controlled by the selfCollision parameter.
            Range: [0, 2^20)"""
    )
}

class "PhysxParticleSetAPI"
(
    customData = {
        string className = "PhysxParticleSetAPI"
    }

    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomPointInstancer or a UsdGeomPointBased. Creates a set of particles for granular (i.e. solid-particle) material or fluid simulation with PhysX."""
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxParticleAPI"]
)
{
    bool physxParticle:fluid = True (
        customData = {
            string apiName = "fluid"
        }

        displayName = "Fluid"
        doc = """Flag to toggle simulation as fluid (True) or solid (False)."""
    )

    point3f[] physxParticle:simulationPoints (
        customData = {
            string apiName= "simulationPoints"
        }

        displayGroup = "Advanced"
        displayName = "Simulation Points"
        doc = """This attribute is read-only and is updated from simulation to capture particle-simulation state while smoothed position data
            is written to the render position/points attribute of the UsdGeomPointInstancer/UsdGeomPoints."""
    )
}

class "PhysxParticleSamplingAPI"
(
    customData = {
        string className = "PhysxParticleSamplingAPI"
    }

    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh which is Poisson-sampled to generate particles in the particles relationship."""
    inherits = </APISchemaBase>
)
{
    float physxParticleSampling:samplingDistance = 0 (
        customData = {
            string apiName = "samplingDistance"
        }

        displayName = "Particle Distance"
        doc = """The distance between the sampled positions. In general, choose a value larger than the corresponding particle rest offset.
            Default value zero means that a suitable value is auto-determined.
            Range: [0, inf)
            Units: distance"""
    )

    bool physxParticleSampling:volume = True (
        customData = {
            string apiName = "volume"
        }

        displayName = "Sample Inside Volume"
        doc = """Whether to sample points inside the mesh or not."""
    )

    int physxParticleSampling:maxSamples = 50000 (
        customData = {
            string apiName = "maxSamples"
        }

        displayName = "Maximum Number of Samples"
        doc = """Approximate upper bound on the number of samples. Zero means unbounded.
            Range: [0, inf)"""
    )

    rel physxParticleSampling:particles (
        customData = {
            string apiName = "particles"
        }

        displayName = "Particles"
        doc = """Relationship to the particle set sampled from the mesh."""
    )
}

class "PhysxParticleClothAPI"
(
    customData = {
        string className = "PhysxParticleClothAPI"
    }

    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh. The mesh is simulated as a particle-based cloth or inflatable, depending on the mesh geometry
    and the pressure attribute. See PhysxAutoParticleClothAPI for an auto-compute helper for cloth springs and dampings."""
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxParticleAPI"]
)
{
    bool physxParticle:selfCollisionFilter = True (
        customData = {
            string apiName = "selfCollisionFilter"
        }

        displayGroup = "Advanced"
        displayName = "Self Collision Filter"
        doc = """Whether the simulation should filter particle-particle collisions based on their rest position distances."""
    )

    point3f[] physxParticle:restPoints (
        customData = {
            string apiName= "restPoints"
        }

        displayGroup = "Advanced"
        displayName = "Rest Points"
        doc = """Particle positions in cloth rest configuration."""
    )

    uniform int2[] physxParticle:springIndices (
        customData = {
            string apiName= "springIndices"
        }

        displayGroup = "Advanced"
        displayName = "Spring Indices"
        doc = """List of index pairs describing which points are connected by spring constraints."""
    )

    float[] physxParticle:springStiffnesses (
        customData = {
            string apiName= "springStiffnesses"
        }

        displayGroup = "Advanced"
        displayName = "Spring Stiffnesses"
        doc = """Stiffness values for linear-distance springs between a pair of particles as defined by index pairs in springIndices.
            Range: [0, inf)
            Units: force / distance = mass / second / second"""
    )

    float[] physxParticle:springDampings (
        customData = {
            string apiName= "springDampings"
        }

        displayGroup = "Advanced"
        displayName = "Spring Dampings"
        doc = """Coefficients for linear-distance dampers between a pair of particles as defined by index pairs in springIndices.
            Range: [0, inf)
            Units: force * second / distance = mass / second"""
    )

    float[] physxParticle:springRestLengths (
        customData = {
            string apiName= "springRestLengths"
        }

        displayGroup = "Advanced"
        displayName = "Spring Rest Lengths"
        doc = """Spring rest lengths corresponding to spring index pairs.
            Range: (-inf, inf)
            Units: distance"""
    )

    float physxParticle:pressure = 0.0 (
        customData = {
            string apiName = "pressure"
        }

        displayName = "Pressure"
        doc = """Pressure: If > 0, a particle cloth has an additional pressure constraint 
            that provides inflatable (i.e. balloon-like) dynamics. The pressure times the rest volume defines 
            the volume the inflatable tries to match. Pressure only works well for closed or approximately closed meshes.
            Range: [0, inf)
            Units: dimensionless"""
    )
}

class "PhysxAutoParticleClothAPI"
(
    customData = {
        string className = "PhysxAutoParticleClothAPI"
    }

    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh with PhysxParticleClothAPI. Defines parameters to automatically compute spring constraints."""
    inherits = </APISchemaBase>
)
{
    float physxAutoParticleCloth:springStretchStiffness = 1.5 (
        customData = {
            string apiName = "springStretchStiffness"
        }

        displayName = "Stretch Stiffness"
        doc = """Stretch stiffness. Represents a stiffness for linear springs placed between particles to counteract stretching.
            Range: [0, inf)
            Units: force / distance = mass / second / second"""
    )

    float physxAutoParticleCloth:springBendStiffness = 1.5 (
        customData = {
            string apiName = "springBendStiffness"
        }

        displayName = "Bend Stiffness"
        doc = """Bend stiffness. Represents a stiffness for linear springs placed in a way to counteract bending.
            Range: [0, inf)
            Units:  force / distance = mass / second / second"""
    )

    float physxAutoParticleCloth:springShearStiffness = 1.5 (
        customData = {
            string apiName = "springShearStiffness"
        }

        displayName = "Shear Stiffness"
        doc = """Shear stiffness. Represents a stiffness for linear springs placed in a way to counteract shear.
            Range: [0, inf)
            Units:  force / distance = mass / second / second"""
    )

    float physxAutoParticleCloth:springDamping = 10.0 (
        customData = {
            string apiName = "springDamping"
        }

        displayName = "Spring Damping"
        doc = """Damping on cloth spring constraints. Applies to all constraints parametrized by stiffness attributes.
            Range: [0, inf)
            Units: force * second / distance = mass / second"""
    )

    bool physxAutoParticleCloth:disableMeshWelding = false (
        customData = {
            string apiName = "disableMeshWelding"
        }

        displayName = "Disable Mesh Welding"
        doc = """Disable welding of the UsdGeomMesh vertices for cloth simulation."""
    )
}

class "PhysxDeformableBodyMaterialAPI"
(
    customData = {
        string className = "PhysxDeformableBodyMaterialAPI"
    }

    doc = """Applied to USD Material. Defines material properties for deformable bodies."""
    inherits = </APISchemaBase>
)
{
    float physxDeformableBodyMaterial:density = 0.0 (
        customData = {
            string apiName= "density"
        }
        
        displayName = "Density"
        doc = """Material density. If set to 0.0, the simulation determines a default density. A density or mass set with a PhysicsMassAPI overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )
    
    float physxDeformableBodyMaterial:elasticityDamping = 0.005 (
        customData = {
            string apiName = "elasticityDamping"
        }
        
        displayName = "Elasticity Damping"
        doc = """Material damping parameter. Use values much smaller than one for good results.
            Range: [0, inf)
            Units: dimensionless"""
    )
    
    float physxDeformableBodyMaterial:dynamicFriction = 0.25 (
        customData = {
            string apiName = "dynamicFriction"
        }
        
        displayName = "Dynamic Friction"
        doc = """Dynamic friction coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxDeformableBodyMaterial:youngsModulus = 50000000.0 (
        customData = {
            string apiName = "youngsModulus"
        }
        
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material.
            Range: [0, inf)
            Units: force / area = mass/distance/seconds/seconds"""
    )
    
    float physxDeformableBodyMaterial:poissonsRatio = 0.45 (
        customData = {
            string apiName = "poissonsRatio"
        }
        
        displayName = "Poisson's Ratio"
        doc = """Poissons's ratio which defines the material's volume preservation under stress.
            Range: [0, 0.5]
            Units: dimensionless"""
    )
    
    float physxDeformableBodyMaterial:dampingScale = 1.0 (
        customData = {
            string apiName= "dampingScale"
        }
        
        displayName = "Damping Scale"
        doc = """Experimental parameter. Try a high damping together with a scale of zero for a water-bed like effect.
            Range: [0, 1]
            Units: dimensionless"""
    )
}

class "PhysxDeformableSurfaceMaterialAPI"
(
    customData = {
        string className = "PhysxDeformableSurfaceMaterialAPI"
    }
    
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to USD Material. Defines material properties for deformable surfaces."""
    inherits = </APISchemaBase>
)
{
    float physxDeformableSurfaceMaterial:density = 0.0 (
        customData = {
            string apiName= "density"
        }
        
        displayName = "Density"
        doc = """Material density. If set to 0.0, the simulation determines a default value. 
            The mass of deformable surface is computed by density * area * thickness.
            A density or mass set with a PhysicsMassAPI overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )
    
    float physxDeformableSurfaceMaterial:dynamicFriction = 0.25 (
        customData = {
            string apiName = "dynamicFriction"
        }
        
        displayName = "Dynamic Friction"
        doc = """Dynamic friction coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxDeformableSurfaceMaterial:youngsModulus = -inf (
        customData = {
           string apiName = "youngsModulus"
        }
        
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material. 
            Used to determine in-plane and bending stiffness.
            If set to a negative value, the simulation determines a default value.
            Range: [0, inf)
            Units: force / area = mass/distance/seconds/seconds"""
    )
    
    float physxDeformableSurfaceMaterial:poissonsRatio = 0.0 (
        customData = {
            string apiName = "poissonsRatio"
        }
        
        displayName = "Poisson's Ratio"
        doc = """Poissons's ratio which defines the material's volume preservation under stress. 
            Used to determine in-plane and bending stiffness.
            Range: [0, 0.5]
            Units: dimensionless"""
    )
    
    float physxDeformableSurfaceMaterial:thickness = 0.0 (
        customData = {
            string apiName= "thickness"
        }
        
        displayName = "Thickness"
        doc = """Virtual thickness of cloth mesh. Used to determine in-plane and bending stiffness, and mass from density.
            If set to 0.0, the simulation determines a default value.
            Range: [0.0, inf)
            Units: distance"""
    )
}

class "PhysxDeformableAPI"
(
    customData = {
        string className = "PhysxDeformableAPI"
    }
    
    doc = """Do not apply. Base API that provides attributes common to both deformable bodies and surfaces.
          Derived APIs are applied to UsdGeomMesh in order to create a deformable physics object.
          Note that the UsdGeomMesh points attribute becomes a read-only attribute for a deformable as the mesh is driven by the simulation.
          """
    inherits = </APISchemaBase>
)
{
    bool physxDeformable:deformableEnabled = True (
        customData = {
            string apiName = "deformableEnabled"
        }

        displayName = "Deformable Enabled"
        doc = """Enable or disable the deformable object."""
    )
    
    rel physxDeformable:simulationOwner (
        customData = {
            string apiName = "simulationOwner"
        }

        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that simulates this deformable. By default,
        this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )

    uint physxDeformable:solverPositionIterationCount = 16 (
        customData = {
            string apiName= "solverPositionIterationCount"
        }
        
        displayName = "Solver Position Iterations"
        doc = """ Number of solver position iterations per time step.
              Range: [1, 255]"""
    )

    float physxDeformable:vertexVelocityDamping = 0.005 (
        customData = {
            string apiName= "vertexVelocityDamping"
        }
        
        displayName = "Vertex Velocity Damping"
        doc = """Artificial damping on the vertex velocity, which may approximate aerodynamic drag.
              Range: [0, inf)
              Units: 1/seconds"""
    )
    
    float physxDeformable:sleepDamping = 10.0 (
        customData = {
            string apiName= "sleepDamping"
        }
        
        displayName = "Sleep Damping"
        doc = """Additional damping term if vertex velocity drops below settlingThreshold.
              Range: [0, inf)
              Units: 1/seconds"""
    )
    
    float physxDeformable:sleepThreshold = 0.05 (
        customData = {
            string apiName= "sleepThreshold"
        }
        
        displayName = "Sleep Threshold"
        doc = """Velocity threshold under which the vertex becomes a candidate for sleeping.
              Range: [0, inf)
              Units: distance/seconds"""
    )
    
    float physxDeformable:settlingThreshold = 0.10 (
        customData = {
            string apiName= "settlingThreshold"
        }
        
        displayName = "Settling Threshold"
        doc = """Threshold vertex velocity under which sleep damping is applied in addition to velocity damping.
              Range: [0, inf]
              Units: distance/seconds"""
    )

    float physxDeformable:maxDepenetrationVelocity = inf (
        customData = {
            string apiName = "maxDepenetrationVelocity"
        }

        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum velocity permitted to be introduced by the solver to depenetrate intersections.
            Range: [0, inf)
            Units: distance / seconds"""
    )

    bool physxDeformable:selfCollision = False (
        customData = {
            string apiName= "selfCollision"
        }
        
        displayName = "Enable Self Collision"
        doc = """Enables self collisions on the deformable, preventing self intersections."""
    )
    
    float physxDeformable:selfCollisionFilterDistance = -inf (
        customData = {
            string apiName= "selfCollisionFilterDistance"
        }
        
        displayName = "Self Collision Filter Distance"
        doc = """Distance under which self-collisions are disabled. Default value -inf means default is picked by the simulation.
              Range: [2*physxCollision:contactOffset, max_float]
              Units: distance"""
    )
    
    bool physxDeformable:enableCCD = False (
        customData = {
            string apiName = "enableCCD"
        }

        displayName = "Enable CCD"
        doc = """Distance based CCD."""
    )
    
    point3f[] physxDeformable:restPoints (
        customData = {
            string apiName= "restPoints"
        }
        
        displayGroup = "Advanced"
        displayName = "Rest Points"
        doc = """Rest points of the UsdGeomMesh in local coordinates.
              Units: distance"""
    )
    
    point3f[] physxDeformable:simulationVelocities (
        customData = {
            string apiName= "simulationVelocities"
        }
        
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Vertex Velocities"
        doc = """Simulation mesh vertex velocities in local coordinates.
            Units: distance / seconds"""
    )
    
    uniform int[] physxDeformable:simulationIndices (
        customData = {
            string apiName= "simulationIndices"
        }
        
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Indices"
        doc = """Simulation mesh indices."""
    )
}

class "PhysxDeformableBodyAPI"
(
    customData = {
        string className = "PhysxDeformableBodyAPI"
    }
	
	doc = """Applied to a UsdGeomMesh that is to be driven by a deformable body simulation.
	      See PhysxDeformableAPI for information on how to define the deformable body's material properties."""
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxDeformableAPI"]
)
{
    bool physxDeformable:disableGravity = False (
        customData = {
            string apiName = "disableGravity"
        }

        displayName = "Disable Gravity"
        doc = """Disable gravity for the actor."""
    )    

    uniform int[] physxDeformable:collisionIndices (
        customData = {
            string apiName= "collisionIndices"
        }
        
        displayGroup = "Advanced"
        displayName = "Collision Mesh Indices"
        doc = """Mesh indices that define the collision tetrahedral mesh together with the collisionPoints attribute."""
    )
    
    point3f[] physxDeformable:collisionPoints (
        customData = {
            string apiName= "collisionPoints"
        }
        
        displayGroup = "Advanced"
        displayName = "Collision Mesh Points"
        doc = """Mesh points in local coordinates that define the collision tetrahedral mesh together with the collisionIndices attribute.
            This attribute is read-only and may be updated from simulation data to reflect the current simulation state."""
    )
    
    point3f[] physxDeformable:collisionRestPoints (
        customData = {
            string apiName= "collisionRestPoints"
        }
        
        displayGroup = "Advanced"
        displayName = "Collision Mesh Rest Points"
        doc = """Mesh rest points in local coordinates that define the rest pose of the collision tetrahedral mesh together with the collisionIndices attribute."""
    )
    
    point3f[] physxDeformable:simulationPoints (
        customData = {
            string apiName= "simulationPoints"
        }

        displayGroup = "Advanced"
        displayName = "Simulation Mesh Points"
        doc = """Simulation mesh points in local coordinates that define the simulation tetrahedral mesh together with the simulationIndices attribute.
            This attribute may be updated from simulation data to reflect the current simulation state."""
    )
    
    point3f[] physxDeformable:simulationRestPoints (
        customData = {
            string apiName= "simulationRestPoints"
        }
        
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Rest Points"
        doc = """Mesh rest points in local coordinates that define the rest pose of the simulation tetrahedral mesh together with the simulationIndices attribute."""
    )
}

class "PhysxDeformableSurfaceAPI"
(
    customData = {
        string className = "PhysxDeformableSurfaceAPI"
    }
    
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh that is to be simulated as a deformable surface.
	See PhysxDeformableAPI for information on how to define the deformable surface's material properties."""
	inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxDeformableAPI"]
)
{
    bool physxDeformableSurface:flatteningEnabled = False (
        customData = {
            string apiName = "flatteningEnabled"
        }

        displayName = "Flattening Enabled"
        doc = """If enabled, bending forces are applied such that the surface flattens, i.e., neighboring triangles become coplanar.
        If disabled, the forces drive toward the bend at the rest state."""
    )

    float physxDeformableSurface:bendingStiffnessScale = 0.0 (
        customData = {
            string apiName= "bendingStiffnessScale"
        }

        displayName = "Bending Stiffness Scale"
        doc = """Scales bending stiffness computed from Young's modulus, Poisson's ratio, and the cloth thickness.
            Range: [0, inf)
            Units: dimensionless"""
    )

    uint physxDeformableSurface:collisionPairUpdateFrequency = 1 (
        customData = {
            string apiName = "collisionPairUpdateFrequency"
        }

        displayGroup = "Advanced"
        displayName = "Collision Pair Update Frequency"
        doc = """Determines how often collision pairs are updated in each time step.
            By default, the pairs of contact points are computed only at the beginning of each time step, and the pairs are kept during the time step.
            Increasing this value will update the contact pairs more frequently providing better contact points,
            e.g., 2 means collision pairs are updated twice in each time step: 
            at the beginning of the time step, and in the middle of the time step (i.e., at the middle solver iteration).
            Range [1, solverPositionIterationCount/2]"""            
    )

    uint physxDeformableSurface:collisionIterationMultiplier = 1 (
        customData = {
            string apiName = "collisionIterationMultiplier"
        }

        displayGroup = "Advanced"
        displayName = "Collision Iteration Multiplier"
        doc = """Determines how many collision subiterations are used in each solver iteration.
            By defualt, collision constraints are applied once in each solver iteration, 
            and increasing this value will apply collision constraints more frequently in each solver iteration,
            e.g., 2 means collision constraints are applied twice in each solver iteration (thus, the collision constraints are applied 2 x solverPositionIterationCount times in each time step).            
            Increasing this value does not update collision pairs more frequently, see collisionPairUpdateFrequency.
            Range [1, solverPositionIterationCount/2]"""            
    )

    float physxDeformableSurface:maxVelocity = inf (
        customData = {
            string apiName = "maxVelocity"
        }

        displayGroup = "Advanced"
        displayName = "Max Velocity"
        doc = """Maximum velocity. The velocity of each vertex is clamped by the max velocity.
            Range: [0, inf)
            Units: distance / seconds"""
    )
}

class PhysxPhysicsAttachment "PhysxPhysicsAttachment"
(
    customData = {
        string className = "PhysxPhysicsAttachment"
    }

    doc = """Represents attachments between physics actors, for example, between a rigid body and a deformable body, or a deformable body and a particle cloth."""
    inherits = </Typed>
)
{
    bool attachmentEnabled = True (
        customData = {
            string apiName = "attachmentEnabled"
        }

        displayName = "Attachment Enabled"
        doc = """Enable or disable the attachment."""
    )

    rel actor0 (
        customData = {
            string apiName = "actor0"
        }

        displayName = "Actor 0"
        doc = """Reference to the first actor."""
    )

    rel actor1 (
        customData = {
            string apiName = "actor1"
        }

        displayName = "Actor 1"
        doc = """Reference to the second actor."""
    )

    point3f[] points0 (
        customData = {
            string apiName = "points0"
        }
        displayGroup = "Advanced"
        displayName = "Points Actor 0"
        doc = """Attachment points in Actor 0 local space, defined in the actor's rest state, if it is deformable. Elements correspond one-to-one to elements in points1 attribute."""
    )

    point3f[] points1 (
        customData = {
            string apiName = "points1"
        }
        displayGroup = "Advanced"
        displayName = "Points Actor 1"
        doc = """Attachment points in Actor 1 local space, defined in the actor's rest state, if it is deformable. Elements correspond one-to-one to elements in points0 attribute."""
    )

    uint[] collisionFilterIndices0 (
        customData = {
            string apiName = "collisionFilterIndices0"
        }
        displayGroup = "Advanced"
        displayName = "Collision Filter Indices Actor 0"
        doc = """Indices to geometry of Actor 0 that should not generate collisions with Actor 1 as specified by filterType0. Ignored for rigid bodies."""
    )

    uniform token filterType0 (
        customData = {
            string apiName = "filterType0"
        }
        displayGroup = "Advanced"
        displayName = "Filter Type 0"
        allowedTokens = ["Vertices", "Geometry"]
        doc = """Specify if indices in collisionFilterIndices0 correspond to vertices; or mesh cell-geometry, i.e. triangles, tetrahedrons, etc."""
    )

    uint[] collisionFilterIndices1 (
        customData = {
            string apiName = "collisionFilterIndices1"
        }
        displayGroup = "Advanced"
        displayName = "Collision Filter Indices Actor 1"
        doc = """Indices to mesh triangle/tet/hex/etc. of Actor 1 that should not generate collisions with Actor 0. Ignored for rigid bodies."""
    )

    uniform token filterType1 (
        customData = {
            string apiName = "filterType1"
        }
        displayGroup = "Advanced"
        displayName = "Filter Type 1"
        allowedTokens = ["Vertices", "Geometry"]
        doc = """Specify if indices in collisionFilterIndices1 correspond to vertices; or mesh cell-geometry, i.e. triangles, tetrahedrons, etc."""
    )
}

class "PhysxAutoAttachmentAPI"
(
    customData = {
        string className = "PhysxAutoAttachmentAPI"
    }

    doc = """Auto generates the attachment points and filtering ids based on the attributes defined in the API."""
    inherits = </APISchemaBase>
)
{
    bool physxAutoAttachment:enableDeformableVertexAttachments = true (
        customData = {
            string apiName = "enableDeformableVertexAttachments"
        }

        displayName = "Enable Deformable Vertex Attachments"
        doc = """Enables attaching deformable mesh vertices which overlap with the other actor's volume."""
    )

    float physxAutoAttachment:deformableVertexOverlapOffset = 0.0 (
        customData = {
            string apiName= "deformableVertexOverlapOffset"
        }
        
        displayName = "Deformable Vertex Overlap Offset"
        doc = """Deformable mesh vertices are attached if their distance to the other actor's volume is smaller than the offset.
            Range: [0, inf)
            Units: distance"""
    )

    bool physxAutoAttachment:enableRigidSurfaceAttachments = false (
        customData = {
            string apiName = "enableRigidSurfaceAttachments"
        }

        displayName = "Enable Rigid Surface Attachments"
        doc = """Enables sampling attachment points on the rigid actor's surface."""
    )

    float physxAutoAttachment:rigidSurfaceSamplingDistance = -inf (
        customData = {
            string apiName= "rigidSurfaceSamplingDistance"
        }
        
        displayName = "Rigid Surface Sampling Distance"
        doc = """Attachment points on the rigid surface are positioned such that their typical neighbor distance matches the sampling distance. Use heuristic by default.
            Range: [0, inf)
            Units: distance"""
    )

    bool physxAutoAttachment:enableCollisionFiltering = true (
        customData = {
            string apiName = "enableCollisionFiltering"
        }

        displayName = "Enable Collision Filtering"
        doc = """Enables adding collision filtering in the vicinity of the attachment points."""
    )

    float physxAutoAttachment:collisionFilteringOffset = -inf (
        customData = {
            string apiName= "collisionFilteringOffset"
        }
        
        displayName = "Collision Filtering Offset"
        doc = """Filtering ids are generated for deformable mesh vertices if their distance to the other actor's volume is smaller than the offset. Use heuristic by default.
            Range: [0, inf)
            Units: distance"""
    )

    bool physxAutoAttachment:enableDeformableFilteringPairs = false (
        customData = {
            string apiName = "enableDeformableFilteringPairs"
        }

        displayGroup = "Advanced"
        displayName = "Enable Deformable Collision Filtering Pairs"
        doc = """Enables geometry pair based collision filtering for deformable-deformable attachments. 
            By default a filtered geometry of one actor is filtered against all geometries of the other actor."""
    )
}

class "PhysxHairAPI"
(
    customData = {
        string className = "PhysxHairAPI"
    }

    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    This is the PhysX Hair API. This API should be applied to a UsdGeomPointBased, for
    example UsdGeomMesh or UsdGeomBasisCurves to simulate the geometry as a PhysX Hairsystem."""
    inherits = </APISchemaBase>
    prepend apiSchemas = ["PhysxDeformableAPI"]
)
{
    # TODO(jcarius) remove once collision groups are implemented
    bool physxHair:externalCollision = True (
        customData = {
            string apiName = "externalCollision"
        }

        displayName = "External Collision"
        doc = """Enables the hair segments to collide with other physics objects that have a collision API applied to them."""
    )

    bool physxHair:twosidedAttachment = False (
        customData = {
            string apiName = "twosidedAttachment"
        }

        displayGroup = "Advanced"
        displayName = "Two-Sided Attachment"
        doc = """Whether the hair should have an effect on the body it is attached to."""
    )

    float physxHair:segmentLength = 0.0 (
        customData = {
            string apiName = "segmentLength"
        }

        displayName = "Segment Length"
        doc = """Length of one hair segment (i.e., distance between simulation vertices along a strand).
        This value is used to automatically place simulation vertices (=control points) along a strand.
            The default value of 0 means the length is autocomputed such that the longest strand has 32 vertices.
            Range: [0, inf),
            Units: distance"""
    )

    float physxHair:globalShapeComplianceAtRoot = -inf (
        customData = {
            string apiName = "globalShapeComplianceAtRoot"
        }

        displayName = "Global Shape Compliance at Root"
        doc = """Compliance to the global shape-matching constraint at the root of the strand.
        The higher the compliance the softer the constraint.
            A negative value disables the shape-matching constraint.
            Range: [0, inf)
            Units: dimensionless"""
    )

    float physxHair:globalShapeComplianceStrandAttenuation = 1.0 (
        customData = {
            string apiName = "globalShapeComplianceStrandAttenuation"
        }

        displayName = "Attenuation for Global Shape Compliance"
        doc = """The factor by which the compliance to the global shape-matching constraint changes from
        a simulation vertex to the next one along the strand. Use it to increase or decrease
        the compliance along a strand, starting with globalShapeComplianceAtRoot.
            A value > 1.0 means the constraint becomes softer towards the strand tips.
            Range: (0, inf)
            Units: dimensionless"""
    )

    float physxHair:interHairRepulsion = 0.0 (
        customData = {
            string apiName = "interHairRepulsion"
        }

        displayName = "Repulsion Between Hair Segments"
        doc = """Strength of the repulsion effect between hair segments.
        This effect is based on the volumetric density of hair vertices in space.
        Can be used as a substitute or complement to self-collisions.
            Range: [0.0, inf)
            Units: dimensionless"""
    )

    float physxHair:velSmoothing = 0.3 (
        customData = {
            string apiName = "velSmoothing"
        }

        displayName = "Velocity Smoothing"
        doc = """Strength of the velocity smoothing effect.
        The higher the value the more the hair moves like a single rigid body.
            A value of zero disables the constraint.
            Range: [0.0, 1.0]
            Units: dimensionless"""
    )

    float physxHair:localShapeMatchingCompliance = -inf (
        customData = {
            string apiName = "localShapeMatchingCompliance"
        }

        displayName = "Local Shape-matching Compliance"
        doc = """Compliance to the local shape matching constraint, which preserves strand shapes.
        The larger the compliance the softer the constraint.
            A negative value disables the constraint.
            Range [0, inf)
            Units: dimensionless"""
    )

    float physxHair:localShapeMatchingLinearStretching = 0.1 (
        customData = {
            string apiName = "localShapeMatchingLinearStretching"
        }

        displayGroup = "Advanced"
        displayName = "Local Shape-matching Linear Stretching"
        doc = """Proportion of linear stretching vs rigid transformation allowed in the local shape matching constraint.
        Only takes effect if local shape matching is enabled.
            A value of 0 allows only rigid transforms, a value of 1 permits linear deformations freely.
            Range [0.0, 1.0]
            Units: dimensionless"""
    )

    uint physxHair:localShapeMatchingGroupSize = 32 (
        customData = {
            string apiName = "localShapeMatchingGroupSize"
        }

        displayGroup = "Advanced"
        displayName = "Local Shape-matching Group Size"
        doc = """How many vertices of a strand are grouped together into one shape-matching constraint.
        The larger this number to more rigid a strand appears. The value is automatically
        capped at the strand length. Setting only takes effect if shape matching is enabled.
            Range [2, inf)."""
    )

    int physxHair:localShapeMatchingGroupOverlap = -1 (
        customData = {
            string apiName = "localShapeMatchingGroupOverlap"
        }

        displayGroup = "Advanced"
        displayName = "Local Shape-matching Group Overlap"
        doc = """Number of vertices by which consecutive shape-matching groups are overlapping.
        Only takes effect if shape matching is enabled.
            Default value of -1 means maximum overlap, i.e., shapeMatchingGroupSize/2
            Range [0, shapeMatchingGroupSize/2]."""
    )
}


# Material properties for hair. Later to be replaced by PhysicsCurveDeformableMaterialAPI
class "PhysxHairMaterialAPI"
(
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to USD Material. Defines material properties for hair simulation."""
    inherits = </APISchemaBase>
)
{
## properties of PhysicsMaterialAPI
    float physxHairMaterial:dynamicFriction = 0.0 (
        customData = {
            string apiName = "dynamicFriction"
        }
        displayName = "Dynamic Friction"
        doc = """Dynamic friction coefficient. Unitless."""
    )

    float physxHairMaterial:density = 0.0 (
        customData = {
            string apiName = "density"
        }
        displayName = "Density"
        doc = """If non-zero, defines the density of the material. This can be
        used for body mass computation, see PhysicsMassAPI.
        Note that if the density is 0.0 it is ignored. 
            Units: mass/distance/distance/distance."""
    )

## properties of PhysicsDeformableMaterial API
    float physxHairMaterial:youngsModulus = -inf (
        customData = {
            string apiName = "youngsModulus"
        }

        displayGroup = "Advanced"
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material.
            A negative value means the simulation will pick a default.
            Range: [0, inf)
            Units: mass/(distance*seconds*seconds)."""
    )

## properties of PhysicsCurveDeformableMaterialAPI
    float physxHairMaterial:curveThickness = -inf (
        customData = {
            string apiName = "curveThickness"
        }
        displayName = "Curve Thickness"
        doc = """Diameter along curve.
            A negative value means the simulation will pick a default.
            Range: [0, inf)
            Units: distance."""
    )

    float physxHairMaterial:curveBendStiffness = -inf (
        customData = {
            string apiName = "curveBendStiffness"
        }
        displayName = "Curve Bend Stiffness"
        doc = """Optional override for bending stiffness; by default derived from youngsModulus and curveThickness.
            Override is active if the value is non-negative.
            Range: [0, inf)
            Units: mass/(distance*seconds*seconds)."""
    )

## PhysX Hair specific properties
    float physxHairMaterial:contactOffsetMultiplier = 1.0 (
        customData = {
            string apiName = "contactOffsetMultiplier"
        }
        displayName = "Contact Offset Multiplier"
        doc = """Distance at which collisions are generated as a multiple of curveThickness.
            This attribute has no effect if contactOffset is non-negative.
            Range: [0.0, inf)
            Units: dimensionless
        """
    )

    float physxHairMaterial:contactOffset = -inf (
        customData = {
            string apiName = "contactOffset"
        }
        displayGroup = "Advanced"
        displayName = "Contact Offset"
        doc = """Distance at which collisions are generated.
            Overrides the contactOffsetMultiplier attribute if set to a non-negative value.
            Range: [0.0, inf)
            Units: distance"""
    )
}
