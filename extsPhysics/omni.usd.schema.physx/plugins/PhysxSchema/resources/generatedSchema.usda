#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class TetrahedralMesh "TetrahedralMesh" (
    doc = "Describes a tetrahedral mesh in 3D space."
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    int[] indices (
        displayGroup = "Advanced"
        displayName = "Indices"
        doc = "Flat list of the index (into the 'points' attribute) of each vertex of each tetrahedron in the mesh."
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "PhysxSceneAPI" (
    doc = """PhysX scene extended parameters.
    Default PhysX material for the scene can be set by using material bind with purpose physics onto the PhysicsScene prim."""
)
{
    float physxScene:bounceThreshold = 0.2 (
        displayGroup = "Advanced"
        displayName = "Bounce Threshold"
        doc = """A contact with a relative velocity below this will not bounce.
            Range: [0, inf)
            Default: 0.2 * tolerancesSpeed
            Units: distance / seconds"""
    )
    uniform token physxScene:broadphaseType = "GPU" (
        allowedTokens = ["GPU", "MBP", "SAP"]
        displayName = "Broadphase Type"
        doc = "Broad phase algorithm used in the simulation."
    )
    uniform token physxScene:collisionSystem = "PCM" (
        allowedTokens = ["PCM", "SAT"]
        displayName = "Collision System"
        doc = "Collision detection system."
    )
    bool physxScene:enableCCD = 0 (
        displayName = "Enable CCD"
        doc = "Enables a second broad phase check after integration that makes it possible to prevent objects from tunneling through each other."
    )
    bool physxScene:enableEnhancedDeterminism = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Enhanced Determinism"
        doc = "Provides improved determinism at the expense of performance."
    )
    bool physxScene:enableGPUDynamics = 1 (
        displayName = "Enable GPU Dynamics"
        doc = "Enables the GPU dynamics pipeline. Required for GPU only features like deformables."
    )
    bool physxScene:enableSceneQuerySupport = 1 (
        displayGroup = "Advanced"
        displayName = "Enable Scene Query Support"
        doc = "Enables scene query support for collision shapes."
    )
    bool physxScene:enableStabilization = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Stabilization"
        doc = "Enables additional stabilization pass in solver."
    )
    float physxScene:frictionCorrelationDistance = 0.025 (
        displayGroup = "Advanced"
        displayName = "Friction Correlation Distance"
        doc = """Friction correlation distance used to decide whether contacts are close enough to be merged into a single friction anchor point or not.
            Range: [0, inf)
            Default: 0.025 * tolerancesLength
            Units: distance"""
    )
    float physxScene:frictionOffsetThreshold = 0.04 (
        displayGroup = "Advanced"
        displayName = "Friction Offset Threshold"
        doc = """A threshold of contact separation distance used to decide if a contact point will experience friction forces.
            Range: [0, inf)
            Default: 0.04 * tolerancesLength
            Units: distance"""
    )
    uniform token physxScene:frictionType = "patch" (
        allowedTokens = ["patch", "oneDirectional", "twoDirectional"]
        displayGroup = "Advanced"
        displayName = "Friction Type"
        doc = '''Friction type used in simulation.
                 
                 Note: "oneDirectional" is deprecated.'''
    )
    uint physxScene:gpuCollisionStackSize = 67108864 (
        displayGroup = "Gpu"
        displayName = "Gpu Collision Stack Size"
        doc = "Gpu collision stack size."
    )
    uint physxScene:gpuFoundLostAggregatePairsCapacity = 1024 (
        displayGroup = "Gpu"
        displayName = "Gpu Found Lost Aggregate Pairs Capacity"
        doc = "Gpu found lost aggregate pairs capacity."
    )
    uint physxScene:gpuFoundLostPairsCapacity = 262144 (
        displayGroup = "Gpu"
        displayName = "Gpu Found Lost Pairs Capacity"
        doc = "Gpu found lost pairs capacity."
    )
    uint physxScene:gpuHeapCapacity = 67108864 (
        displayGroup = "Gpu"
        displayName = "Gpu Heap Capacity"
        doc = "Gpu heap capacity."
    )
    uint physxScene:gpuMaxDeformableSurfaceContacts = 1048576 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Deformable Surface Contacts"
        doc = "Gpu max deformable surface contacts."
    )
    uint physxScene:gpuMaxHairContacts = 1048576 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Hair Contacts"
        doc = "Gpu max hair contacts."
    )
    uint physxScene:gpuMaxNumPartitions = 8 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Num Partitions"
        doc = "Limitation for the partitions in the GPU dynamics pipeline. This variable must be a power of 2. A value greater than 32 is currently not supported."
    )
    uint physxScene:gpuMaxParticleContacts = 1048576 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Particle Contacts"
        doc = "Gpu max particle contacts."
    )
    uint physxScene:gpuMaxRigidContactCount = 524288 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Rigid Contact Count"
        doc = "Gpu max rigid contact count."
    )
    uint physxScene:gpuMaxRigidPatchCount = 81920 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Rigid Patch Count"
        doc = "Gpu max rigid patch count."
    )
    uint physxScene:gpuMaxSoftBodyContacts = 1048576 (
        displayGroup = "Gpu"
        displayName = "Gpu Max Softbody Contacts"
        doc = "Gpu max soft body contacts."
    )
    uint physxScene:gpuTempBufferCapacity = 16777216 (
        displayGroup = "Gpu"
        displayName = "Gpu Temp Buffer Capacity"
        doc = "Gpu temp buffer capacity."
    )
    uint physxScene:gpuTotalAggregatePairsCapacity = 1024 (
        displayGroup = "Gpu"
        displayName = "Gpu Total Aggregate Pairs Capacity"
        doc = "Gpu total aggregate pairs capacity."
    )
    bool physxScene:invertCollisionGroupFilter = 0 (
        displayName = "Inverted Collision Group Filter"
        doc = '''Boolean attribute indicating whether inverted collision group filtering should be used.
        By default two collisions, that do have a collisionGroup set, collide with each other. Adding
        a collisionGroup into a collisionGroup filtering will mean that the collision between those groups
        will be disabled. This boolean attribute does invert the default behavior. Hence two collisions with
        defined collisionGroups will not collide with each other by default and one does enable the
        collisions between the groups through the "CollisionGroup" filtering.'''
    )
    float physxScene:maxBiasCoefficient = inf (
        displayGroup = "Advanced"
        displayName = "Maximum Bias Coefficient"
        doc = """The maximum bias coefficient used in the constraint solver.
            Range: [0, inf)
            Units: dimensionless"""
    )
    uniform uint physxScene:maxPositionIterationCount = 255 (
        displayName = "Maximum Position Iteration Count"
        doc = """Maximum position iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations.
            Range: [1, 255]"""
    )
    uniform uint physxScene:maxVelocityIterationCount = 255 (
        displayName = "Maximum Velocity Iteration Count"
        doc = """Maximum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations.
            Range: [0, 255]"""
    )
    uniform uint physxScene:minPositionIterationCount = 1 (
        displayName = "Minimum Position Iteration Count"
        doc = """Minimum position iteration count for all actors (rigid bodies, cloth, particles etc).
            Range: [1, 255]"""
    )
    uniform uint physxScene:minVelocityIterationCount = 0 (
        displayName = "Minimum Velocity Iteration Count"
        doc = """Minimum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
            Range: [0, 255]"""
    )
    bool physxScene:reportKinematicKinematicPairs = 0 (
        displayName = "Report Kinematic vs Kinematic Pairs"
        doc = """Boolean attribute indicating whether kinematic vs kinematic pairs
        generate contact reports."""
    )
    bool physxScene:reportKinematicStaticPairs = 0 (
        displayName = "Report Kinematic vs Static Pairs"
        doc = """Boolean attribute indicating whether kinematic vs static pairs
        generate contact reports."""
    )
    uniform token physxScene:solverType = "TGS" (
        allowedTokens = ["PGS", "TGS"]
        displayName = "Solver Type"
        doc = "Solver used for the simulation."
    )
    uint physxScene:timeStepsPerSecond = 60 (
        displayName = "Time Steps Per Second"
        doc = """Simulation scene step defined as number of steps per second.
        Note that application might cap the number of simulation steps to avoid
        running more simulations steps with a low frame rate."""
    )
    uniform token physxScene:updateType = "Synchronous" (
        allowedTokens = ["Synchronous", "Asynchronous", "Disabled"]
        displayGroup = "Advanced"
        displayName = "Update Type"
        doc = "Type of update for a PhysX scene."
    )
}

class "PhysxRigidBodyAPI" (
    doc = "PhysX rigid body extended parameters"
)
{
    float physxRigidBody:angularDamping = 0.05 (
        displayName = "Angular Damping"
        doc = """Angular damping coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxRigidBody:cfmScale = 0.025 (
        displayGroup = "Advanced"
        displayName = "Constraint-force-mixing Scale"
        doc = """The cfm scale term can help stabilize an articulation by weakening the constraint's response.
            Use small values close to the default and typically in the range [0, 0.1] for best results.
            Note that this parameter is currently used only if rigid body is part of an articulation.
            Range: [0, 1]
            Units: unitless"""
    )
    float physxRigidBody:contactSlopCoefficient = 0 (
        displayGroup = "Advanced"
        displayName = "Contact Slop Coefficient"
        doc = """Tolerance on the angular influence of a contact that can help improve the behavior of rolling approximate collision shapes.
            Specifically, the angular component of a normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance.
            The tolerance is scaled such that the behavior improvement persists through a range of angular velocities of a rolling shape.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxRigidBody:disableGravity = 0 (
        displayName = "Disable Gravity"
        doc = "Disable gravity for the actor."
    )
    bool physxRigidBody:enableCCD = 0 (
        displayName = "Enable CCD"
        doc = "Enables swept integration for the actor."
    )
    bool physxRigidBody:enableGyroscopicForces = 1 (
        displayGroup = "Advanced"
        displayName = "Enable Gyroscopic Forces"
        doc = "Enables computation of gyroscopic forces on the rigid body."
    )
    bool physxRigidBody:enableSpeculativeCCD = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Speculative CCD"
        doc = "Register a rigid body to dynamically adjust contact offset based on velocity. This can be used to achieve a CCD effect."
    )
    float physxRigidBody:linearDamping = 0 (
        displayName = "Linear Damping"
        doc = """Linear damping coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )
    int physxRigidBody:lockedPosAxis = 0 (
        displayName = "Locked Pos Axis"
        doc = "Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2)."
    )
    int physxRigidBody:lockedRotAxis = 0 (
        displayName = "Locked Rot Axis"
        doc = "Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2)."
    )
    float physxRigidBody:maxAngularVelocity = 5729.58 (
        displayName = "Max Angular Velocity"
        doc = """Maximum allowable angular velocity for rigid body.
            Range: [0, inf)
            Units: degrees / seconds"""
    )
    float physxRigidBody:maxContactImpulse = inf (
        displayGroup = "Advanced"
        displayName = "Max Contact Impulse"
        doc = """Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic
            bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited
            by the value for the dynamic body.
            Range: [0, inf)
            Units: force * seconds = mass * distance / seconds"""
    )
    float physxRigidBody:maxDepenetrationVelocity = 3 (
        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum depenetration velocity permitted to be introduced by the solver.
            Range: [0, inf)
            Default: 5.0 * tolerancesLength
            Units: distance / seconds"""
    )
    float physxRigidBody:maxLinearVelocity = inf (
        displayName = "Max Linear Velocity"
        doc = """Maximum allowable linear velocity for the rigid body.
            Range: [0, inf)
            Units: distance / seconds"""
    )
    bool physxRigidBody:retainAccelerations = 0 (
        displayGroup = "Advanced"
        displayName = "Retain Accelerations"
        doc = "Carries over forces/accelerations between frames, rather than clearing them."
    )
    float physxRigidBody:sleepThreshold = 0.00005 (
        displayName = "Sleep Threshold"
        doc = """Mass-normalized kinetic energy threshold below which an actor may go to sleep.
            Range: [0, inf)
            Default: 0.00005 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
    )
    bool physxRigidBody:solveContact = 1 (
        displayGroup = "Advanced"
        displayName = "Solve Contact"
        doc = "Process the contacts of this rigid body in the dynamics solver."
    )
    int physxRigidBody:solverPositionIterationCount = 16 (
        displayGroup = "Advanced"
        displayName = "Solver Position Iteration Count"
        doc = "Solver position iteration counts for the body. Allowed range [1, 255]."
    )
    int physxRigidBody:solverVelocityIterationCount = 1 (
        displayGroup = "Advanced"
        displayName = "Solver Velocity Iteration Count"
        doc = "Solver velocity iteration counts for the body. Allowed range [0, 255]."
    )
    float physxRigidBody:stabilizationThreshold = 0.00001 (
        displayGroup = "Advanced"
        displayName = "Stabilization Threshold"
        doc = """Mass-normalized kinetic energy threshold below which an actor may participate in stabilization.
            Range: [0, inf)
            Default: 0.00001 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxContactReportAPI" (
    doc = "Enables contact reporting for a rigid body or articulation."
)
{
    rel physxContactReport:reportPairs (
        displayName = "Report Pairs"
        doc = "Relationship to objects. If in contact with these objects, contact reports will be sent. If relationship not set or list empty all contacts are reported."
    )
    float physxContactReport:threshold = 1 (
        displayName = "Contact Report Threshold"
        doc = """Sets the force threshold for contact reports.
            Range: [0, inf]
            Units: force = mass * distance / seconds^2"""
    )
}

class "PhysxCollisionAPI" (
    doc = "PhysX collision extended parameters"
)
{
    float physxCollision:contactOffset = -inf (
        displayGroup = "Advanced"
        displayName = "Contact Offset"
        doc = """Contact offset of a collision shape. Default value -inf means default is picked by the simulation based on the shape extent.
            Range: [maximum(0, restOffset), inf)
            Units: distance"""
    )
    float physxCollision:minTorsionalPatchRadius = 0 (
        displayGroup = "Advanced"
        displayName = "Min Torsional Patch Radius"
        doc = """Defines the minimum radius of the contact patch used to apply torsional friction.
            Range: [0, inf)
            Units: distance"""
    )
    float physxCollision:restOffset = -inf (
        displayGroup = "Advanced"
        displayName = "Rest Offset"
        doc = """Rest offset of a collision shape. Default value -inf means that the simulation sets a suitable value.
            For rigid bodies, this value is zero.
            Range: [0, contactOffset]
            Units: distance"""
    )
    float physxCollision:torsionalPatchRadius = 0 (
        displayGroup = "Advanced"
        displayName = "Torsional Patch Radius"
        doc = """Defines the radius of the contact patch used to apply torsional friction.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxConvexHullCollisionAPI" (
    doc = "PhysX convex hull collision extended parameters"
)
{
    int physxConvexHullCollision:hullVertexLimit = 64 (
        displayName = "Hull Vertex Limit"
        doc = "Convex hull vertex limit used for convex hull cooking."
    )
    float physxConvexHullCollision:minThickness = 0.001 (
        displayGroup = "Advanced"
        displayName = "Min Thickness"
        doc = """Convex hull minimum thickness.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxConvexDecompositionCollisionAPI" (
    doc = "PhysX convex decomposition extended parameters"
)
{
    float physxConvexDecompositionCollision:errorPercentage = 10 (
        displayGroup = "Advanced"
        displayName = "Error Percentage"
        doc = "Convex decomposition errorPercentage parameter."
    )
    int physxConvexDecompositionCollision:hullVertexLimit = 64 (
        displayName = "Hull Vertex Limit"
        doc = "Convex hull vertex limit used for convex hull cooking."
    )
    int physxConvexDecompositionCollision:maxConvexHulls = 32 (
        displayName = "Max Convex Hulls"
        doc = "Maximum of convex hulls created during convex decomposition."
    )
    float physxConvexDecompositionCollision:minThickness = 0.001 (
        displayGroup = "Advanced"
        displayName = "Min Thickness"
        doc = """Convex hull min thickness.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxConvexDecompositionCollision:shrinkWrap = 0 (
        displayGroup = "Advanced"
        displayName = "Shrink Wrap"
        doc = "Attempts to adjust the convex hull points so that they are projected onto the surface of the original graphics mesh."
    )
    int physxConvexDecompositionCollision:voxelResolution = 500000 (
        displayGroup = "Advanced"
        displayName = "Voxel Resolution"
        doc = "Voxel resolution used for convex decomposition."
    )
}

class "PhysxSphereFillCollisionAPI" (
    doc = "PhysX sphere fill extended parameters"
)
{
    uniform token physxSphereFillCollision:fillMode = "flood" (
        allowedTokens = ["flood", "raycast", "surface"]
        displayGroup = "Advanced"
        displayName = "Fill Mode"
        doc = "Fill mode for the the algorithm."
    )
    int physxSphereFillCollision:maxSpheres = 128 (
        displayName = "Max Spheres"
        doc = "Maximum of spheres produced. Range (2, 4000)"
    )
    int physxSphereFillCollision:seedCount = 1000 (
        displayGroup = "Advanced"
        displayName = "Seed Count"
        doc = "Seed count used for the algorithm. Range (16, 4000)"
    )
    int physxSphereFillCollision:voxelResolution = 50000 (
        displayGroup = "Advanced"
        displayName = "Voxel Resolution"
        doc = "Voxel resolution used for the algorithm. Range (10 000, 1 000 000)"
    )
}

class "PhysxTriangleMeshSimplificationCollisionAPI" (
    doc = "PhysX triangle mesh simplification extended parameters"
)
{
    float physxTriangleMeshSimplificationCollision:metric = 0.55 (
        displayName = "Simplification Metric"
        doc = "Mesh simplification accuracy."
    )
    float physxTriangleMeshSimplificationCollision:weldTolerance = -inf (
        displayGroup = "Advanced"
        displayName = "Weld Tolerance"
        doc = """Mesh weld tolerance, controls the distance at which vertices are welded. 
            Default -inf will autocompute the welding tolerance based on the mesh size. Zero value will disable welding.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxTriangleMeshCollisionAPI" (
    doc = "PhysX triangle mesh extended parameters"
)
{
    float physxTriangleMeshCollision:weldTolerance = -inf (
        displayGroup = "Advanced"
        displayName = "Weld Tolerance"
        doc = """Mesh weld tolerance, controls the distance at which vertices are welded. 
            Default -inf will autocompute the welding tolerance based on the mesh size. Zero value will disable welding.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxSDFMeshCollisionAPI" (
    doc = "PhysX SDF mesh extended parameters"
)
{
    uniform token physxSDFMeshCollision:sdfBitsPerSubgridPixel = "BitsPerPixel16" (
        allowedTokens = ["BitsPerPixel8", "BitsPerPixel16", "BitsPerPixel32"]
        displayGroup = "Advanced"
        displayName = "SDF Bits per Subgrid Pixel"
        doc = """Values of 8, 16 and 32 bits per subgrid pixel are supported. Dense SDFs always use 32 bits per pixel. The
            less bits per pixel, the smaller the resulting SDF but also the less precise. The SDF's memory consumption 
            scales proportionally with the number of bits per subgrid pixel."""
    )
    uniform bool physxSDFMeshCollision:sdfEnableRemeshing = 0 (
        displayGroup = "Advanced"
        displayName = "Enable SDF Remeshing"
        doc = """Enables optional remeshing as a preprocessing step before the SDF is computed. Remeshing can help generate 
            valid SDF data even if the input mesh has bad properties like inconsistent winding or self-intersections. The SDF
            distances (and therefore the collisions) will be slightly less accurate when remeshing is enabled."""
    )
    uniform float physxSDFMeshCollision:sdfMargin = 0.01 (
        displayGroup = "Advanced"
        displayName = "SDF Margin"
        doc = """Margin to increase the size of the SDF relative to the bounding box diagonal length of the mesh. A sdf 
            margin value of 0.01 means the sdf boundary will be enlarged in any direction by 1% of the mesh's bounding box 
            diagonal length. Representing the margin relative to the bounding box diagonal length ensures that it is scale 
            independent. Margins allow for precise distance queries in a region slightly outside of the mesh's bounding box.
            Range: [0, inf)
            Units: dimensionless"""
    )
    uniform float physxSDFMeshCollision:sdfNarrowBandThickness = 0.01 (
        displayGroup = "Advanced"
        displayName = "SDF Narrow Band Thickness"
        doc = """Size of the narrow band around the mesh surface where high resolution SDF samples are available. Outside
            of the narrow band, only low resolution samples are stored. Representing the narrow band thickness as a fraction
            of the mesh's bounding box diagonal length ensures that it is scale independent. A value of 0.01 is usually
            large enough. The smaller the narrow band thickness, the smaller the memory consumption of the sparse SDF.
            Range: [0, 1]
            Units: dimensionless"""
    )
    uniform int physxSDFMeshCollision:sdfResolution = 256 (
        displayName = "SDF Resolution"
        doc = """The spacing of the uniformly sampled SDF is equal to the largest AABB extent of the mesh, divided by the resolution.
            Choose the lowest possible resolution that provides acceptable performance; very high resolution results in
            large memory consumption, and slower cooking and simulation performance.
            Range: (1, inf)"""
    )
    uniform int physxSDFMeshCollision:sdfSubgridResolution = 6 (
        displayGroup = "Advanced"
        displayName = "SDF Subgrid Resolution"
        doc = """A positive subgrid resolution enables sparsity on signed-distance-fields (SDF) while a value of 0 leads
            to the usage of a dense SDF. A value in the range of 4 to 8 is a reasonable compromise between block size and 
            the overhead introduced by block addressing. The smaller a block, the more memory is spent on the address 
            table. The bigger a block, the less precisely the sparse SDF can adapt to the mesh's surface. In most cases 
            sparsity reduces the memory consumption of a SDF significantly. 
            Range: [0, inf)"""
    )
}

class "PhysxMaterialAPI" (
    doc = "PhysX material extended parameters"
)
{
    float physxMaterial:compliantContactDamping = 0 (
        displayGroup = "Advanced"
        displayName = "Compliant Contact Damping"
        doc = """Damping coefficient for a compliant contact model using implicit springs. Irrelevant if compliant contacts
            are disabled when compliantContactStiffness is set to zero and rigid contacts are active.
            Range: [0, inf)
            Units: force / (distance / seconds) = mass / seconds"""
    )
    float physxMaterial:compliantContactStiffness = 0 (
        displayGroup = "Advanced"
        displayName = "Compliant Contact Stiffness"
        doc = """Spring stiffness for a compliant contact model using implicit springs. A higher stiffness results in behavior
            closer to a rigid contact. The compliant contact model is only enabled if the stiffness is larger than 0.
            Range: [0, inf)
            Units: force/distance = mass / seconds / seconds"""
    )
    uniform token physxMaterial:frictionCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        displayName = "Friction Combine Mode"
        doc = "Determines the way in which two material properties will be combined to yield a friction or restitution coefficient for a collision."
    )
    bool physxMaterial:improvePatchFriction = 1 (
        displayName = "Improved Patch Friction"
        doc = 'Flag only has an effect if physxScene:frictionType "patch" friction model is used.'
    )
    uniform token physxMaterial:restitutionCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        displayName = "Restitution Combine Mode"
        doc = "Determines the way in which two material properties will be combined to yield a friction or restitution coefficient for a collision."
    )
}

class PhysxPhysicsInstancer "PhysxPhysicsInstancer" (
    doc = "Core class for instancing physics prims"
)
{
    int[] physics:protoIndices (
        doc = """<b>Required property</b>. Per-instance index into
      prototypes relationship that identifies what physics prims are instanced.  <b>Topology attribute</b> - can be animated,
      but at a potential performance impact for streaming."""
    )
    rel physics:prototypes (
        doc = """<b>Required property</b>. Orders and targets the prototype root
      prims, which can be located anywhere in the scenegraph that is convenient,
      although we promote organizing prototypes as children of the
      PhysxPhysicsInstancer.  The position of a prototype in this relationship defines
      the value an instance would specify in the protoIndices attribute to
      instance that prototype. Since relationships are uniform, this property
      cannot be animated."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxPhysicsJointInstancer "PhysxPhysicsJointInstancer" (
    doc = "Physics joint instancer, the prototypes are expected to be UsdPhysicsJoint prim types."
)
{
    int[] physics:body0Indices (
        doc = """<b>Optional property</b>. Only applicable if body0s is a point instancer. 
      An index specifies the per-instance body0 rel as the rigid body at the body0s-instancer's protoIndices[index].
      """
    )
    rel physics:body0s (
        doc = """<b>Required property</b>. The rel must contain either exactly one 
      UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage.
      If the rel is to a point instancer, the body0Indices must be specified. 
      """
    )
    int[] physics:body1Indices (
        doc = """<b>Optional property</b>. Only applicable if body0s is a point instancer. 
      An index specifies the per-instance body0 rel as the rigid body at the body0s-instancer's protoIndices[index].
      """
    )
    rel physics:body1s (
        doc = """<b>Required property</b>. The rel must contain either exactly one 
      UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage.
      If the rel is to a point instancer, the body0Indices must be specified.
      """
    )
    point3f[] physics:localPos0s (
        doc = """<b>Required property</b>. Per-instance localPos0. This transformation
      is added on top of the joint localPos0."""
    )
    point3f[] physics:localPos1s (
        doc = """<b>Required property</b>. Per-instance localPos1. This transformation
      is added on top of the joint localPos1."""
    )
    quath[] physics:localRot0s (
        doc = """<b>Required property</b>. Per-instance localRot0. This transformation
      is added on top of the joint localPos0."""
    )
    quath[] physics:localRot1s (
        doc = """<b>Required property</b>. Per-instance localRot1. This transformation
      is added on top of the joint localPos0."""
    )
    int[] physics:protoIndices (
        doc = """<b>Required property</b>. Per-instance index into
      prototypes relationship that identifies what physics prims are instanced.  <b>Topology attribute</b> - can be animated,
      but at a potential performance impact for streaming."""
    )
    rel physics:prototypes (
        doc = """<b>Required property</b>. Orders and targets the prototype root
      prims, which can be located anywhere in the scenegraph that is convenient,
      although we promote organizing prototypes as children of the
      PhysxPhysicsInstancer.  The position of a prototype in this relationship defines
      the value an instance would specify in the protoIndices attribute to
      instance that prototype. Since relationships are uniform, this property
      cannot be animated."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxPhysicsGearJoint "PhysxPhysicsGearJoint" (
    doc = "Predefined gear joint type"
)
{
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    float physics:gearRatio = 1 (
        displayName = "Gear Ratio"
        doc = """Gear ratio
            Range: (-inf, inf)
            Units: dimensionless"""
    )
    rel physics:hinge0 (
        displayName = "Hinge 0"
        doc = "Relationship to first revolute joint."
    )
    rel physics:hinge1 (
        displayName = "Hinge 1"
        doc = "Relationship to second revolute joint."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxPhysicsRackAndPinionJoint "PhysxPhysicsRackAndPinionJoint" (
    doc = "Predefined rack & pinion joint type"
)
{
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    rel physics:hinge (
        displayName = "Hinge"
        doc = "Relationship to revolute joint."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    rel physics:prismatic (
        displayName = "Prismatic"
        doc = "Relationship to prismatic joint."
    )
    float physics:ratio = 1 (
        displayName = "Ratio"
        doc = """Ratio between angular and linear motion.
            Range: (-inf, inf)
            Units: degrees / distance"""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class "PhysxJointAPI" (
    doc = "PhysX joint extended parameters"
)
{
    float physxJoint:armature = 0 (
        displayGroup = "Advanced"
        displayName = "Armature"
        doc = """Armature can help stabilize an articulation by adding to the inertial response of a joint.
            Conceptually, armature represents the inertia of an actuator driving the joint.
            Note that this parameter is used only when the joint belongs to an articulation.
            Range: [0, inf)
            Units: Linear joint - mass
                   Angular joint - mass * (distance)^2"""
    )
    bool physxJoint:enableProjection = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Projection"
        doc = "Whether the actors should get projected for this constraint (the direction will be chosen by PhysX)."
    )
    float physxJoint:jointFriction = 0 (
        displayGroup = "Advanced"
        displayName = "Joint Friction"
        doc = """Joint friction. Only applies for joints that are parts of an articulation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxJoint:maxJointVelocity = 1000000 (
        displayGroup = "Advanced"
        displayName = "Maximum Joint Velocity"
        doc = """Maximum joint velocity.
            Range: [0, inf)
            Units: Linear joint - distance / time
                   Angular joint - degrees / time"""
    )
}

class "PhysxPhysicsDistanceJointAPI" (
    doc = "PhysX distance joint extended parameters"
)
{
    float physxPhysicsDistanceJoint:springDamping = 0 (
        displayName = "Spring Damping"
        doc = """Spring damping.
            Range: [0, inf)
            Units: force * seconds / distance = mass / seconds"""
    )
    bool physxPhysicsDistanceJoint:springEnabled = 0 (
        displayName = "Spring Enabled"
        doc = "Whether spring should be enabled. (default off)"
    )
    float physxPhysicsDistanceJoint:springStiffness = 0 (
        displayName = "Spring Stiffness"
        doc = """Spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / seconds^2"""
    )
}

class "PhysxLimitAPI"
{
    float physxLimit:__INSTANCE_NAME__:bounceThreshold = 0 (
        displayName = "Bounce Threshold"
        doc = """Determines the minimum impact velocity which will cause the joint to bounce.
            Range: [0, inf)
            Units: linear - distance / seconds
                   angular - degrees / seconds"""
    )
    float physxLimit:__INSTANCE_NAME__:contactDistance = 0 (
        displayName = "Contact Distance"
        doc = """The distance inside the limit value at which the limit will be considered to be active by the solver.
            As this value is made larger, the limit becomes active more quickly. It thus becomes less likely to violate
            the extents of the limit, but more expensive.
            Range: [0, inf)
            Units: linear - distance
                   angular - degrees"""
    )
    float physxLimit:__INSTANCE_NAME__:damping = 0 (
        displayName = "Damping"
        doc = """If spring is greater than zero, this is the damping of the limit spring.
            Range: [0, inf)
            Units: linear - force / distance * seconds
                   angular - torque / degrees * seconds"""
    )
    float physxLimit:__INSTANCE_NAME__:restitution = 0 (
        displayName = "Restitution"
        doc = """Controls the amount of bounce when the joint hits a limit.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxLimit:__INSTANCE_NAME__:stiffness = 0 (
        displayName = "Stiffness"
        doc = """If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
            Range: [0, inf)
            Units: linear - force / distance
                   angular - torque / degrees"""
    )
}

class "PhysicsJointStateAPI" (
    doc = '''The PhysicsJointStateAPI is applied to a joint primitive 
    (i.e. any PhysicsJoint-derived type) and provides read/write access 
    to the joint position and velocity for a specific joint axis.
    The PhysicsJointStateAPI is a multipleApply schema, and its instance name 
    TfToken defines the joint axis: The name can be "transX", "transY", "transZ", 
    "rotX", "rotY", "rotZ" or its "linear" for prismatic joint or "angular" 
    for revolute joints, respectively.'''
)
{
    float state:__INSTANCE_NAME__:physics:position = 0 (
        displayName = "Position"
        doc = """Joint state position defines the relative difference between
            joint body0 frame and joint body1 frame in world frame.
            Range: (-inf, inf)
            Units: linear - distance
                   angular - degrees"""
    )
    float state:__INSTANCE_NAME__:physics:velocity = 0 (
        displayName = "Velocity"
        doc = """Joint state velocity defines the relative velocity between
            joint body0 and joint body1.
            Range: (-inf, inf)
            Units: linear - distance / seconds
                   angular - degrees / seconds"""
    )
}

class "PhysxArticulationAPI" (
    doc = "PhysX articulation extended parameters"
)
{
    bool physxArticulation:articulationEnabled = 1 (
        displayName = "Articulation Enabled"
        doc = "Boolean defining whether articulation is enabled or disabled."
    )
    bool physxArticulation:enabledSelfCollisions = 1 (
        displayName = "Self Collisions Enabled"
        doc = "Boolean defining whether self collisions should be enabled or disabled."
    )
    float physxArticulation:sleepThreshold = 0.00005 (
        displayName = "Sleep Threshold"
        doc = """Mass-normalized kinetic energy threshold below which the articulation may go to sleep.
            Range: [0, inf)
            Default: 0.00005 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
    )
    int physxArticulation:solverPositionIterationCount = 32 (
        displayName = "Solver Position Iteration Count"
        doc = "Solver position iteration counts for the body. Allowed range [1, 255]."
    )
    int physxArticulation:solverVelocityIterationCount = 1 (
        displayName = "Solver Velocity Iteration Count"
        doc = "Solver velocity iteration counts for the body. Allowed range [0, 255]."
    )
    float physxArticulation:stabilizationThreshold = 0.00001 (
        displayName = "Stabilization Threshold"
        doc = """The mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.
            Range: [0, inf)
            Default: 0.00001 * tolerancesSpeed * tolerancesSpeed
            Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxArticulationForceSensorAPI" (
    doc = """ WARNING: THIS API IS DEPRECATED AND WILL BE REMOVED IN A FUTURE RELEASE.
    PhysX articulation sensor to measure spatial force.
    Articulation sensor API must be applied to a UsdGeom.Xformable in order to get
    a transformation information. The UsdGeom.Xformable must be created under the
    articulated rigid body in order to compute a relative transformation between the
    body and the sensor."""
)
{
    bool physxArticulationForceSensor:constraintSolverForcesEnabled = 1 (
        displayName = "Constraint Solver Forces Enabled"
        doc = "Boolean defining whether to receive forces from constraint solver."
    )
    vector3f physxArticulationForceSensor:force = (0, 0, 0) (
        displayName = "Force"
        doc = """Spatial force in the local frame of the sensor computed by the simulation.
            Units: force"""
    )
    bool physxArticulationForceSensor:forwardDynamicsForcesEnabled = 1 (
        displayName = "Forward Dynamics Forces Enabled"
        doc = "Boolean defining whether to receive forces from forward dynamics."
    )
    bool physxArticulationForceSensor:sensorEnabled = 1 (
        displayName = "Force Sensor Enabled"
        doc = "Boolean defining whether sensor is enabled."
    )
    vector3f physxArticulationForceSensor:torque = (0, 0, 0) (
        displayName = "Torque"
        doc = """Spatial torque in the local frame of the sensor computed by the simulation.
            Units: torque"""
    )
    bool physxArticulationForceSensor:worldFrameEnabled = 0 (
        displayName = "World Frame Force Enabled"
        doc = "Boolean defining whether reported force is in world frame."
    )
}

class "PhysxForceAPI" (
    doc = """PhysX schema API that applies a force and torque to a rigid body 
    (UsdGeom.Xformable with UsdPhysicsRigidBodyAPI). The API can be applied to either:
    - The rigid-body Xformable, in which case the force is applied at the body's center of mass.
    - To an UsdGeom.Xformable that is a child of the rigid-body Xformable, 
    in which case the force is applied at the location defined by the Xformable.

    The worldFrameEnabled flag defines what coordinate frame the force and torque are expressed in. 
    Note that any scale transform operations will only affect the force and torque values if on \"acceleration\" mode."""
)
{
    vector3f physxForce:force = (0, 0, 0) (
        displayName = "Force"
        doc = """Force to apply defined in global or local frame depending on worldFrameEnabled. The force is applied at the position
            defined by the relative transform to the parent rigid-body Xformable, or at the body's center of mass if the API is applied
            directly to a rigid-body Xformable. For units see mode attribute.
            Range: (-inf, inf)"""
    )
    bool physxForce:forceEnabled = 1 (
        displayName = "Force Enabled"
        doc = "Boolean defining whether the force and torque are enabled or disabled."
    )
    uniform token physxForce:mode = "acceleration" (
        allowedTokens = ["force", "acceleration"]
        displayName = "Mode"
        doc = """Force mode, can be either a force or an acceleration.
            force - units:  (linear) mass * distance / seconds^2, i.e. a force
                            (angular) mass * distance * distance / time^2, i.e. a torque
            acceleration - units: (linear) distance / seconds^2, i.e. a linear acceleration.
                            (angular) degrees / seconds^2, i.e. an angular acceleration."""
    )
    vector3f physxForce:torque = (0, 0, 0) (
        displayName = "Torque"
        doc = """Torque to apply defined in the global or local frame depending on worldFrameEnabled. For units see mode attribute.
            Range: (-inf, inf)"""
    )
    bool physxForce:worldFrameEnabled = 0 (
        displayName = "World Frame Enabled"
        doc = "Boolean defining whether the force and torque are in world frame or in local frame."
    )
}

class "PhysxCharacterControllerAPI" (
    doc = "PhysxCharacterControllerAPI can be applied to a capsuleGeom. It will turn the capsule into a character controller."
)
{
    uniform token physxCharacterController:climbingMode = "easy" (
        allowedTokens = ["easy", "constrained"]
        displayName = "Climb Mode"
        doc = "The climbing mode."
    )
    float physxCharacterController:contactOffset = 0.1 (
        displayName = "Contact Offset"
        doc = """The contact offset used by the controller.
            Range: [0, inf)
            Units: distance"""
    )
    float physxCharacterController:invisibleWallHeight = 0 (
        displayName = "Invisible Wall Height"
        doc = """Height of invisible walls created around non-walkable triangles.
            Range: [0, inf)
            Units: distance"""
    )
    float physxCharacterController:maxJumpHeight = 0 (
        displayName = "Max Jump Height"
        doc = """Maximum height a jumping character can reach.
            Range: [0, inf)
            Units: distance"""
    )
    vector3f physxCharacterController:moveTarget = (0, 0, 0) (
        displayName = "Move Target"
        doc = "Desired target position that CCT should try to reach."
    )
    uniform token physxCharacterController:nonWalkableMode = "preventClimbing" (
        allowedTokens = ["preventClimbing", "preventClimbingForceSliding"]
        displayName = "Non Walkable Mode"
        doc = "The non-walkable mode controls if a character controller slides or not on a non-walkable part."
    )
    float physxCharacterController:scaleCoeff = 0.8 (
        displayName = "Scale Coefficient"
        doc = """Scale coefficient for underlying kinematic actor.
            Range: [0, inf)
            Units: dimensionless"""
    )
    rel physxCharacterController:simulationOwner (
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that simulates this character controller.
        By default, this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )
    float physxCharacterController:slopeLimit = 0.3 (
        displayName = "Slope Limit"
        doc = """Slope limit which the CCT can climb. The limit is expressed as the cosine of the desired limit angle. 
        A value of 0 disables this feature."""
    )
    float physxCharacterController:stepOffset = 0.5 (
        displayName = "Step Offset"
        doc = """Defines the maximum height of an obstacle which the character can climb.
            Range: [0, inf)
            Units: distance"""
    )
    uniform token physxCharacterController:upAxis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        displayName = "Up Axis"
        doc = "Up axis for stepping functionality."
    )
    float physxCharacterController:volumeGrowth = 1.5 (
        displayName = "Volume Growth"
        doc = """Cached volume growth.
            Range: [0, inf)
            Units: dimensionless"""
    )
}

class "PhysxTriggerAPI" (
    doc = "PhysX trigger"
)
{
    uniform token physxTrigger:enterScriptType = "scriptFile" (
        allowedTokens = ["scriptFile", "scriptBuffer"]
        displayName = "Enter Script Type"
        doc = "Enter script type. Script file tries to find a file on disc and execute. Script buffer does execute the provided script string directly."
    )
    uniform token physxTrigger:leaveScriptType = "scriptFile" (
        allowedTokens = ["scriptFile", "scriptBuffer"]
        displayName = "Leave Script Type"
        doc = "Leave script type. Script file tries to find a file on disc and execute. Script buffer does execute the provided script string directly."
    )
    uniform token physxTrigger:onEnterScript (
        displayName = "On Enter Script"
        doc = "Enter script."
    )
    uniform token physxTrigger:onLeaveScript (
        displayName = "On Leave Script"
        doc = "Leave script."
    )
}

class "PhysxTriggerStateAPI" (
    doc = "PhysX trigger state"
)
{
    rel physxTrigger:triggeredCollisions (
        displayName = "Triggered Collisions"
        doc = "List of collisions that are currently triggered."
    )
}

class "PhysxCookedDataAPI" (
    doc = "PhysX cooked data storage."
)
{
    uchar[] physxCookedData:__INSTANCE_NAME__:buffer
}

class "PhysxTendonAxisAPI" (
    doc = """WARNING: Draft API, this design is not fixed and may change in the future. At this point, we don't support
    multi-axis joints (e.g. spherical, D6).
    
    Applied to a Physics Joint that must be part of an articulation, e.g. PhysicsRevoluteJoint or PhysicsPrismaticJoint.
    
    A tendon axis is part of a fixed tendon and contributes to the tendon length via the position of its associated
    articulation joint axis and the gearing attribute. The tendon applies spring-damper forces to the articulation links,
    scaled by the force coefficient, that aim to maintain constraints on the tendon lengths.
    
    A joint may have multiple tendon axes that belong to distinct fixed tendons; therefore, the fixed-tendon APIs are
    multi-apply and are grouped into tendons by their instance names.
    
    Fixed tendons do not allow linking arbitrary joint axes of the articulation: The respective joints must all be
    directly connected to each other in the articulation structure, i.e. each of the joints in the tendon must be
    connected by a single articulation link to another joint in the same tendon. This implies that fixed tendons can
    branch along with a branching articulation as well. In addition, the root tendon axis created by applying the
    PhysxTendonAxisRootAPI must be applied to the articulation joint that is the common ancestor of all joint
    axes in the fixed tendon.
    
    In a future version, it will be possible to include multiple axes of a multi-axis joint (e.g. a spherical joint)
    in the fixed tendon by adding them to the axis token array, and setting their gearing and forceCoefficient accordingly
    in the respective float arrays (in the same order). Until then, the jointAxis token array is ignored, and only the first
    element of the gearing array is considered.
    """
)
{
    float[] physxTendon:__INSTANCE_NAME__:forceCoefficient = [1] (
        displayName = "Force Coefficient"
        doc = """Joint force coefficient(s) per joint axis in axis token array, in the same order.
            Range: (-inf, inf)
            Units: translational axis: unitless
                   rotational axis:    distance"""
    )
    float[] physxTendon:__INSTANCE_NAME__:gearing = [1] (
        displayName = "Gearing"
        doc = """Joint gearing(s) per joint axis in axis token array, in the same order.
            Range: (-inf, inf)
            Units: translational axis: unitless
                   rotational axis:    distance/degrees"""
    )
    uniform token[] physxTendon:__INSTANCE_NAME__:jointAxis (
        allowedTokens = ["transX", "transY", "transZ", "rotX", "rotY", "rotZ"]
        displayName = "Joint Axis"
        doc = "Specifies target joint axis/axes. Ignored when the joint only has a single axis, e.g. a revolute joint."
    )
}

class "PhysxTendonAxisRootAPI" (
    apiSchemas = ["PhysxTendonAxisAPI:__INSTANCE_NAME__"]
    doc = """WARNING: Draft API, this design is not fixed and may change in the future. At this point, we don't support
    multi-axis joints (e.g. spherical, D6) yet.
    
    Applied to a Physics Joint that must be part of an articulation, e.g. PhysicsRevoluteJoint or PhysicsPrismaticJoint.
    
    In addition to creating a regular axis of the fixed tendon, the root API provides attributes that apply to the
    entire tendon. The root API must be applied to the joint that is the common ancestor of all joint axes in the tendon.
    
    For restrictions on tendon structure and grouping of axes into tendons, see PhysxTendonAxisAPI.
    """
)
{
    float physxTendon:__INSTANCE_NAME__:damping = 0 (
        displayName = "Damping"
        doc = """Tendon length damping.
            Range: [0, inf)
            Units: force / distance * time = mass / time"""
    )
    float physxTendon:__INSTANCE_NAME__:limitStiffness = 0 (
        displayName = "Limit Stiffness"
        doc = """Tendon length-limit spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )
    float physxTendon:__INSTANCE_NAME__:lowerLimit = -inf (
        displayName = "Lower Limit"
        doc = """Tendon length lower limit.
            Range: (-inf, upperLimit].
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:offset = 0 (
        displayName = "Offset"
        doc = """Tendon length offset.
            Range: (-inf, inf)
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:restLength = 0 (
        displayName = "Rest Length"
        doc = """Tendon rest length.
            Range: (-inf, inf)
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:stiffness = 0 (
        displayName = "Stiffness"
        doc = """Tendon length spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )
    bool physxTendon:__INSTANCE_NAME__:tendonEnabled = 1 (
        displayName = "Tendon Enabled"
        doc = "Enables/disables the tendon from contributing to the articulation dynamics."
    )
    float physxTendon:__INSTANCE_NAME__:upperLimit = inf (
        displayName = "Upper Limit"
        doc = """Tendon length upper limit.
            Range: [lowerLimit, inf)
            Units: distance"""
    )
}

class "PhysxTendonAttachmentAPI" (
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.
    
    Applied to an articulation-link rigid-body Xformable.
    
    A tendon attachment is part of a spatial tendon and is attached to an articulation link. The distance between the
    attachment and its parent attachment contributes to the length of the tendon, after scaling by the gearing
    attribute.

    The localPos attribute defines the translational offset of the attachment in the link's local frame; in particular,
    this means that the offset is scaled together with any scaling applied to the link.
    
    An articulation link may have multiple distinct attachments that belong to the same or distinct spatial tendons;
    therefore, the spatial tendon APIs are multi-apply and each attachment must have a unique instance name that is
    used in parent-child relationships of the attachments."""
)
{
    float physxTendon:__INSTANCE_NAME__:gearing = 1 (
        displayName = "Gearing"
        doc = """Attachment distance scaling factor.
            Range: (-inf, inf)
            Units: unitless"""
    )
    point3f physxTendon:__INSTANCE_NAME__:localPos = (0, 0, 0) (
        displayName = "Local Position"
        doc = """Location of the attachment. Only considered if API is applied to an articulation link (i.e. with a PhysicsRigidBodyAPI).
            Units: (local-frame) distance"""
    )
    uniform token physxTendon:__INSTANCE_NAME__:parentAttachment (
        displayName = "Parent Attachment"
        doc = "API instance name of parent attachment at parentLink."
    )
    rel physxTendon:__INSTANCE_NAME__:parentLink (
        displayName = "Parent Link"
        doc = "Relationship to parent link that has a PhysxTendonAttachmentAPI or PhysxTendonAttachmentRootAPI with instance name parentAttachment applied."
    )
}

class "PhysxTendonAttachmentRootAPI" (
    apiSchemas = ["PhysxTendonAttachmentAPI:__INSTANCE_NAME__"]
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.

    Applied to an articulation-link rigid-body Xformable.

    The root API creates a new spatial tendon tree. The root tendon attachment is the only attachment in a tendon tree
    that does not have a parent, so the parentLink, parentAttachment, and gearing attributes inherited from
    PhysxTendonAttachmentAPI are ignored for a root.

    Spatial tendons create line-of-sight distance constraints between links of a single articulation. In particular,
    spatial tendons run through attachments that are positioned relative to a rigid-body link, and their length is
    defined as a weighted sum of the distance between the attachments in the tendon.

    Spatial tendons may branch, in which case the tendon splits up into multiple conceptual sub-tendons, one for each
    root-to-leaf path in the tendon tree. The tendon tree starts at the root, and its topology is defined by the
    attachments' parentLink rel and parentAttachment token.

    It is possible to create multiple attachments per link, see PhysxTendonAttachmentAPI.

    Details on dynamics:

    The length of a sub-tendon in the tree is

    subTendonLength = sum(gearing[i] * |p[i] - p_parent[i]|)

    where the sum is evaluated along the unique tree path between root and leaf. The gearing[i] is the i-th attachment's
    gearing, and |p[i] - p_parent[i]| is the distance between the positions of the i-th attachment and its parent
    attachment.

    Each subtendon has spring-damper dynamics acting on the length constraint

    constraint = 0 = offset + subTendonLength - restLength

    where the offset is a common summand for all sub-tendons of a spatial tendon, and the restLength is specific to a
    sub-tendon, see the PhysxTendonAttachmentLeafAPI.

    If limits are not active, the sub-tendon force that acts on the leaf is

    F = stiffness * constraint + damping * tendonVelocity

    where tendonVelocity is the sum of the time derivatives of the line-of-sight distances between
        1) the leaf and its parent attachment and
        2) the tendon root and its first child attachment on the path to the leaf.
    Stiffness and damping are common parameters for all sub-tendons.

    The 3D force applied at the leaf attachment is equal to 

    F * (p_parent - p_leaf).

    where p_leaf and p_parent are the leaf's position and its parent's position, respectively. The reaction force acting
    on the root attachment is

    F * (p_child_leaf - p_root)

    where p_child_leaf is the position of the root's child attachment that leads to the leaf that produces F,
    and p_root is the root attachment position. The tendon force is not further propagated through the tendon, so at
    intermediate attachments (i.e. created by PhysxTendonAttachmentAPI) no forces are applied.

    Note that a spatial tendon may both pull and push on the leaf and root attachments. A string-like, one-sided constraint
    can be implemented using the sub-tendon's length limits.

    Sub-tendon length limits constrain the offset length

    lowerLimit <= subTendonLength + offset<= upperLimit

    and, when active, add a restoring spring force parametrized by limitStiffness to the tendon force, analogous to the
    length constraint force above. Limit dynamics are damped by the tendon-length damping that is applied regardless of
    a limit being active. Limit parameters are attributes of the PhysxTendonAttachmentLeafAPI."""
)
{
    float physxTendon:__INSTANCE_NAME__:damping = 0 (
        displayName = "Damping"
        doc = """Common sub-tendon length damping.
            Range: [0, inf)
            Units: force / distance * time = mass / time"""
    )
    float physxTendon:__INSTANCE_NAME__:limitStiffness = 0 (
        displayName = "Limit Stiffness"
        doc = """Common sub-tendon length-limit spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )
    float physxTendon:__INSTANCE_NAME__:offset = 0 (
        displayName = "Offset"
        doc = """Common sub-tendon length offset.
            Range: (-inf, inf)
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:stiffness = 0 (
        displayName = "Stiffness"
        doc = """Common sub-tendon length spring stiffness.
            Range: [0, inf)
            Units: force / distance = mass / time / time"""
    )
    bool physxTendon:__INSTANCE_NAME__:tendonEnabled = 1 (
        displayName = "Tendon Enabled"
        doc = "Enables/disables the tendon from contributing to the articulation dynamics."
    )
}

class "PhysxTendonAttachmentLeafAPI" (
    apiSchemas = ["PhysxTendonAttachmentAPI:__INSTANCE_NAME__"]
    doc = """WARNING: Draft API, this design is not fixed and may change in the future.
    
    Applied to an articulation-link rigid-body Xformable.
    
    The leaf API creates a new sub-tendon between the leaf and the root attachment. A leaf cannot have any children,
    i.e. there cannot be another attachment API that refers to a leaf as parent."""
)
{
    float physxTendon:__INSTANCE_NAME__:lowerLimit = -inf (
        displayName = "Lower Length Limit"
        doc = """Sub-tendon length lower limit.
            Range: (-inf, upperLimit]
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:restLength = -inf (
        displayName = "Rest Length"
        doc = """Sub-tendon rest length. If set to a negative value, the rest length is computed internally from the articulation pose and the attachment positions at simulation start.
            Range: [0, inf)
            Units: distance"""
    )
    float physxTendon:__INSTANCE_NAME__:upperLimit = inf (
        displayName = "Upper Length Limit"
        doc = """Sub-tendon length upper limit.
            Range: [lowerLimit, inf)
            Units: distance"""
    )
}

class "PhysxVehicleContextAPI" (
    doc = "PhysX vehicles general settings. Has to be applied to a PhysicsScene prim."
)
{
    float3 physxVehicleContext:forwardAxis (
        displayName = "Forward Axis"
        doc = """Deprecated. Please use longitudinalAxis instead.
              
              The normalized vector defining the general forward direction to use for vehicles.
              Has to match one of the base axes (1,0,0), (0,1,0) etc. Arbitrary axes are not
              supported.

              Note: will be ignored if longitudinalAxis is used."""
    )
    uniform token physxVehicleContext:longitudinalAxis = "undefined" (
        allowedTokens = ["posX", "negX", "posY", "negY", "posZ", "negZ", "undefined"]
        displayName = "Longitudinal Axis"
        doc = '''The axis defining the general forward direction to use for vehicles.

              Note: the "undefined" token value is only a valid option for indicating that the
              deprecated attribute forwardAxis should be used instead. Else, a valid axis has to
              be chosen.'''
    )
    float3 physxVehicleContext:upAxis (
        displayName = "Up Axis"
        doc = """Deprecated. Please use verticalAxis instead.
              
              The normalized vector defining the general up direction to use for vehicles.
              Has to match one of the base axes (1,0,0), (0,1,0) etc. Arbitrary axes are not
              supported.

              Note: will be ignored if verticalAxis is used."""
    )
    uniform token physxVehicleContext:updateMode = "velocityChange" (
        allowedTokens = ["velocityChange", "acceleration"]
        displayName = "Update Mode"
        doc = """The dynamics of the vehicle simulation can get applied to the PhysX rigid 
              body by either applying an acceleration or by using a velocity delta."""
    )
    uniform token physxVehicleContext:verticalAxis = "undefined" (
        allowedTokens = ["posX", "negX", "posY", "negY", "posZ", "negZ", "undefined"]
        displayName = "Vertical Axis"
        doc = '''The axis defining the general up direction to use for vehicles.

              Note: the "undefined" token value is only a valid option for indicating that the
              deprecated attribute upAxis should be used instead. Else, a valid axis has to be
              chosen.'''
    )
}

class PhysxVehicleTireFrictionTable "PhysxVehicleTireFrictionTable" (
    doc = "Table defining the friction values of a tire against a given set of ground materials."
)
{
    float defaultFrictionValue = 1 (
        displayName = "Default Friction Value"
        doc = """The friction value to use for the tire against the ground if the material of the ground surface is not among the materials
        listed in groundMaterials. The value has to be greater or equal 0."""
    )
    float[] frictionValues (
        displayName = "Friction Values"
        doc = "The friction values to use for the tire against the ground materials listed under groundMaterials. The array needs to have the same size as the list of materials specified in groundMaterials."
    )
    rel groundMaterials (
        displayName = "Ground Materials"
        doc = "Relationships to Material instances that have PhysicsMaterialAPI applied. For each material, a friction value has to be specified in the frictionValues attribute. If a material is encountered that has not been listed, the value declared in defaultFrictionValue will be used."
    )
}

class "PhysxVehicleWheelAPI" (
    doc = """Properties of a PhysX vehicle wheel. If the wheel setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI applied.
             If the intent is to share the wheel setup, PhysxVehicleWheelAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
)
{
    float physxVehicleWheel:dampingRate (
        displayName = "Damping Rate"
        doc = """The damping rate applied to the wheel (units: torque * seconds = mass * distance * distance / seconds).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleWheel:mass (
        displayName = "Mass"
        doc = """The mass of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleWheel:maxBrakeTorque (
        displayName = "Max Brake Torque"
        doc = """Deprecated. Please use PhysxVehicleBrakesAPI instead.
              
              The maximum brake torque that can be applied to the wheel
              (units: mass * distance * distance / seconds / seconds).
              
              Note: will be ignored if PhysxVehicleBrakesAPI is used."""
    )
    float physxVehicleWheel:maxHandBrakeTorque (
        displayName = "Max Handbrake Torque"
        doc = """Deprecated. Please use PhysxVehicleBrakesAPI instead.
              
              The maximum hand brake torque that can be applied to the wheel
              (units: mass * distance * distance / seconds / seconds).
              
              Note: will be ignored if PhysxVehicleBrakesAPI is used."""
    )
    float physxVehicleWheel:maxSteerAngle (
        displayName = "Max Steer Angle"
        doc = """Deprecated. Please use PhysxVehicleSteeringAPI instead.
        
              The maximum steer angle (in radians) that can be achieved by the wheel.
        
              Note: will be ignored if PhysxVehicleSteeringAPI is used."""
    )
    float physxVehicleWheel:moi (
        displayName = "Moment of Inertia"
        doc = """The moment of inertia (metal wheel plus tire) about the rolling axis (units: 
              mass * distance * distance).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleWheel:radius (
        displayName = "Radius"
        doc = """The radius of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleWheel:toeAngle (
        displayName = "Toe Angle"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The wheel toe angle (in radians).
        
              Note: currently, this attribute is only considered for vehicles using the
                    PhysxVehicleDriveStandard drive type.
              
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    float physxVehicleWheel:width (
        displayName = "Width"
        doc = """The width of the wheel (metal wheel plus tire).
        
              Note: this attribute has to be specified (there is no default)."""
    )
}

class "PhysxVehicleTireAPI" (
    doc = """Properties of a PhysX vehicle tire. If the tire setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI applied.
             If the intent is to share the tire setup, PhysxVehicleTireAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
)
{
    float physxVehicleTire:camberStiffness = -1 (
        displayName = "Camber Stiffness"
        doc = """Tire camber stiffness (units: mass * distance / seconds / seconds / radians).
              The value has to be greater or equal 0. Camber force can be approximated as: 
              camberStiffness*camberAngle.
              
              Note: the default value -1 is not a valid value as such but indicates that the 
              deprecated attribute camberStiffnessPerUnitGravity should be used instead."""
    )
    float physxVehicleTire:camberStiffnessPerUnitGravity = 0 (
        displayName = "Camber Stiffness per Unit Gravity"
        doc = """Deprecated. Please use camberStiffness instead.
              
              Tire camber stiffness per unit gravitational acceleration. Camber stiffness of the tire is
              calculated as gravitationalAcceleration*camberStiffnessPerUnitGravity.
              
              Note: will be ignored if camberStiffness is used."""
    )
    rel physxVehicleTire:frictionTable (
        displayName = "Friction Table"
        doc = """A relationship to a PhysxVehicleTireFrictionTable instance.
        
              Note: if not defined, a default friction table will be used."""
    )
    float2[] physxVehicleTire:frictionVsSlipGraph (
        displayName = "Friction vs Slip Graph"
        doc = """Graph of friction vs longitudinal slip with 3 points. The friction value extracted from this
              graph will be multiplied with the friction value of the combination of ground material and tire
              type. The array is expected to have 3 entries/points. For the first point, the first value is 
              always zero and the second value is the friction available at zero longitudinal slip. For the
              second point, the first value is the longitudinal slip with maximum friction and the second
              value is the maximum friction. For the third point, the first value is the end point of the graph
              and the second value is the friction for slips greater than the end point of the graph. Note that
              the friction value of the first point is typically smaller than the friction value of the second
              point and the friction value of the second point is typically larger than the friction value of
              the third point.
              
              Note: if not defined, the following values will be used: [(0.0, 1.0), (0.1, 1.0), (1.0, 1.0)]."""
    )
    float2 physxVehicleTire:lateralStiffnessGraph = (0, 0) (
        displayName = "Lateral Stiffness Graph"
        doc = """Tire lateral stiffness is represented as a graph of tire load that has linear behavior
              near zero load and flattens at large loads. The first value of the parameter describes the
              minimum normalized load (load/restLoad) that gives a flat lateral stiffness response to load.
              This value has to be greater or equal 0. The second value of the parameter defines the lateral
              stiffness when the response is flat (the max lateral stiffness, units: mass * distance / seconds / seconds).
              This value has to be positive.
              
              Note: the default value (0, 0) is not a valid value as such but indicates that the
              deprecated attributes latStiffX and latStiffY should be used instead."""
    )
    float physxVehicleTire:latStiffX = 2 (
        displayName = "Lateral Stiffness X"
        doc = """Deprecated. Please use lateralStiffnessGraph instead.
              
              Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and 
              flattens at large loads. The parameter describes the minimum normalized load (load/restLoad)
              that gives a flat lateral stiffness response to load.
              
              Note: will be ignored if lateralStiffnessGraph is used."""
    )
    float physxVehicleTire:latStiffY (
        displayName = "Lateral Stiffness Y"
        doc = """Deprecated. Please use lateralStiffnessGraph instead.
              
              Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and 
              flattens at large loads. The parameter describes the maximum possible value of lateralStiffness/restLoad
              that occurs when (load/restLoad) >= latStiffX. If load/restLoad is greater than latStiffX then
              the lateral stiffness is latStiffY*restLoad, else the lateral stiffness is latStiffY*(load/latStiffX).
              
              Note: will be ignored if lateralStiffnessGraph is used.
              
              Note: if not defined, the value 17.095 will be used."""
    )
    float physxVehicleTire:longitudinalStiffness = 0 (
        displayName = "Longitudinal Stiffness"
        doc = """Tire longitudinal stiffness (units: mass * distance / seconds / seconds).
              The value has to be positive. The resulting longitudinal force can be approximated as: 
              longitudinalStiffness*longitudinalSlip.
              
              Note: the default value 0 is not a valid value as such but indicates that the deprecated
              attribute longitudinalStiffnessPerUnitGravity should be used instead."""
    )
    float physxVehicleTire:longitudinalStiffnessPerUnitGravity (
        displayName = "Longitudinal Stiffness per Unit Gravity"
        doc = """Deprecated. Please use longitudinalStiffness instead.
              
              Tire longitudinal stiffness per unit gravitational acceleration. Longitudinal stiffness of 
              the tire is calculated as gravitationalAcceleration*longitudinalStiffnessPerUnitGravity.
              
              Note: will be ignored if longitudinalStiffness is used.
              
              Note: if not defined, the value 500 will be used."""
    )
    float physxVehicleTire:restLoad = 0 (
        displayName = "Rest Load"
        doc = """The load that develops on the tire when the vehicle is at rest on a flat plane
                 (units: force = mass * distance / seconds / seconds). The value has to be greater or equal 0.
                 If set to 0, the rest load will get computed automatically using the approximation of:
                 gravitational acceleration * sprungMass.
                 
                 Note: it is not possible for a vehicle to have some rest load values being user-defined
                 and some being computed automatically. Either all values have to be user-defined or all
                 have to be set to 0 for auto-computation."""
    )
}

class "PhysxVehicleSuspensionAPI" (
    doc = """Properties of a PhysX vehicle wheel suspension. If the suspension setup does not need to be shared 
             among vehicle instances, it can be applied to the prim which has PhysxVehicleWheelAttachmentAPI
             applied. If the intent is to share the suspension setup, PhysxVehicleSuspensionAPI can be 
             applied to a separate prim which can be linked to (see PhysxVehicleWheelAttachmentAPI)."""
)
{
    float physxVehicleSuspension:camberAtMaxCompression (
        displayName = "Camber at Max Compression"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at maximum compression.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    float physxVehicleSuspension:camberAtMaxDroop (
        displayName = "Camber at Max Droop"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at maximum droop.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    float physxVehicleSuspension:camberAtRest (
        displayName = "Camber at Rest"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              Camber angle (in radians) of wheel when the suspension is at its rest position.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    float physxVehicleSuspension:maxCompression (
        displayName = "Max Compression"
        doc = """Deprecated. Please use travelDistance instead.
        
              Maximum compression from rest state allowed by suspension spring (units: distance).
              The value has to be positive.
              
              Note: will be ignored if travelDistance is authored."""
    )
    float physxVehicleSuspension:maxDroop (
        displayName = "Max Droop"
        doc = """Deprecated. Please use travelDistance instead.
              
              Maximum elongation from rest state allowed by suspension spring (units: distance).
              The value has to be positive unless it should get computed automatically in which case any
              negative number can be used to indicate as much. It is highly recommended to chose a value
              close to: sprungMass * gravity / springStrength.
              
              Note: will be ignored if travelDistance is authored."""
    )
    float physxVehicleSuspension:springDamperRate (
        displayName = "Spring Damper Rate"
        doc = """Spring damper rate of suspension unit (units: force * seconds / distance = mass / seconds).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleSuspension:springStrength (
        displayName = "Spring Strength"
        doc = """Spring strength of suspension unit (units: force / distance = mass / seconds / seconds).
        
              Note: this attribute has to be specified (there is no default)."""
    )
    float physxVehicleSuspension:sprungMass = 0 (
        displayName = "Sprung Mass"
        doc = """Mass of vehicle that is supported by suspension spring (units: mass).
              If set to 0, the sprung mass will get computed automatically.
              
              Note: it is not possible for a vehicle to have some sprung mass values being user-defined and some 
              being computed automatically. Either all values have to be user-defined or all have to be set to 0 
              for auto-computation."""
    )
    float physxVehicleSuspension:travelDistance (
        displayName = "Travel Distance"
        doc = """Distance the wheel can travel along the suspension when going from max compression to 
              max droop (units: distance). The value has to be positive.
              
              Note: either this attribute or the deprecated maxCompression/maxDroop have to
              to be specified (with the former taking precedence). When migrating from the
              deprecated attributes, travelDistance can be set to the sum of maxCompression
              and maxDroop."""
    )
}

class "PhysxVehicleWheelAttachmentAPI" (
    doc = """For every wheel of a vehicle, this class defines the attachment properties. Has to 
            be applied to a prim that is a descendant of a prim with PhysxVehicleAPI applied. If the wheel
            attachment prim (the prim with PhysxVehicleWheelAttachmentAPI applied) is a UsdGeomXformable,
            then the position and orientation of the prim will be set by the vehicle simulation. If the
            wheel attachment prim has PhysicsCollisionAPI applied, then none of its descendants are allowed
            to have PhysicsCollisionAPI applied. If the wheel attachment prim is a UsdGeomXformable but does
            not have PhysicsCollisionAPI applied, then exactly one direct child prim among all descendants
            is allowed to have PhysicsCollisionAPI applied. That prim will be interpreted as the collision
            geometry of the wheel and its position and orientation will be set by the vehicle simulation
            too. Note that the relative transform between the collision geometry prim and the wheel attachment
            prim at the start of the simulation will be maintained (the relative transform with respect to
            the center of mass frame of the vehicle rigid body that is). If there is no desire to have the
            vehicle simulation control the transform of the wheel attachment prim, then a prim type that is
            not a UsdGeomXformable should be chosen."""
)
{
    rel physxVehicleWheelAttachment:collisionGroup (
        displayName = "Collision Group"
        doc = "A relationship to a PhysicsCollisionGroup instance that defines what the wheel/suspension scene queries should treat as a ground surface to collide against. If not specified, no specific filtering will be applied."
    )
    bool physxVehicleWheelAttachment:driven (
        displayName = "Driven"
        doc = """Deprecated. Please use PhysxVehicleMultiWheelDifferentialAPI instead.
        
                 True if the tire is driven by the engine through the transmission. Will be ignored if the vehicle
                 has no drive specified (see PhysxVehicleAPI:drive) or if PhysxVehicleMultiWheelDifferentialAPI
                 is used instead."""
    )
    int physxVehicleWheelAttachment:index = -1 (
        displayName = "Index"
        doc = """The index of the wheel attachment. Some other components will reference the wheel attachments
              based on this index. Either all indices of a vehicle's wheel attachments need to be -1 or they
              need to cover all entries in the group {0, .., (numberOfWheels-1)}. All indices being -1 covers 
              the case where wheels are controlled directly through PhysxVehicleWheelControllerAPI, for example,
              or when deprecated APIs are used still."""
    )
    rel physxVehicleWheelAttachment:suspension (
        displayName = "Suspension"
        doc = """A relationship to a PhysxVehicleSuspensionAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleSuspensionAPI
                    applied (none or both of the two is invalid)."""
    )
    float3 physxVehicleWheelAttachment:suspensionForceAppPointOffset (
        displayName = "Suspension Force Application Point Offset"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The location where the suspension force gets applied. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    quatf physxVehicleWheelAttachment:suspensionFrameOrientation = (1, 0, 0, 0) (
        displayName = "Suspension Frame Orientation"
        doc = """The orientation of the suspension frame. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the orientation is specified. If set to true, the orientation is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer. Camber, steer and toe angles are all applied in the suspension
              frame. The vehicle frame transform of the wheel will be defined by: centerOfMassFrame * 
              suspensionFrame * wheelFrame (if physxVehicle:referenceFrameIsCenterOfMass is true,
              else centerOfMassFrame has to be omitted)."""
    )
    point3f physxVehicleWheelAttachment:suspensionFramePosition (
        displayName = "Suspension Frame Position"
        doc = """The point of the suspension at max compression. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the position is specified. If set to true, the position is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer. Camber, steer and toe angles are all applied in the suspension
              frame. The vehicle frame transform of the wheel will be defined by: centerOfMassFrame * 
              suspensionFrame * wheelFrame (if physxVehicle:referenceFrameIsCenterOfMass is true,
              else centerOfMassFrame has to be omitted).
              
              Note: either this attribute or the deprecated wheelCenterOfMassOffset have to
              to be specified (with the former taking precedence)."""
    )
    vector3f physxVehicleWheelAttachment:suspensionTravelDirection (
        displayName = "Suspension Travel Direction"
        doc = """The direction of the suspension travel (towards the wheel). The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the direction is specified. If set to true, the direction is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: this attribute has to be specified (there is no default)."""
    )
    rel physxVehicleWheelAttachment:tire (
        displayName = "Tire"
        doc = """A relationship to a PhysxVehicleTireAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleTireAPI
                    applied (none or both of the two is invalid)."""
    )
    float3 physxVehicleWheelAttachment:tireForceAppPointOffset (
        displayName = "Tire Force Application Point Offset"
        doc = """Deprecated. Please use PhysxVehicleSuspensionComplianceAPI instead.
        
              The location where the tire force gets applied. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if PhysxVehicleSuspensionComplianceAPI is used."""
    )
    rel physxVehicleWheelAttachment:wheel (
        displayName = "Wheel"
        doc = """A relationship to a PhysxVehicleWheelAPI prim.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleWheelAPI
                    applied (none or both of the two is invalid)."""
    )
    float3 physxVehicleWheelAttachment:wheelCenterOfMassOffset (
        displayName = "Wheel Center of Mass Offset"
        doc = """Deprecated. Please use suspensionFramePosition instead.
              
              The location of the wheel centre when at rest. The custom metadata
              physxVehicle:referenceFrameIsCenterOfMass (on the vehicle prim) defines in what frame
              the offset is specified. If set to true, the offset is assumed to be relative
              to the vehicle center of mass frame, else relative to the frame of the vehicle prim.
              Note that using the center of mass frame as reference is deprecated and will not be
              supported for much longer.
        
              Note: will be ignored if suspensionFramePosition is authored."""
    )
    quatf physxVehicleWheelAttachment:wheelFrameOrientation = (1, 0, 0, 0) (
        displayName = "Wheel Frame Orientation"
        doc = """An orientation adjustment of the wheel relative to the suspension frame.
              The rotation angle around the wheel's lateral axis is applied in this frame."""
    )
    point3f physxVehicleWheelAttachment:wheelFramePosition = (0, 0, 0) (
        displayName = "Wheel Frame Position"
        doc = """A position offset of the wheel center relative to the suspension frame.
              Non-zero values might be used, for example, if the steer axis should not go
              through the wheel center."""
    )
}

class "PhysxVehicleSuspensionComplianceAPI" (
    doc = """Compliance describes how toe and camber angle and force application points are 
          affected by suspension compression. Each compliance term is in the form of a graph
          with up to 3 points. The points in the graph consist of a normalized jounce value
          (with 0 meaning fully elongated and 1 fully compressed suspension) and a corresponding
          compliance value (which can be an angle or point etc. depending on the specific
          compliance term). The sequence of points must respresent monotonically increasing
          values of normalized jounce. The actual compliance value will be computed by linear
          interpolation based on the current normalized jounce. If any graph has zero points
          in it, a value of 0.0 is used for the compliance value. If any graph has 1 point
          in it, the compliance value of that point is used directly. This API schema has to
          be applied to a prim with PhysxVehicleWheelAttachmentAPI applied. If defined, then
          this setup takes precedence over the deprecated attributes suspensionForceAppPointOffset
          and tireForceAppPointOffset of the PhysxVehicleWheelAttachmentAPI API schema, the
          deprecated attributes camberAtRest, camberAtMaxCompression, camberAtMaxDroop of the
          PhysxVehicleSuspensionAPI API schema as well as the deprecated attribute toeAngle
          of the PhysxVehicleWheelAPI API schema."""
)
{
    float4[] physxVehicleSuspensionCompliance:suspensionForceAppPoint (
        displayName = "Suspension Force Application Point"
        doc = """Suspension forces are applied at an offset from the suspension frame (see 
              PhysxVehicleWheelAttachmentAPI). An entry in this array defines this offset for a
              given normalized jounce value (which is the first element in the float4 while
              the other 3 elements are used to store the x, y, z coordinates of the offset).
              See the class documentation for general info about the nature of these compliance
              terms and the data requirements."""
    )
    float4[] physxVehicleSuspensionCompliance:tireForceAppPoint (
        displayName = "Tire Force Application Point"
        doc = """Tire forces are applied at an offset from the suspension frame (see 
              PhysxVehicleWheelAttachmentAPI). An entry in this array defines this offset for a
              given normalized jounce value (which is the first element in the float4 while
              the other 3 elements are used to store the x, y, z coordinates of the offset).
              See the class documentation for general info about the nature of these compliance
              terms and the data requirements."""
    )
    float2[] physxVehicleSuspensionCompliance:wheelCamberAngle (
        displayName = "Wheel Camber Angle"
        doc = """A graph of camber angle against normalized jounce with the camber angle expressed
              in radians in the range [-pi, pi]. See the class documentation for general info
              about the nature of these graphs and the data requirements.
              
              Note: the camber angle is applied in the suspension frame (see PhysxVehicleWheelAttachmentAPI)."""
    )
    float2[] physxVehicleSuspensionCompliance:wheelToeAngle (
        displayName = "Wheel Toe Angle"
        doc = """A graph of toe angle against normalized jounce with the toe angle expressed
              in radians in the range [-pi, pi]. See the class documentation for general info
              about the nature of these graphs and the data requirements.
              
              Note: the toe angle is applied in the suspension frame (see PhysxVehicleWheelAttachmentAPI)."""
    )
}

class "PhysxVehicleEngineAPI" (
    doc = """Properties of a PhysX vehicle engine. If the engine setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the engine setup, PhysxVehicleEngineAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
)
{
    float physxVehicleEngine:dampingRateFullThrottle = -1 (
        displayName = "Damping Rate at Full Throttle"
        doc = """Damping rate of engine when full throttle is applied (units: 
                 torque * seconds = mass * distance * distance / seconds). The value has to be greater
                 or equal 0.
                 
                 Note: if the clutch is engaged (any gear except neutral) then the damping rate applied 
                 at run-time is an interpolation between dampingRateZeroThrottleClutchEngaged (see 
                 corresponding attribute) and dampingRateFullThrottle:
                 dampingRateZeroThrottleClutchEngaged + 
                 ((dampingRateFullThrottle-dampingRateZeroThrottleClutchEngaged) * acceleratorPedal).
                 
                 Note: if the clutch is disengaged (in neutral gear) the damping rate applied at run-time
                 is an interpolation between dampingRateZeroThrottleClutchDisengaged (see corresponding 
                 attribute) and dampingRateFullThrottle:
                 dampingRateZeroThrottleClutchDisengaged +
                 ((dampingRateFullThrottle-dampingRateZeroThrottleClutchDisengaged) * acceleratorPedal).
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 0.15
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
    float physxVehicleEngine:dampingRateZeroThrottleClutchDisengaged = -1 (
        displayName = "Damping Rate at Zero Throttle with Clutch Disengaged"
        doc = '''Damping rate of engine when no throttle is applied and the clutch is disengaged (units: 
                 torque * seconds = mass * distance * distance / seconds). See attribute "dampingRateFullThrottle"
                 for information about the effect of the value. The value has to be greater or equal 0.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 0.35
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used).'''
    )
    float physxVehicleEngine:dampingRateZeroThrottleClutchEngaged = -1 (
        displayName = "Damping Rate at Zero Throttle with Clutch Engaged"
        doc = '''Damping rate of engine when no throttle is applied and the clutch is engaged (units: 
                 torque * seconds = mass * distance * distance / seconds). See attribute "dampingRateFullThrottle"
                 for information about the effect of the value. The value has to be greater or equal 0.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 2.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used).'''
    )
    float physxVehicleEngine:idleRotationSpeed = 0 (
        displayName = "Idle Rotation Speed"
        doc = "Rotation speed of the engine when idling (units: radians / seconds). The value has to be greater or equal 0."
    )
    float physxVehicleEngine:maxRotationSpeed = 600 (
        displayName = "Max Rotation Speed"
        doc = """Maximum rotation speed of the engine (units: radians / seconds). The value has to be greater
                 or equal 0."""
    )
    float physxVehicleEngine:moi (
        displayName = "Moment of Inertia"
        doc = """The moment of inertia of the engine around the axis of rotation (units: 
                 mass * distance * distance). The value has to be positive.
        
                 Note: if not defined, the value 1.0 will be used. This default value is in meter length scale 
                 and kilograms and will get adjusted if other units are used."""
    )
    float physxVehicleEngine:peakTorque = -1 (
        displayName = "Peak Torque"
        doc = """Maximum torque available to apply to the engine when the accelerator pedal is at maximum
                 (units: mass * distance * distance / seconds / seconds). The value has to be greater or
                 equal 0.
                 
                 Note: the torque available is the value of the accelerator pedal (in range [0, 1]) multiplied
                 by the normalized torque as computed from torqueCurve (see corresponding attribute)
                 multiplied by peakTorque.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 500.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used)."""
    )
    float2[] physxVehicleEngine:torqueCurve (
        displayName = "Torque Curve"
        doc = """Graph of normalized torque (torque / peakTorque) against normalized engine speed (engineRotationSpeed / maxRotationSpeed).
                 
                 Note: the normalized engine speed is the x-axis of the graph, while the normalized torque is the y-axis of the graph.
                 No more than 8 data points are supported.
                 
                 Note: if not defined, the following values will be used: [(0.0, 0.8), (0.33, 1.0), (1.0, 0.8)]."""
    )
}

class "PhysxVehicleGearsAPI" (
    doc = """Properties of PhysX vehicle gears. If the gears setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the gears setup, PhysxVehicleGearsAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
)
{
    float[] physxVehicleGears:ratios (
        displayName = "Ratios"
        doc = """The gear ratios. First entry is for reverse, then there is support for up to 30 gears
                 (neutral has a fixed value of 0 and is not represented in this array). The value for
                 reverse has to be negative, else a positive value is expected and the ratios have to
                 form a descending sequence.
                 
                 Note: if not defined, the following values will be used: [-4.0, 4.0, 2.0, 1.5, 1.1, 1.0]."""
    )
    float physxVehicleGears:ratioScale (
        displayName = "Ratio Scale"
        doc = """Multiplier for gear ratio values. Final gear ratio is computed as ratios[currentGear] * ratioScale.
                 The value has to be positive.
                 
                 Note: if not defined, the value 4.0 will be used."""
    )
    float physxVehicleGears:switchTime (
        displayName = "Switch Time"
        doc = """Time it takes to switch gear (units: seconds).
        
                 Note: if not defined, the value 0.5 will be used."""
    )
}

class "PhysxVehicleAutoGearBoxAPI" (
    doc = """Properties of the PhysX vehicle automatic gear shift box. If the automatic gear shift box setup
             does not need to be shared among vehicle instances, it can be applied to the prim which has 
             PhysxVehicleDriveStandardAPI applied. If the intent is to share the automatic gear shift box
             setup, PhysxVehicleAutoGearBoxAPI can be applied to a separate prim which can be linked to 
             (see PhysxVehicleDriveStandardAPI)."""
)
{
    float[] physxVehicleAutoGearBox:downRatios (
        displayName = "Down Ratios"
        doc = """Value of normalized engine speed (engineRotationSpeed / maxRotationSpeed) that is low
                 enough to decrement gear. The first entry is for second gear then up to the highest gear.
                 When (engineRotationSpeed / maxRotationSpeed) < downRatios[currentGear] the autobox will
                 begin a transition to currentGear-1 unless currentGear is first gear or neutral or reverse.
                 
                 Note: if not defined, the following values will be used: [0.5, 0.5, 0.5, 0.5]."""
    )
    float physxVehicleAutoGearBox:latency (
        displayName = "Latency"
        doc = """The latency time of the automatic gear shift box (units: seconds). This is the minimum
                 time that must pass between each gear change that is initiated by the automatic gear shift
                 box.
                 
                 Note: if not defined, the value 2.0 will be used."""
    )
    float[] physxVehicleAutoGearBox:upRatios (
        displayName = "Up Ratios"
        doc = """Value of normalized engine speed (engineRotationSpeed / maxRotationSpeed) that is high
                 enough to increment gear. The first entry is for first gear and then up to the
                 second highest gear. When (engineRotationSpeed / maxRotationSpeed) > upRatios[currentGear]
                 the autobox will begin a transition to currentGear+1 unless currentGear is the highest
                 possible gear or neutral or reverse.
                 
                 Note: if not defined, the following values will be used: [0.65, 0.65, 0.65, 0.65]."""
    )
}

class "PhysxVehicleClutchAPI" (
    doc = """Properties of the PhysX vehicle clutch. If the clutch setup does not need to be shared among vehicle
             instances, it can be applied to the prim which has PhysxVehicleDriveStandardAPI applied.
             If the intent is to share the clutch setup, PhysxVehicleClutchAPI can be applied to a separate
             prim which can be linked to (see PhysxVehicleDriveStandardAPI)."""
)
{
    float physxVehicleClutch:strength (
        displayName = "Strength"
        doc = """Strength of clutch (units: torque * seconds = mass * distance * distance / seconds).
              The value has to be positive.
              The clutch is the mechanism that couples the engine to the wheels. A stronger clutch more
              strongly couples the engine to the wheels, while a clutch of strength zero completely
              decouples the engine from the wheels. Stronger clutches more quickly bring the wheels and
              engine into equilibrium, while weaker clutches take longer, resulting in periods of clutch
              slip and delays in power transmission from the engine to the wheels. The torque generated
              by the clutch is proportional to the clutch strength and the velocity difference between
              the engine's rotational speed and the rotational speed of the driven wheels after accounting
              for the gear ratio. The torque at the clutch is applied negatively to the engine and
              positively to the driven wheels.
              
              Note: if not defined, the value 10.0 will be used. This default value is in meter length scale 
              and kilograms and will get adjusted if other units are used."""
    )
}

class "PhysxVehicleDriveBasicAPI" (
    doc = '''Very simple drive model for a PhysX vehicle. A torque will be directly applied to the wheels
             that are marked as driven (see PhysxVehicleMultiWheelDifferentialAPI or deprecated attribute
             "driven" in PhysxVehicleWheelAttachmentAPI).
             
             If the drive setup does not need to be shared among vehicle instances, it can be applied to the
             prim which has PhysxVehicleAPI applied. If the intent is to share the drive setup, PhysxVehicleDriveBasicAPI
             can be applied to a separate prim which can be linked to (see PhysxVehicleAPI).'''
)
{
    float physxVehicleDriveBasic:peakTorque = -1 (
        displayName = "Peak Torque"
        doc = '''Maximum torque to generate when the accelerator pedal is at maximum
                 (units: mass * distance * distance / seconds / seconds). The value has to be greater or equal 0.
                 
                 Note: PhysxVehicleMultiWheelDifferentialAPI can be used to specify which wheels are connected
                 to the drive as well as how the torque should be distributed among those wheels. If the
                 deprecated attribute "driven" of PhysxVehicleWheelAttachmentAPI is used, then each driven
                 wheel can experience a torque up to the value defined in this attribute.
                 
                 Note: the applied torque is the value of the accelerator pedal (in range [0, 1]) multiplied
                 by peakTorque.
                 
                 Note: the default value -1 is not a valid value as such but will result in the value 1000.0
                 being used (in meter length scale and kilogram mass scale or the equivalent if other units
                 are used).'''
    )
}

class "PhysxVehicleDriveStandardAPI" (
    doc = '''Standard drive model for a PhysX vehicle. The available drive torque will be split equally
             between all the wheels that are marked as driven (see PhysxVehicleMultiWheelDifferentialAPI
             or deprecated attribute "driven" in PhysxVehicleWheelAttachmentAPI) unless the torque
             distributon is configured explicitly (see PhysxVehicleMultiWheelDifferentialAPI for details).
             
             If the drive setup does not need to be shared among vehicle instances, it can be applied to the
             prim which has PhysxVehicleAPI applied. If the intent is to share the drive setup, PhysxVehicleDriveStandardAPI
             can be applied to a separate prim which can be linked to (see PhysxVehicleAPI).'''
)
{
    rel physxVehicleDriveStandard:autoGearBox (
        displayName = "Auto Gear Box"
        doc = """A relationship to a PhysxVehicleAutoGearBoxAPI prim that describes the automatic gear shift box.
                 This relationship is optional and should be omitted if no automatic gear shift is desired. It is
                 also possible to apply PhysxVehicleAutoGearBoxAPI to the prim directly. In that case the relationship
                 must not be defined."""
    )
    rel physxVehicleDriveStandard:clutch (
        displayName = "Clutch"
        doc = """A relationship to a PhysxVehicleClutchAPI prim that describes the clutch.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleClutchAPI
                    applied (none or both of the two is invalid)."""
    )
    rel physxVehicleDriveStandard:engine (
        displayName = "Engine"
        doc = """A relationship to a PhysxVehicleEngineAPI prim that describes the engine.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleEngineAPI
                    applied (none or both of the two is invalid)."""
    )
    rel physxVehicleDriveStandard:gears (
        displayName = "Gears"
        doc = """A relationship to a PhysxVehicleGearsAPI prim that describes the gears.
        
              Note: either this relationship has to be specified or the prim must have PhysxVehicleGearsAPI
                    applied (none or both of the two is invalid)."""
    )
}

class "PhysxVehicleMultiWheelDifferentialAPI" (
    doc = """Describes which wheels of a vehicle are driven as well as the distribution of the
          drive torque among those wheels. Has to be applied to a prim with PhysxVehicleAPI applied.
          Can only be used for vehicles that have a drive (see PhysxVehicleDriveBasicAPI or
          PhysxVehicleDriveStandardAPI)."""
)
{
    float[] physxVehicleMultiWheelDifferential:averageWheelSpeedRatios (
        displayName = "Average Wheel Speed Ratios"
        doc = '''Defines how the speeds of the driven wheels get weighted when computing the average wheel
              speed at the clutch (for computing clutch slip). The provided ratios must be in range [0, 1]
              and under normal circumstances sum up to 1. If the attribute is defined, then the length of 
              the array needs to match the length of the "wheels" array. If the attribute is not defined, 
              the wheel speeds of all driven wheels will get weighted equally.
              
              Note: if a vehicle is using a PhysxVehicleDriveBasicAPI drive, then this attribute should not
                    be used.'''
    )
    float[] physxVehicleMultiWheelDifferential:torqueRatios (
        displayName = "Torque Ratios"
        doc = '''Defines how the drive torque should get distributed among the wheels specified in the "wheels"
              attribute. The provided ratios must be in range [-1, 1] and under normal circumstances the absolute
              values should sum up to 1. If the attribute is defined, then the length of the array needs to match
              the length of the "wheels" array. If the attribute is not defined, the torque will get split equally
              among all driven wheels.'''
    )
    int[] physxVehicleMultiWheelDifferential:wheels (
        displayName = "Wheels"
        doc = '''List of indices, referencing the wheels that are driven (receiving torque from the engine). The
              indices refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI.'''
    )
}

class "PhysxVehicleTankDifferentialAPI" (
    apiSchemas = ["PhysxVehicleMultiWheelDifferentialAPI"]
    doc = """Differential to set up a wheeled tank vehicle. Describes which wheels of a vehicle are part of
          the tank tracks. The wheels in each tank track have a constraint applied to them to enforce the
          rule that they all have the same longitudinal speed at the contact point between the wheel and the
          tank track. Driven wheels that are not part of a tank track receive the torque split specified in
          physxVehicleMultiWheelDifferential:torqueRatios. Has to be applied to a prim with PhysxVehicleAPI
          applied. Can only be used for vehicles that have a standard drive (see PhysxVehicleDriveStandardAPI)."""
)
{
    int[] physxVehicleTankDifferential:numberOfWheelsPerTrack (
        displayName = "Number Of Wheels Per Track"
        doc = "For each track, this array holds the number of wheels assigned to that track."
    )
    int[] physxVehicleTankDifferential:thrustIndexPerTrack (
        displayName = "Thrust Index Per Track"
        doc = '''For each track, this array holds the index of the thrust control (0 or 1, see PhysxVehicleTankControllerAPI)
              that drives the track. The length of the array needs to match the length of the 
              "numberOfWheelsPerTrack" array.'''
    )
    int[] physxVehicleTankDifferential:trackToWheelIndices (
        displayName = "Track To Wheel Indices"
        doc = '''For each track, this array holds the start index of the list describing the wheels that
              are assigned to that track (e.g., the list of wheel indices assigned to the track with index
              2 starts at: wheelIndicesInTrackOrder[trackToWheelIndices[2]]). The length of the array needs
              to match the length of the "numberOfWheelsPerTrack" array.'''
    )
    int[] physxVehicleTankDifferential:wheelIndicesInTrackOrder (
        displayName = "Wheel Indices In Track Order"
        doc = '''The wheels (identified by wheel attachment indices, see attribtue "index" of 
              PhysxVehicleWheelAttachmentAPI) assigned to track 0, followed by the wheels assigned to
              track 1 and so on. The length of the array is expected to be equal (or larger than) the number
              of wheels that are assigned to tracks.'''
    )
}

class "PhysxVehicleBrakesAPI" (
    doc = '''Describes a braking system for a vehicle by specifying which wheels are connected to the
          brake control and by defining the brake torque that gets applied to those wheels. Currently,
          up to two braking systems are supported. Use the instance name TfToken "brakes0" and "brakes1"
          of this multipleApply schema to distinguish between the two braking systems. Note that system
          "brakes0" will be coupled to the brake control brake0 while system "brakes1" will be coupled
          to the brake control brake1 (see PhysxVehicleControllerAPI for the brake controls). An example
          for using two systems is to provide brake and handbrake control (the former applying brake
          torque to all wheels and the latter applying brake torque to the rear wheels only). This API
          schema has to be applied to a prim with PhysxVehicleAPI applied. Can only be used for vehicles
          that have a drive (see PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI).'''
)
{
    float physxVehicleBrakes:__INSTANCE_NAME__:maxBrakeTorque = 0 (
        displayName = "Max Brake Torque"
        doc = '''The maximum brake torque that can be generated by the braking system
              (units: mass * distance * distance / seconds / seconds). Has to be greater or equal
              zero. For braking system "brakes0", the brake torque applied to wheels[i] will be
              defined by maxBrakeTorque * torqueMultipliers[i] * physxVehicleController:brake0
              (see PhysxVehicleControllerAPI).'''
    )
    float[] physxVehicleBrakes:__INSTANCE_NAME__:torqueMultipliers (
        displayName = "Torque Multipliers"
        doc = '''Defines how much of the max brake torque can be delivered to the wheels that are
              connected to the braking system. The values are unitless multipliers and have to be
              greater or equal to zero. See maxBrakeTorque for how these multipliers affect the
              brake torque applied to a wheel. If the attribute is defined, then the length of the
              array needs to match the length of the "wheels" array. If the attribute is not defined,
              a multiplier value of 1 will be used for all connected wheels.'''
    )
    int[] physxVehicleBrakes:__INSTANCE_NAME__:wheels (
        displayName = "Wheels"
        doc = '''List of indices, referencing the wheels that receive brake torque. The indices
              refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI. If not specified,
              each wheel will receive a brake torque using a torque multiplier of 1 (see attribute
              torqueMultipliers).'''
    )
}

class "PhysxVehicleSteeringAPI" (
    doc = """Describes a steering system for a vehicle by specifying which wheels are connected to the
          steer control and by defining the maximum steer angle for those wheels (see PhysxVehicleControllerAPI
          for the steer control). This API schema has to be applied to a prim with PhysxVehicleAPI applied.
          Can only be used for vehicles that have a drive (see PhysxVehicleDriveBasicAPI or
          PhysxVehicleDriveStandardAPI)."""
)
{
    float[] physxVehicleSteering:angleMultipliers (
        displayName = "Angle Multipliers"
        doc = '''Allows to adjust the max steer angle for each wheel that is steered. The values are
              unitless multipliers. See maxSteerAngle for how these multipliers affect the steer
              angle of a wheel. If the attribute is defined, then the length of the array needs
              to match the length of the "wheels" array. If the attribute is not defined,
              a multiplier value of 1 will be used for all steered wheels.'''
    )
    float physxVehicleSteering:maxSteerAngle = 0 (
        displayName = "Max Steer Angle"
        doc = """The maximum steer angle (in radians) that can be achieved by the wheels.
              Has to be in range [-pi, pi] when multiplied by the attribute angleMultipliers.
              The steer angle of wheels[i] will be defined by maxSteerAngle * angleMultipliers[i] * 
              physxVehicleController:steer (see PhysxVehicleControllerAPI)."""
    )
    int[] physxVehicleSteering:wheels (
        displayName = "Wheels"
        doc = '''List of indices, referencing the wheels that are going to be steered. The indices
              refer to the attribute "index" of PhysxVehicleWheelAttachmentAPI. If not specified,
              every wheel will be affected by the steer control using an angle multiplier of 1
              (see attribute angleMultipliers).'''
    )
}

class "PhysxVehicleAckermannSteeringAPI" (
    doc = """Describes a steering system with Ackermann correction for two wheels. This system will
          result in asymmetric steer angles such that the line defined by the non-steered wheel axle
          and the lateral lines of the steered wheels meet at the same point. As a consequence, when
          following the path around a curve, the inner wheel will turn more than the outer one. This
          avoids that some wheels need to slip sideways to stay on the path. The specified wheels
          will be connected to the steer control (see PhysxVehicleControllerAPI). This API schema
          has to be applied to a prim with PhysxVehicleAPI applied. Can only be used for vehicles that
          have a drive (see PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI). This API
          schema can not be combined with PhysxVehicleSteeringAPI, only one or the other is allowed."""
)
{
    float physxVehicleAckermannSteering:maxSteerAngle = 0 (
        displayName = "Max Steer Angle"
        doc = """The maximum steer angle (in radians) that can be achieved by the wheels.
              Has to be in range [-pi, pi]. The steer angle of wheel0 will be defined by 
              maxSteerAngle * ackermann_correction(0) * physxVehicleController:steer (see PhysxVehicleControllerAPI)."""
    )
    float physxVehicleAckermannSteering:strength = 1 (
        displayName = "Strength"
        doc = """The strength of the Ackermann correction with 0 denoting no correction and
              1 denoting perfect correction. The value has to be in range [0, 1]."""
    )
    float physxVehicleAckermannSteering:trackWidth (
        displayName = "Track Width"
        doc = """The width of the axle defined by wheel0 and wheel1 (units: distance).
              The value has to be greater than zero.
              
              Note: this attribute has to be specified (there is no default)."""
    )
    int physxVehicleAckermannSteering:wheel0 (
        displayName = "Wheel 0"
        doc = '''The index of the wheel that is negative along the lateral axis and should get
              connected to the steering system. The index refers to the attribute "index" of
              PhysxVehicleWheelAttachmentAPI.
              
              Note: this attribute has to be specified (there is no default).'''
    )
    int physxVehicleAckermannSteering:wheel1 (
        displayName = "Wheel 1"
        doc = '''The index of the wheel that is positive along the lateral axis and should get
              connected to the steering system. The index refers to the attribute "index" of
              PhysxVehicleWheelAttachmentAPI.
              
              Note: this attribute has to be specified (there is no default).'''
    )
    float physxVehicleAckermannSteering:wheelBase (
        displayName = "Wheel Base"
        doc = """The longitudinal distance between the axle that is affected by Ackermann
              correction and a reference axle (units: distance). The value has to be greater
              than zero.
              
              Note: this attribute has to be specified (there is no default)."""
    )
}

class "PhysxVehicleAPI" (
    doc = '''PhysX vehicle. Has to be applied to a prim with PhysicsRigidBodyAPI applied. Wheels can be added by applying PhysxVehicleWheelAttachmentAPI to a prim that is a descendant of the "vehicle" prim.
    
          Note: if the prim has PhysxRigidBodyAPI applied, it should be configured such that disableGravity is set to true since the vehicle simulation will take gravity into account already.'''
)
{
    rel physxVehicle:drive (
        displayName = "Drive"
        doc = """A relationship to a PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI prim that describes the 
                 drive model. If none is specified, it is up to the user to apply torque to the wheels. It is also
                 possible to apply PhysxVehicleDriveBasicAPI or PhysxVehicleDriveStandardAPI to the prim directly. In 
                 that case the relationship must not be defined."""
    )
    int physxVehicle:highForwardSpeedSubStepCount (
        displayName = "High Forward Speed Sub-step Count"
        doc = """Number of sub-steps performed in the vehicle dynamics update for vehicles that have
              longitudinal speed greater than subStepThresholdLongitudinalSpeed.
              
              Note: if not defined, the value 1 will be used."""
    )
    float physxVehicle:lateralStickyTireDamping = 20 (
        displayName = "Lateral Sticky Tire Damping"
        doc = """The lateral sticky tire damping (per seconds). See documentation about
              longitudinalStickyTireDamping as it is the same concept.
              
              Note: larger values of damping lead to faster approaches to zero. Since the damping behaves
                    like a stiffness with respect to the velocity, too large a value can lead to instabilities."""
    )
    float physxVehicle:lateralStickyTireThresholdSpeed = -1 (
        displayName = "Lateral Sticky Tire Threshold Speed"
        doc = '''The lateral sticky tire threshold speed (units: distance / seconds). See documentation about
              longitudinalStickyTireThresholdSpeed as it is the same concept. Note that the lateral part
              can only enter the "sticky tire" regime if the longitudinal speed is below longitudinalStickyTireThresholdSpeed.
              
              Note: the default value -1 is not a valid value as such but will result in the value 0.2 being
              used (in meter length scale or the equivalent if another unit is used).'''
    )
    float physxVehicle:lateralStickyTireThresholdTime = 1 (
        displayName = "Lateral Sticky Tire Threshold Time"
        doc = """The lateral sticky tire threshold time (in seconds). See documentation about
              longitudinalStickyTireThresholdTime as it is the same concept."""
    )
    bool physxVehicle:limitSuspensionExpansionVelocity = 0 (
        displayName = "Limit Suspension Expansion Velocity"
        doc = """Limit the suspension expansion dynamics.
              
              When a hit with the ground is detected, the suspension jounce will be set such that the wheel
\t          is placed on the ground. This can result in large changes to jounce within a single simulation
              frame, if the ground surface has high frequency or if the simulation time step is large. As a
              result, large damping forces can evolve and cause undesired behavior. If this parameter is set
              to true, the suspension expansion speed will be limited to what can be achieved given the time
              step, suspension stiffness etc. As a consequence, handling of the vehicle will be affected as
              the wheel might loose contact with the ground more easily.
              
              Note: this will apply to the suspensions of all wheels."""
    )
    float physxVehicle:longitudinalStickyTireDamping = 200 (
        displayName = "Longitudinal Sticky Tire Damping"
        doc = '''The longitudinal sticky tire damping (per seconds). Has to be greater or equal 0.
              Describes the rate at which the velocity constraint approaches zero when entering the "sticky tire"
              regime. More details on the "sticky tire" regime can be found in the documentation of the
              longitudinalStickyTireThresholdSpeed attribute.
              
              Note: larger values of damping lead to faster approaches to zero. Since the damping behaves
                    like a stiffness with respect to the velocity, too large a value can lead to instabilities.'''
    )
    float physxVehicle:longitudinalStickyTireThresholdSpeed = -1 (
        displayName = "Longitudinal Sticky Tire Threshold Speed"
        doc = '''The longitudinal sticky tire threshold speed (units: distance / seconds). Has to be greater 
              or equal 0. A tire enters the "sticky tire" regime when its longitudinal speed has been below
              this threshold for a continuous time specified by longitudinalStickyTireThresholdTime. At low
              speeds with no significant brake or drive torque, numerical error begins to dominate and it
              can be difficult to bring the vehicle to rest. A solution to this problem is to recognise that
              the vehicle is close to rest and to replace the tire forces with velocity constraints that will
              bring the vehicle to rest. For the purpose of this documentation, this regime is referred to as
              the "sticky tire" regime.
              
              Note: the default value -1 is not a valid value as such but will result in the value 0.2 being
              used (in meter length scale or the equivalent if another unit is used).'''
    )
    float physxVehicle:longitudinalStickyTireThresholdTime = 1 (
        displayName = "Longitudinal Sticky Tire Threshold Time"
        doc = '''The longitudinal sticky tire threshold time (in seconds). Has to be greater or equal 0.
              A tire enters the "sticky tire" regime when it has been below the speed specified by
              longitudinalStickyTireThresholdSpeed for this continuous time. More details on the
              "sticky tire" regime can be found in the documentation of the longitudinalStickyTireThresholdSpeed
              attribute.'''
    )
    int physxVehicle:lowForwardSpeedSubStepCount (
        displayName = "Low Forward Speed Sub-step Count"
        doc = """Number of sub-steps performed in the vehicle dynamics update for vehicles that have
              longitudinal speed lower than subStepThresholdLongitudinalSpeed.
              
              Note: if not defined, the value 3 will be used."""
    )
    float physxVehicle:minActiveLongitudinalSlipDenominator = 0 (
        displayName = "Min Active Longitudinal Slip Denominator"
        doc = """The minimum denominator used in the longitudinal slip calculation when a wheel experiences
              drive or brake torque (units: distance / seconds). For low longitudinal velocities, the
              computation of the longitudinal slip can become unstable. This value defines the minimum velocity
              to use when computing the longitudinal slip. The value has to be positive.
              
              Note: the default value 0 is not a valid value as such but will result in the value 0.1 being
              used (in meter length scale or the equivalent if another unit is used).
              
              Note: it is recommended to have minActiveLongitudinalSlipDenominator < minPassiveLongitudinalSlipDenominator."""
    )
    float physxVehicle:minLateralSlipDenominator = 0 (
        displayName = "Min Lateral Slip Denominator"
        doc = """The minimum denominator used in the lateral slip calculation (units: distance / seconds).
              For low longitudinal velocities, the computation of the lateral slip can become unstable.
              This value defines the minimum longitudinal velocity to use when computing the lateral slip.
              The value has to be positive.
              
              Note: the default value 0 is not a valid value as such but will result in the value 1.0 being
              used (in meter length scale or the equivalent if another unit is used).
              
              Note: larger simulation timesteps typically require larger values of minLateralSlipDenominator."""
    )
    float physxVehicle:minLongitudinalSlipDenominator (
        displayName = "Min Longitudinal Slip Denominator"
        doc = """Deprecated. Please use minPassiveLongitudinalSlipDenominator instead.
              
              The minimum denominator used in the longitudinal slip calculation (units: distance / seconds).
              For low longitudinal velocities, the computation of the longitudinal slip can become 
              unstable. This value defines the minimum velocity to use when computing the longitudinal slip.
              
              Note: will be ignored if minPassiveLongitudinalSlipDenominator is used.
              
              Note: if not defined, the value 4.0 will be used. This default value is in meter length scale 
              and will get adjusted if another unit is used."""
    )
    float physxVehicle:minPassiveLongitudinalSlipDenominator = 0 (
        displayName = "Min Passive Longitudinal Slip Denominator"
        doc = """The minimum denominator used in the longitudinal slip calculation when a wheel experiences no
              drive and no brake torque (units: distance / seconds). For low longitudinal velocities, the
              computation of the longitudinal slip can become unstable. This value defines the minimum velocity
              to use when computing the longitudinal slip. The value has to be positive.
              
              Note: the default value 0 is not a valid value as such but indicates that the deprecated
              attribute minLongitudinalSlipDenominator should be used instead.
              
              Note: it is recommended to have minActiveLongitudinalSlipDenominator < minPassiveLongitudinalSlipDenominator."""
    )
    float physxVehicle:subStepThresholdLongitudinalSpeed (
        displayName = "Sub-step Threshold Longitudinal Speed"
        doc = """Threshold speed that is used to categorize vehicle speed as low speed or high speed for
              choosing the sub-step count (units: distance / seconds).
              
              Note: if not defined, the value 5.0 will be used. This default value is in meter length scale 
              and will get adjusted if another unit is used."""
    )
    uniform token physxVehicle:suspensionLineQueryType = "raycast" (
        allowedTokens = ["raycast", "sweep"]
        displayName = "Suspension Line Query Type"
        doc = """Collision of the wheels with the ground surface is detected through scene queries along the suspension direction. 
              This attribute defines whether a raycast or a sweep should be used as the query type. Raycasts are faster while sweeps
              can represent the wheel shape better and thus react earlier to ground surface changes."""
    )
    bool physxVehicle:vehicleEnabled = 1 (
        displayName = "Vehicle Simulation Enabled"
        doc = """Defines whether the vehicle simulation update loop will run for the vehicle or not.
              
              Note: if set to false, the prim's rigid body will still get simulated (the PhysicsRigidBodyAPI API schema
              can be used to turn the body into a kinematic or set velocities to zero at that point).
              
              Note: it is an illegal setup to have a vehicle enabled, while the prim's rigid body is disabled or kinematic."""
    )
}

class "PhysxVehicleControllerAPI" (
    doc = "PhysX vehicle controller that samples user input to drive the vehicle. Has to be applied to a prim with PhysxVehicleAPI applied."
)
{
    float physxVehicleController:accelerator = 0 (
        displayName = "Accelerator"
        doc = "Driven vehicle. Throttle input, 0.0 to 1.0."
    )
    float physxVehicleController:brake = 0 (
        displayName = "Brake"
        doc = """Deprecated. Please use brake0/brake1 instead.
              
              Driven vehicle. Brake input, 0.0 to 1.0."""
    )
    float physxVehicleController:brake0 = 0 (
        displayName = "Brake 0"
        doc = '''Brake control for braking system "brakes0" (see PhysxVehicleBrakesAPI)
                 that triggers the connected brakes and defines the brake strength.
                 Value has to be in range [0.0, 1.0].'''
    )
    float physxVehicleController:brake1 = 0 (
        displayName = "Brake 1"
        doc = '''Brake control for braking system "brakes1" (see PhysxVehicleBrakesAPI)
                 that triggers the connected brakes and defines the brake strength.
                 Value has to be in range [0.0, 1.0].'''
    )
    float physxVehicleController:handbrake = 0 (
        displayName = "Handbrake"
        doc = """Deprecated. Please use brake0/brake1 instead.
              
              Driven vehicle. Handbrake input, 0.0 to 1.0."""
    )
    float physxVehicleController:steer = 0 (
        displayName = "Steer"
        doc = """Steer control for the steering system (see PhysxVehicleSteeringAPI).
                 Defines the extent of the wheels' steer angles with respect to the
                 maximum steer angle. Value has to be in range [-1.0, 1.0]."""
    )
    float physxVehicleController:steerLeft = 0 (
        displayName = "Steer Left"
        doc = """Deprecated. Please use steer instead.
              
              Driven vehicle. Left steering input. 0.0 to 1.0. Net steering is the aggregate of steerRight and steerLeft."""
    )
    float physxVehicleController:steerRight = 0 (
        displayName = "Steer Right"
        doc = """Deprecated. Please use steer instead.
              
              Driven vehicle. Right steering input, 0.0 to 1.0. Net steering is the aggregate of steerRight and steerLeft."""
    )
    int physxVehicleController:targetGear = 255 (
        displayName = "Target Gear"
        doc = """Driven vehicle. Desired gear to shift into. -1 = Reverse, 0 = Neutral, 1 = First etc.
              The special value 255 is used to denote automatic forward gear shifting (similar to <D> in
              automatic transmissions).
              
              Note: if set to automatic gear shifting, the vehicle is expected to have an autobox
                    defined (see PhysxVehicleAutoGearBoxAPI).
        
              Note: please be aware that the target gear definition differs from the PhysX vehicle API."""
    )
}

class "PhysxVehicleTankControllerAPI" (
    apiSchemas = ["PhysxVehicleControllerAPI"]
    doc = '''PhysX vehicle tank controller to divert torque from the engine to the wheels of the tracks
          of a wheel based tank vehicle (see PhysxVehicleTankDifferentialAPI). Note that the "accelerator"
          attribute of PhysxVehicleControllerAPI still drives the engine torque whereas the thrust controls
          introduced here define how that torque gets diverted to the wheels, so both controls need to
          be used to drive a wheel based tank vehicle usually. This API schema has to be applied to a prim
          with PhysxVehicleAPI applied. Can only be used for vehicles that have a standard drive and a
          tank differential defined (see PhysxVehicleDriveStandardAPI, PhysxVehicleTankDifferentialAPI).'''
)
{
    float physxVehicleTankController:thrust0 = 0 (
        displayName = "Thrust 0"
        doc = """Magnitude of thrust to apply to the tracks that are assigned to thrust control 0.
              Values have to be in [-1.0, 1.0] with the sign dictating whether the thrust will be
              applied positively or negatively with respect to the gearing ratio."""
    )
    float physxVehicleTankController:thrust1 = 0 (
        displayName = "Thrust 1"
        doc = """Magnitude of thrust to apply to the tracks that are assigned to thrust control 1.
              Values have to be in [-1.0, 1.0] with the sign dictating whether the thrust will be
              applied positively or negatively with respect to the gearing ratio."""
    )
}

class "PhysxVehicleWheelControllerAPI" (
    doc = "PhysX wheel controller that samples user input and allows direct control of the wheel torques and steer angle to drive the vehicle. Has to be applied to a prim with PhysxVehicleWheelAttachmentAPI applied and be a descendant of a prim with a PhysxVehicleAPI applied."
)
{
    float physxVehicleWheelController:brakeTorque = 0 (
        displayName = "Brake Torque"
        doc = """Torque to decrease wheel angular rate and slow down (units: mass * distance * distance / seconds / seconds).
              The value has to be greater or equal zero."""
    )
    float physxVehicleWheelController:driveTorque = 0 (
        displayName = "Drive Torque"
        doc = "Torque to increase wheel angular rate and speed up (units: mass * distance * distance / seconds / seconds)."
    )
    float physxVehicleWheelController:steerAngle = 0 (
        displayName = "Steer Angle"
        doc = "Steer angle of the wheel in radians."
    )
}

class "PhysxVehicleNonlinearCommandResponseAPI" (
    doc = '''Describes a system of graphs to define nonlinear responses to PhysxVehicleControllerAPI
          command values like accelerator, brake0, brake1 and steer. The normalized response will be
          a function of the command value and the longitudinal vehicle speed. The response will be
          computed by interpolating between the points of the graph and then interpolating those
          results again between the closest graphs. One example usage of nonlinear command response
          is a brake pedal that has an almost flat response when tipped slightly but a very strong
          response from a certain point on. Another example is the steering wheel showing a strong
          response for a large input at low speed but only a weak response at high speed.

          This multipleApply schema can be used to control the response to steering (use instance name
          TfToken "steer") and braking (use instance name TfTokens "brakes0" or "brakes1"). It can
          also control the response to the accelerator but only in combination with the basic drive (use
          instance name TfToken "drive"). Furthermore, this API has to be applied to the appropriate
          prims to take effect: "steer" has to be applied to a prim that has PhysxVehicleSteeringAPI or
          PhysxVehicleAckermannSteeringAPI applied. "brakes0"/"brakes1" have to be applied to a prim that
          has PhysxVehicleBrakesAPI:brakes0/brakes1 applied. "drive" has to be applied to a prim that
          has PhysxVehicleDriveBasicAPI applied.'''
)
{
    float[] physxVehicleNCR:__INSTANCE_NAME__:commandValues (
        displayName = "Command Values"
        doc = """The command values to define response graphs for. Each listed command value
              (in range [0, 1], steer commands are treated symmetrically) has to point to a graph
              in speedResponses. The command values refer to steer, brake0 etc. The values
              have to be strictly increasing. The number of entries has to match the number of
              entries in speedResponsesPerCommandValue and is limited to 8. Every command value
              needs at least one entry in speedResponses."""
    )
    float2[] physxVehicleNCR:__INSTANCE_NAME__:speedResponses (
        displayName = "Speed Responses"
        doc = """List of pairs that define points in graphs of longitudinal speed vs. normalized
              response. The first value of the pair is the longitudinal speed, the second value
              is the expected response (in range [0, 1]). The longitudinal speed values within
              a graph have to be strictly increasing. The maximum allowed number of entries is 64.
              See speedResponsesPerCommandValue for how the different graphs are accessed."""
    )
    int[] physxVehicleNCR:__INSTANCE_NAME__:speedResponsesPerCommandValue (
        displayName = "Speed Responses Per Command Value"
        doc = """List of indices pointing to the start of a response graph for a certain command
              value. The index values have to be strictly increasing. The graph for command
              value commandValues[i] starts at entry speedResponses[speedResponsesPerCommandValue[i]]
              and stops at entry speedResponses[speedResponsesPerCommandValue[i+1] - 1]. The
              number of entries has to match the number of entries in commandValues and has the
              same maximum limit."""
    )
}

class "PhysxCameraAPI" (
    doc = "PhysX camera."
)
{
    bool alwaysUpdateEnabled = 1 (
        displayName = "Always Update Enabled"
        doc = """When enabled, always update this camera whether it is the active camera or not. This prevents cameras from slewing 
                 into position when switching to a new active camera. When disabled, only the active camera is updated, saving time."""
    )
    rel physxCamera:subject (
        displayName = "Subject"
        doc = "Reference to the subject this camera is to track."
    )
}

class "PhysxCameraFollowAPI" (
    apiSchemas = ["PhysxCameraAPI"]
    doc = "PhysX camera that follows behind the subject as it moves."
)
{
    float3 physxFollowCamera:cameraPositionTimeConstant (
        displayName = "Camera Position Time Constant"
        doc = "Filter time constant for the position of the camera for each axis, in seconds. e.g. (0.5 sec, 0.1 sec, 0.5 sec)"
    )
    float physxFollowCamera:followMaxDistance (
        displayName = "Follow Max Distance"
        doc = "The maximum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1000.0 cm"
    )
    float physxFollowCamera:followMaxSpeed (
        displayName = "Follow Max Speed"
        doc = "The maximum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm/sec"
    )
    float physxFollowCamera:followMinDistance (
        displayName = "Follow Min Distance"
        doc = "The minimum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm"
    )
    float physxFollowCamera:followMinSpeed (
        displayName = "Follow Min Speed"
        doc = "The minimum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 300.0 cm/sec"
    )
    float physxFollowCamera:followTurnRateGain (
        displayName = "Follow Turn Rate Gain"
        doc = "A scale factor that multiplies the filtered yaw rate to yaw the camera position behind the subject. Can be any positive or negative number. e.g. 0.2"
    )
    float physxFollowCamera:lookAheadMaxSpeed (
        displayName = "Look Ahead Max Speed"
        doc = "The maximum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 2000.0 cm"
    )
    float physxFollowCamera:lookAheadMinDistance (
        displayName = "Look Ahead Min Distance"
        doc = "The minimum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm"
    )
    float physxFollowCamera:lookAheadMinSpeed (
        displayName = "Look Ahead Min Speed"
        doc = "The minimum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm/sec"
    )
    float physxFollowCamera:lookAheadTurnRateGain (
        displayName = "Look Ahead Turn Rate Gain"
        doc = "A scale factor that multiplies the filtered yaw rate to yaw the camera look point left or right. Can be any positive or negative number. e.g. 0.2"
    )
    float physxFollowCamera:lookPositionHeight (
        displayName = "Look Position Height"
        doc = "Distance to elevate the camera look point. e.g. 50.0 cm"
    )
    float3 physxFollowCamera:lookPositionTimeConstant (
        displayName = "Look Position Time Constant"
        doc = "Filter time constant for the camera look point, in seconds. e.g. (0.2 sec, 0.5 sec, 0.2 sec)"
    )
    float physxFollowCamera:pitchAngle (
        displayName = "Pitch Angle"
        doc = "The pitch angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 15 degrees"
    )
    float physxFollowCamera:pitchAngleTimeConstant (
        displayName = "Pitch Angle Time Constant"
        doc = "Time constant to filter the pitch angle, in seconds. Used to pitch the camera up and down when driving up or down hills. e.g. 0.2 seconds"
    )
    float3 physxFollowCamera:positionOffset (
        displayName = "Position Offset"
        doc = "Position offset from the subject center of mass from which the camera follow vector and look vector are computed. e.g. (0.0 cm, 10.0 cm, 0.0 cm)"
    )
    float physxFollowCamera:slowPitchAngleSpeed (
        displayName = "Slow Pitch Angle Speed"
        doc = "Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 1000 cm/sec"
    )
    float physxFollowCamera:slowSpeedPitchAngleScale (
        displayName = "Slow Speed Pitch Angle Scale"
        doc = "Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 0.5"
    )
    float physxFollowCamera:velocityNormalMinSpeed (
        displayName = "Velocity Normal Min Speed"
        doc = "The minimum speed, below which, the subject look vector must be used because the normalized velocity vector is too erratic. e.g. 600.0 cm/sec"
    )
    float physxFollowCamera:yawAngle (
        displayName = "Yaw Angle"
        doc = "The yaw angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 0 degrees"
    )
    float physxFollowCamera:yawRateTimeConstant (
        displayName = "Yaw Rate Time Constant"
        doc = "Time constant to filter the subject yaw rate, in seconds. Use to look into turns. e.g. 0.2 sec"
    )
    float physxFollowFollowCamera:lookAheadMaxDistance (
        displayName = "Look Ahead Max Distance"
        doc = "The maximum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g.  500.0 cm"
    )
}

class "PhysxCameraFollowLookAPI" (
    apiSchemas = ["PhysxCameraFollowAPI"]
    doc = "PhysX camera that follows behind the subject's forward vector as it moves. Assumes the subject is always upright and does not roll."
)
{
    float physxFollowLookCamera:downHillGroundAngle (
        displayName = "Downhill Ground Angle"
        doc = "The minimum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. -45.0 degrees"
    )
    float physxFollowLookCamera:downHillGroundPitch (
        displayName = "Downhill Ground Pitch"
        doc = "The minimum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"
    )
    float physxFollowLookCamera:followReverseDistance (
        displayName = "Follow Reverse Distance"
        doc = "The maximum distance, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm"
    )
    float physxFollowLookCamera:followReverseSpeed (
        displayName = "Follow Reverse Speed"
        doc = "The positive, maximum speed, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm/sec"
    )
    float physxFollowLookCamera:upHillGroundAngle (
        displayName = "Uphill Ground Angle"
        doc = "The maximum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. 45.0 degrees"
    )
    float physxFollowLookCamera:upHillGroundPitch (
        displayName = "Uphill Ground Pitch"
        doc = "The maximum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"
    )
    float physxFollowLookCamera:velocityBlendTimeConstant (
        displayName = "Velocity Blend Time Constant"
        doc = "Filter time constant to blend between the look and velocity vectors, in seconds. e.g. 0.1 seconds"
    )
}

class "PhysxCameraFollowVelocityAPI" (
    apiSchemas = ["PhysxCameraFollowAPI"]
    doc = "PhysX camera that follows behind the subject's velocity vector as it moves, which allows the subject to roll and tumble."
)
{
}

class "PhysxCameraDroneAPI" (
    apiSchemas = ["PhysxCameraAPI"]
    doc = "PhysX drone camera that follows its subject from the air as it drives."
)
{
    float physxDroneCamera:feedForwardVelocityGain (
        displayName = "Feed Forward Velocity Gain"
        doc = "The higher the gain, the more closely the drone will match the velocity of the subject and the more connected it will appear. e.g. 0.1"
    )
    float physxDroneCamera:followDistance (
        displayName = "Follow Distance"
        doc = "The distance from the subject that the drone attempts to maintain. e.g. 30 meters"
    )
    float physxDroneCamera:followHeight (
        displayName = "Follow Height"
        doc = "The height above the subject that the drone attmepts to maintain. e.g. 15 meters"
    )
    float physxDroneCamera:horizontalVelocityGain (
        displayName = "Horizontal Velocity Gain"
        doc = "The higher the gain, the faster the drone will accelerate towards the target position. e.g. 1.0"
    )
    float physxDroneCamera:maxDistance (
        displayName = "Max Distance"
        doc = "The maximum distance allowed from the subject before the drone resets to the target position. e.g. 100 meters"
    )
    float physxDroneCamera:maxSpeed (
        displayName = "Max Speed"
        doc = "The maximum speed the drone is allowed to move. e.g. 20.0 meters/second"
    )
    float3 physxDroneCamera:positionOffset (
        displayName = "Position Offset"
        doc = "An offset vector from the subject origin at which the drone looks. e.g. (0.0 m, 0.0 m, 0.0 m)"
    )
    float physxDroneCamera:rotationFilterTimeConstant (
        displayName = "Rotation Filter Time Constant"
        doc = "The angular velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 0.2 seconds"
    )
    float physxDroneCamera:velocityFilterTimeConstant (
        displayName = "Velocity Filter Time Constant"
        doc = "The velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 1.0 seconds"
    )
    float physxDroneCamera:verticalVelocityGain (
        displayName = "Vertical Velocity Gain"
        doc = "The higher the gain, the higher the climb or descent rate of the drone to get to the target altitude. e.g. 1.0"
    )
}

class PhysxParticleSystem "PhysxParticleSystem" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    PhysX particle system, used to simulate fluids, cloth and inflatables. This prim allows the user to configure the
    solver parameters that are common to the particle objects associated with this system via their particleSystem relationship."""
)
{
    float contactOffset = -inf (
        displayName = "Contact Offset"
        doc = """Contact offset used for collisions with non-particle objects such as rigid or deformable bodies.
            Must be larger than restOffset. Default value -inf results in a simulation-determined value.
            Range: (restOffset, inf)
            Units: distance"""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    bool enableCCD = 0 (
        displayName = "Enable CCD"
        doc = "Enable continuous collision detection for particles to help avoid tunneling effects."
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    float fluidRestOffset = -inf (
        displayName = "Fluid Rest Offset"
        doc = """Rest offset used for fluid-fluid particle interactions. Must be smaller than particleContactOffset.
            Default value -inf results in a simulation-determined value.
            Range: [0, particleContactOffset)
            Units: distance"""
    )
    bool globalSelfCollisionEnabled = 1 (
        displayGroup = "Advanced"
        displayName = "Global Self Collision Enabled"
        doc = """If True, self collisions follow particle-object-specific settings. If False, all particle self collisions are disabled, regardless of any other settings.
            Improves performance if self collisions are not needed."""
    )
    float maxDepenetrationVelocity = inf (
        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum velocity permitted to be introduced by the solver to depenetrate intersecting particles.
            Range: [0, inf)
            Units: distance / seconds"""
    )
    int maxNeighborhood = 96 (
        displayGroup = "Advanced"
        displayName = "Max Neighborhood"
        doc = "The particle neighborhood size."
    )
    float maxVelocity = inf (
        displayName = "Max Velocity"
        doc = """Maximum particle velocity. See also cflCoefficient in PhysxPBDMaterialAPI for limiting particle-particle relative velocity.
            Range: [0, inf)
            Units: distance / seconds"""
    )
    bool nonParticleCollisionEnabled = 1 (
        displayGroup = "Advanced"
        displayName = "Nonparticle-Objects Collision Enabled"
        doc = """Enable or disable particle collision with nonparticle objects for all particles in the system.
            Improves performance if nonparticle collisions are not needed."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    float particleContactOffset = 0.05 (
        displayName = "Particle Contact Offset"
        doc = """Contact offset used for interactions between particles. Must be larger than solid and fluid rest offsets.
            Range: (max(solidRestOffset, fluidRestOffset), inf)
            Units: distance"""
    )
    bool particleSystemEnabled = 1 (
        displayName = "Particle System Enabled"
        doc = "Enable or disable the particle system."
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    float restOffset = -inf (
        displayName = "Rest Offset"
        doc = """Rest offset used for collisions with non-particle objects such as rigid or deformable bodies.
            Must be smaller than contact offset. Default value -inf results in a simulation-determined value.
            Range: [0, contactOffset)
            Units: distance"""
    )
    rel simulationOwner (
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that simulates this particle system. By default,
        this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )
    float solidRestOffset = -inf (
        displayName = "Solid Rest Offset"
        doc = """Rest offset used for solid-solid or solid-fluid particle interactions. Must be smaller than particleContactOffset.
            Default value -inf results in a simulation-determined value.
            Range: [0, particleContactOffset)
            Units: distance"""
    )
    int solverPositionIterationCount = 16 (
        displayGroup = "Advanced"
        displayName = "Solver Position Iteration Count"
        doc = """Number of solver iterations for position.
            Range: [1, 255]"""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float3 wind = (0, 0, 0) (
        displayName = "Wind"
        doc = """The wind applied to the current particle system.
            Range: (-inf, inf)
            Units: distance / seconds"""
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "PhysxParticleIsosurfaceAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Defines settings to extract an isosurface from the fluid particles in the particle system.
    The isosurface extraction is a post-processing step that does not affect the particle dynamics."""
)
{
    string physxParticleIsosurface:gridFilteringPasses = "GSRS" (
        displayName = "Grid Filtering Passes"
        doc = 'Grid filtering sequence, defined as capital letters "S":Smooth, "G":Grow, "R":Reduce. Up to 32 passes.'
    )
    float physxParticleIsosurface:gridSmoothingRadius = -inf (
        displayName = "Grid Smoothing Radius"
        doc = """The radius used during the smoothing process on the grid. Default value -inf results in a simulation-determined value.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxParticleIsosurface:gridSpacing = -inf (
        displayName = "Grid Spacing"
        doc = """Cell Size of the grid used for isosurface extraction. Default value -inf results in a simulation-determined value.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxParticleIsosurface:isosurfaceEnabled = 1 (
        displayName = "Isosurface Enabled"
        doc = "Enable or disable the creation of an isosurface."
    )
    uniform int physxParticleIsosurface:maxSubgrids = 2048 (
        displayName = "Max Subgrids"
        doc = """Maximum number of blocks the sparse grid structure can contain.
            Range: [1, inf)"""
    )
    uniform int physxParticleIsosurface:maxTriangles = 2097152 (
        displayName = "Max Triangles"
        doc = """Maximum number of triangles the extracted isosurface can have.
            Range: [1, inf)"""
    )
    uniform int physxParticleIsosurface:maxVertices = 1048576 (
        displayName = "Max Vertices"
        doc = """Maximum number of vertices the extracted isosurface can have.
            Range: [3, inf)"""
    )
    int physxParticleIsosurface:numMeshNormalSmoothingPasses = 4 (
        displayName = "Mesh Normal Smoothing Passes"
        doc = """Number of smoothing passes applied to the normals of the generated isosurface triangle mesh.
            Range: [0, inf)"""
    )
    int physxParticleIsosurface:numMeshSmoothingPasses = 4 (
        displayName = "Mesh Smoothing Passes"
        doc = """Number of smoothing passes applied to the generated isosurface triangle mesh.
            Range: [0, inf)"""
    )
    float physxParticleIsosurface:surfaceDistance = -inf (
        displayName = "Surface Distance"
        doc = """Distance from particle center to isosurface. Default value -inf results in a simulation-determined value.
            Range: [0, 2.5*gridSpacing)
            Units: distance"""
    )
}

class "PhysxParticleSmoothingAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Controls smoothing of simulated particle positions in a post-processing step.
    The smoothing post-processing only affects the rendering output including isosurface generation, and not the particle dynamics.
    Affects point based primitives with PhysxParticleSetAPI, which are defined as fluid."""
)
{
    bool physxParticleSmoothing:particleSmoothingEnabled = 1 (
        displayName = "Particle Smoothing Enabled"
        doc = "Enable or disable smoothingStrength of particle positions."
    )
    float physxParticleSmoothing:strength = 0.8 (
        displayName = "Strength"
        doc = """Smoothing coefficient for particle positions.
            Range: [0, 1]
            Units: dimensionless"""
    )
}

class "PhysxParticleAnisotropyAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a PhysxParticleSystem. Defines settings to compute anisotropic scaling of particles in a post-processing step.
    The anisotropy post-processing only affects the rendering output including isosurface generation, and not the particle dynamics.
    Affects point instancer primitives with PhysxParticleSetAPI, which are defined as fluid."""
)
{
    float physxParticleAnisotropy:max = 2 (
        displayName = "Max"
        doc = """Maximum scale of anisotropy relative to fluidRestOffset for rendering.
            Range: [min, inf)
            Units: dimensionless"""
    )
    float physxParticleAnisotropy:min = 0.2 (
        displayName = "Min"
        doc = """Minimum scale of anisotropy relative to fluidRestOffset for rendering.
            Range: [0, max]
            Units: dimensionless"""
    )
    bool physxParticleAnisotropy:particleAnisotropyEnabled = 1 (
        displayName = "Particle Anisotropy Enabled"
        doc = "Enables use of fluid anisotropy information for rendering."
    )
    float physxParticleAnisotropy:scale = 1 (
        displayName = "Scale"
        doc = """Scale of anisotropy for rendering.
            Range: [0, inf)
            Units: dimensionless"""
    )
}

class "PhysxDiffuseParticlesAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomPoints or UsdGeomPointInstancer primitive with PhysxParticleSetAPI. 
    Defines settings that the particle simulation uses to spawn diffuse particles.
    The diffuse particles are a render-only effect and do not affect the particle dynamics."""
)
{
    float physxDiffuseParticles:airDrag = 0 (
        displayName = "Air Drag"
        doc = """Air drag force factor for spray particles.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxDiffuseParticles:bubbleDrag = 0.5 (
        displayName = "BubbleDrag"
        doc = """Fluid drag force factor for bubble particles.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxDiffuseParticles:buoyancy = 0.8 (
        displayName = "Buoyancy"
        doc = """Buoyancy force factor for bubble particles.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxDiffuseParticles:collisionDecay = 0.5 (
        displayName = "Collision Decay"
        doc = """Decay factor of diffuse particles' lifetime after they collide with shapes. 0 == lifetime remains unchanged, 1 == particle disappears immediately.
            Range: [0, 1]
            Units: dimensionless"""
    )
    bool physxDiffuseParticles:diffuseParticlesEnabled = 1 (
        displayName = "Diffuse Particles Enabled"
        doc = "Enable or disable the creation of diffuse particles."
    )
    float physxDiffuseParticles:divergenceWeight = 5 (
        displayName = "Divergence Weight"
        doc = """Contribution from divergence when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDiffuseParticles:kineticEnergyWeight = 0.01 (
        displayName = "Kinetic Energy Weight"
        doc = """Contribution from kinetic energy when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDiffuseParticles:lifetime = 5 (
        displayName = "Lifetime"
        doc = """Lifetime of a spawned particle before it is removed again.
            Range: [0, inf)
            Units: seconds"""
    )
    uniform float physxDiffuseParticles:maxDiffuseParticleMultiplier = -inf (
        displayName = "Max Diffuse Particle Multiplier"
        doc = """Maximum number of diffuse particles that can be present in the simulation relative to the number
              of non-diffuse particles.
              Range: [0.0, inf)
              Default value -inf means default is picked by the simulation."""
    )
    float physxDiffuseParticles:pressureWeight = 1 (
        displayName = "Pressure Weight"
        doc = """Contribution from pressure when deciding diffuse particle creation.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDiffuseParticles:threshold = 0.01 (
        displayName = "Threshold"
        doc = """Kinetic energy threshold a particle must reach to spawn a diffuse particle.
            Range: [0, inf)
            Units: energy = mass * distance * distance / seconds / seconds"""
    )
    bool physxDiffuseParticles:useAccurateVelocity = 0 (
        displayGroup = "Advanced"
        displayName = "Use Accurate Velocity"
        doc = "Enables accurate particle velocity estimation."
    )
}

class "PhysxPBDMaterialAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a USD Material. PhysX position-based-dynamics (PBD) material for particles used to simulate fluids, cloth and inflatables.
    Currently, only a single material per particle system is supported which applies to all objects that are associated with the system."""
)
{
    float physxPBDMaterial:adhesion = 0 (
        displayGroup = "Advanced"
        displayName = "Adhesion"
        doc = """Adhesion for interactions between particles (solid or fluid), and rigids or deformables.
            Adhesion also applies to solid-solid particle interactions, but is multiplied with the particle adhesion scale.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:adhesionOffsetScale = 0 (
        displayGroup = "Advanced"
        displayName = "Adhesion Offset Scale"
        doc = """Offset scale defining the offset at which adhesion ceases to take effect. For interactions between particles (fluid or solid),
            and rigids or deformables, the adhesion offset is defined relative to the rest offset. For solid particle-particle
            interactions, the adhesion offset is defined relative to the solid rest offset.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:cflCoefficient = 1 (
        displayGroup = "Advanced"
        displayName = "CFL Coefficient"
        doc = """This coefficient scales the CFL term used to limit relative motion between fluid particles. A very large value disables the limit.
            Range: [1, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:cohesion = 0 (
        displayName = "Cohesion"
        doc = """Cohesion for interaction between fluid particles.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:damping = 0 (
        displayName = "Damping"
        doc = """Global velocity damping coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxPBDMaterial:density = 0 (
        displayName = "Density"
        doc = """Density used to compute particle object mass. If set to 0.0, the simulation determines a default density.
            A density or mass set with a PhysicsMassAPI on a particle object overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )
    float physxPBDMaterial:drag = 0 (
        displayName = "Drag"
        doc = """Drag coefficient for cloth and inflatable particle objects. Basic aerodynamic drag model coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxPBDMaterial:friction = 0.2 (
        displayName = "Friction"
        doc = """Friction coefficient. The maximal friction force tangential to the surface is equal to the normal force times
            the friction. The friction takes effect in all interactions between particles and rigids or deformables.
            For solid particle-particle interactions it is multiplied by the particle friction scale.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:gravityScale = 1 (
        displayGroup = "Advanced"
        displayName = "Gravity Scale"
        doc = """Gravitational acceleration scaling factor. Can be used to approximate lighter-than-air inflatables, for example (-1.0 would invert gravity).
            Range: (-inf, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:lift = 0 (
        displayName = "Lift"
        doc = """Lift coefficient for cloth and inflatable particle objects. Basic aerodynamic lift model coefficient.
            Range: [0, inf)
            Units: dimensionless """
    )
    float physxPBDMaterial:particleAdhesionScale = 1 (
        displayGroup = "Advanced"
        displayName = "Particle Adhesion Scale"
        doc = """Coefficient that scales adhesion for solid particle-particle interations.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:particleFrictionScale = 1 (
        displayGroup = "Advanced"
        displayName = "Particle Friction Scale"
        doc = """Coefficient that scales friction for solid particle-particle interations.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxPBDMaterial:surfaceTension = 0 (
        displayName = "Surface Tension"
        doc = """Surface tension for fluid particles.
            Range: [0, inf) 
            Units: 1 / (distance * distance * distance)"""
    )
    float physxPBDMaterial:viscosity = 0 (
        displayName = "Viscosity"
        doc = """Viscosity for fluid particles.
            Range: [0, inf) 
            Units: dimensionless"""
    )
    float physxPBDMaterial:vorticityConfinement = 0 (
        displayGroup = "Advanced"
        displayName = "Vorticity Confinement"
        doc = """Vorticity confinement for fluid particles. Helps prevent energy loss due to numerical solver by adding vortex-like accelerations to the particles.
            Range: [0, inf)
            Units: dimensionless """
    )
}

class "PhysxParticleAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Do not apply. Provides parameters shared among particle objects."""
)
{
    bool physxParticle:particleEnabled = 1 (
        displayName = "Particle Enabled"
        doc = "Enable or disable the particle object."
    )
    int physxParticle:particleGroup = 0 (
        displayGroup = "Advanced"
        displayName = "Particle Group"
        doc = """Group Id of the particles. Particles / objects in different groups in the same system collide with each other.
            Within the same group in the same system, the collision behavior is controlled by the selfCollision parameter.
            Range: [0, 2^20)"""
    )
    rel physxParticle:particleSystem (
        displayName = "Particle System"
        doc = "Single particle system that the particle-based object belongs to."
    )
    bool physxParticle:selfCollision = 1 (
        displayName = "Self Collision"
        doc = "Enables self-collision of the particles or of the particle object."
    )
}

class "PhysxParticleSetAPI" (
    apiSchemas = ["PhysxParticleAPI"]
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomPointInstancer or a UsdGeomPointBased. Creates a set of particles for granular (i.e. solid-particle) material or fluid simulation with PhysX."""
)
{
    bool physxParticle:fluid = 1 (
        displayName = "Fluid"
        doc = "Flag to toggle simulation as fluid (True) or solid (False)."
    )
    point3f[] physxParticle:simulationPoints (
        displayGroup = "Advanced"
        displayName = "Simulation Points"
        doc = """This attribute is read-only and is updated from simulation to capture particle-simulation state while smoothed position data
            is written to the render position/points attribute of the UsdGeomPointInstancer/UsdGeomPoints."""
    )
}

class "PhysxParticleSamplingAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh which is Poisson-sampled to generate particles in the particles relationship."""
)
{
    int physxParticleSampling:maxSamples = 50000 (
        displayName = "Maximum Number of Samples"
        doc = """Approximate upper bound on the number of samples. Zero means unbounded.
            Range: [0, inf)"""
    )
    rel physxParticleSampling:particles (
        displayName = "Particles"
        doc = "Relationship to the particle set sampled from the mesh."
    )
    float physxParticleSampling:samplingDistance = 0 (
        displayName = "Particle Distance"
        doc = """The distance between the sampled positions. In general, choose a value larger than the corresponding particle rest offset.
            Default value zero means that a suitable value is auto-determined.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxParticleSampling:volume = 1 (
        displayName = "Sample Inside Volume"
        doc = "Whether to sample points inside the mesh or not."
    )
}

class "PhysxParticleClothAPI" (
    apiSchemas = ["PhysxParticleAPI"]
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh. The mesh is simulated as a particle-based cloth or inflatable, depending on the mesh geometry
    and the pressure attribute. See PhysxAutoParticleClothAPI for an auto-compute helper for cloth springs and dampings."""
)
{
    float physxParticle:pressure = 0 (
        displayName = "Pressure"
        doc = """Pressure: If > 0, a particle cloth has an additional pressure constraint 
            that provides inflatable (i.e. balloon-like) dynamics. The pressure times the rest volume defines 
            the volume the inflatable tries to match. Pressure only works well for closed or approximately closed meshes.
            Range: [0, inf)
            Units: dimensionless"""
    )
    point3f[] physxParticle:restPoints (
        displayGroup = "Advanced"
        displayName = "Rest Points"
        doc = "Particle positions in cloth rest configuration."
    )
    bool physxParticle:selfCollisionFilter = 1 (
        displayGroup = "Advanced"
        displayName = "Self Collision Filter"
        doc = "Whether the simulation should filter particle-particle collisions based on their rest position distances."
    )
    float[] physxParticle:springDampings (
        displayGroup = "Advanced"
        displayName = "Spring Dampings"
        doc = """Coefficients for linear-distance dampers between a pair of particles as defined by index pairs in springIndices.
            Range: [0, inf)
            Units: force * second / distance = mass / second"""
    )
    uniform int2[] physxParticle:springIndices (
        displayGroup = "Advanced"
        displayName = "Spring Indices"
        doc = "List of index pairs describing which points are connected by spring constraints."
    )
    float[] physxParticle:springRestLengths (
        displayGroup = "Advanced"
        displayName = "Spring Rest Lengths"
        doc = """Spring rest lengths corresponding to spring index pairs.
            Range: (-inf, inf)
            Units: distance"""
    )
    float[] physxParticle:springStiffnesses (
        displayGroup = "Advanced"
        displayName = "Spring Stiffnesses"
        doc = """Stiffness values for linear-distance springs between a pair of particles as defined by index pairs in springIndices.
            Range: [0, inf)
            Units: force / distance = mass / second / second"""
    )
}

class "PhysxAutoParticleClothAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh with PhysxParticleClothAPI. Defines parameters to automatically compute spring constraints."""
)
{
    bool physxAutoParticleCloth:disableMeshWelding = 0 (
        displayName = "Disable Mesh Welding"
        doc = "Disable welding of the UsdGeomMesh vertices for cloth simulation."
    )
    float physxAutoParticleCloth:springBendStiffness = 1.5 (
        displayName = "Bend Stiffness"
        doc = """Bend stiffness. Represents a stiffness for linear springs placed in a way to counteract bending.
            Range: [0, inf)
            Units:  force / distance = mass / second / second"""
    )
    float physxAutoParticleCloth:springDamping = 10 (
        displayName = "Spring Damping"
        doc = """Damping on cloth spring constraints. Applies to all constraints parametrized by stiffness attributes.
            Range: [0, inf)
            Units: force * second / distance = mass / second"""
    )
    float physxAutoParticleCloth:springShearStiffness = 1.5 (
        displayName = "Shear Stiffness"
        doc = """Shear stiffness. Represents a stiffness for linear springs placed in a way to counteract shear.
            Range: [0, inf)
            Units:  force / distance = mass / second / second"""
    )
    float physxAutoParticleCloth:springStretchStiffness = 1.5 (
        displayName = "Stretch Stiffness"
        doc = """Stretch stiffness. Represents a stiffness for linear springs placed between particles to counteract stretching.
            Range: [0, inf)
            Units: force / distance = mass / second / second"""
    )
}

class "PhysxDeformableBodyMaterialAPI" (
    doc = "Applied to USD Material. Defines material properties for deformable bodies."
)
{
    float physxDeformableBodyMaterial:dampingScale = 1 (
        displayName = "Damping Scale"
        doc = """Experimental parameter. Try a high damping together with a scale of zero for a water-bed like effect.
            Range: [0, 1]
            Units: dimensionless"""
    )
    float physxDeformableBodyMaterial:density = 0 (
        displayName = "Density"
        doc = """Material density. If set to 0.0, the simulation determines a default density. A density or mass set with a PhysicsMassAPI overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )
    float physxDeformableBodyMaterial:dynamicFriction = 0.25 (
        displayName = "Dynamic Friction"
        doc = """Dynamic friction coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDeformableBodyMaterial:elasticityDamping = 0.005 (
        displayName = "Elasticity Damping"
        doc = """Material damping parameter. Use values much smaller than one for good results.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDeformableBodyMaterial:poissonsRatio = 0.45 (
        displayName = "Poisson's Ratio"
        doc = """Poissons's ratio which defines the material's volume preservation under stress.
            Range: [0, 0.5]
            Units: dimensionless"""
    )
    float physxDeformableBodyMaterial:youngsModulus = 50000000 (
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material.
            Range: [0, inf)
            Units: force / area = mass/distance/seconds/seconds"""
    )
}

class "PhysxDeformableSurfaceMaterialAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to USD Material. Defines material properties for deformable surfaces."""
)
{
    float physxDeformableSurfaceMaterial:density = 0 (
        displayName = "Density"
        doc = """Material density. If set to 0.0, the simulation determines a default value. 
            The mass of deformable surface is computed by density * area * thickness.
            A density or mass set with a PhysicsMassAPI overrides the material density.
            Range: [0, inf)
            Units: mass / distance / distance / distance"""
    )
    float physxDeformableSurfaceMaterial:dynamicFriction = 0.25 (
        displayName = "Dynamic Friction"
        doc = """Dynamic friction coefficient.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxDeformableSurfaceMaterial:poissonsRatio = 0 (
        displayName = "Poisson's Ratio"
        doc = """Poissons's ratio which defines the material's volume preservation under stress. 
            Used to determine in-plane and bending stiffness.
            Range: [0, 0.5]
            Units: dimensionless"""
    )
    float physxDeformableSurfaceMaterial:thickness = 0 (
        displayName = "Thickness"
        doc = """Virtual thickness of cloth mesh. Used to determine in-plane and bending stiffness, and mass from density.
            If set to 0.0, the simulation determines a default value.
            Range: [0.0, inf)
            Units: distance"""
    )
    float physxDeformableSurfaceMaterial:youngsModulus = -inf (
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material. 
            Used to determine in-plane and bending stiffness.
            If set to a negative value, the simulation determines a default value.
            Range: [0, inf)
            Units: force / area = mass/distance/seconds/seconds"""
    )
}

class "PhysxDeformableAPI" (
    doc = """Do not apply. Base API that provides attributes common to both deformable bodies and surfaces.
          Derived APIs are applied to UsdGeomMesh in order to create a deformable physics object.
          Note that the UsdGeomMesh points attribute becomes a read-only attribute for a deformable as the mesh is driven by the simulation.
          """
)
{
    bool physxDeformable:deformableEnabled = 1 (
        displayName = "Deformable Enabled"
        doc = "Enable or disable the deformable object."
    )
    bool physxDeformable:enableCCD = 0 (
        displayName = "Enable CCD"
        doc = "Distance based CCD."
    )
    float physxDeformable:maxDepenetrationVelocity = inf (
        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum velocity permitted to be introduced by the solver to depenetrate intersections.
            Range: [0, inf)
            Units: distance / seconds"""
    )
    point3f[] physxDeformable:restPoints (
        displayGroup = "Advanced"
        displayName = "Rest Points"
        doc = """Rest points of the UsdGeomMesh in local coordinates.
              Units: distance"""
    )
    bool physxDeformable:selfCollision = 0 (
        displayName = "Enable Self Collision"
        doc = "Enables self collisions on the deformable, preventing self intersections."
    )
    float physxDeformable:selfCollisionFilterDistance = -inf (
        displayName = "Self Collision Filter Distance"
        doc = """Distance under which self-collisions are disabled. Default value -inf means default is picked by the simulation.
              Range: [2*physxCollision:contactOffset, max_float]
              Units: distance"""
    )
    float physxDeformable:settlingThreshold = 0.1 (
        displayName = "Settling Threshold"
        doc = """Threshold vertex velocity under which sleep damping is applied in addition to velocity damping.
              Range: [0, inf]
              Units: distance/seconds"""
    )
    uniform int[] physxDeformable:simulationIndices (
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Indices"
        doc = "Simulation mesh indices."
    )
    rel physxDeformable:simulationOwner (
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that simulates this deformable. By default,
        this is the first PhysicsScene found in the stage using UsdStage::Traverse()."""
    )
    point3f[] physxDeformable:simulationVelocities (
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Vertex Velocities"
        doc = """Simulation mesh vertex velocities in local coordinates.
            Units: distance / seconds"""
    )
    float physxDeformable:sleepDamping = 10 (
        displayName = "Sleep Damping"
        doc = """Additional damping term if vertex velocity drops below settlingThreshold.
              Range: [0, inf)
              Units: 1/seconds"""
    )
    float physxDeformable:sleepThreshold = 0.05 (
        displayName = "Sleep Threshold"
        doc = """Velocity threshold under which the vertex becomes a candidate for sleeping.
              Range: [0, inf)
              Units: distance/seconds"""
    )
    uint physxDeformable:solverPositionIterationCount = 16 (
        displayName = "Solver Position Iterations"
        doc = """ Number of solver position iterations per time step.
              Range: [1, 255]"""
    )
    float physxDeformable:vertexVelocityDamping = 0.005 (
        displayName = "Vertex Velocity Damping"
        doc = """Artificial damping on the vertex velocity, which may approximate aerodynamic drag.
              Range: [0, inf)
              Units: 1/seconds"""
    )
}

class "PhysxDeformableBodyAPI" (
    apiSchemas = ["PhysxDeformableAPI"]
    doc = """Applied to a UsdGeomMesh that is to be driven by a deformable body simulation.
\t      See PhysxDeformableAPI for information on how to define the deformable body's material properties."""
)
{
    uniform int[] physxDeformable:collisionIndices (
        displayGroup = "Advanced"
        displayName = "Collision Mesh Indices"
        doc = "Mesh indices that define the collision tetrahedral mesh together with the collisionPoints attribute."
    )
    point3f[] physxDeformable:collisionPoints (
        displayGroup = "Advanced"
        displayName = "Collision Mesh Points"
        doc = """Mesh points in local coordinates that define the collision tetrahedral mesh together with the collisionIndices attribute.
            This attribute is read-only and may be updated from simulation data to reflect the current simulation state."""
    )
    point3f[] physxDeformable:collisionRestPoints (
        displayGroup = "Advanced"
        displayName = "Collision Mesh Rest Points"
        doc = "Mesh rest points in local coordinates that define the rest pose of the collision tetrahedral mesh together with the collisionIndices attribute."
    )
    bool physxDeformable:disableGravity = 0 (
        displayName = "Disable Gravity"
        doc = "Disable gravity for the actor."
    )
    point3f[] physxDeformable:simulationPoints (
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Points"
        doc = """Simulation mesh points in local coordinates that define the simulation tetrahedral mesh together with the simulationIndices attribute.
            This attribute may be updated from simulation data to reflect the current simulation state."""
    )
    point3f[] physxDeformable:simulationRestPoints (
        displayGroup = "Advanced"
        displayName = "Simulation Mesh Rest Points"
        doc = "Mesh rest points in local coordinates that define the rest pose of the simulation tetrahedral mesh together with the simulationIndices attribute."
    )
}

class "PhysxDeformableSurfaceAPI" (
    apiSchemas = ["PhysxDeformableAPI"]
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to a UsdGeomMesh that is to be simulated as a deformable surface.
\tSee PhysxDeformableAPI for information on how to define the deformable surface's material properties."""
)
{
    float physxDeformableSurface:bendingStiffnessScale = 0 (
        displayName = "Bending Stiffness Scale"
        doc = """Scales bending stiffness computed from Young's modulus, Poisson's ratio, and the cloth thickness.
            Range: [0, inf)
            Units: dimensionless"""
    )
    uint physxDeformableSurface:collisionIterationMultiplier = 1 (
        displayGroup = "Advanced"
        displayName = "Collision Iteration Multiplier"
        doc = """Determines how many collision subiterations are used in each solver iteration.
            By defualt, collision constraints are applied once in each solver iteration, 
            and increasing this value will apply collision constraints more frequently in each solver iteration,
            e.g., 2 means collision constraints are applied twice in each solver iteration (thus, the collision constraints are applied 2 x solverPositionIterationCount times in each time step).            
            Increasing this value does not update collision pairs more frequently, see collisionPairUpdateFrequency.
            Range [1, solverPositionIterationCount/2]"""
    )
    uint physxDeformableSurface:collisionPairUpdateFrequency = 1 (
        displayGroup = "Advanced"
        displayName = "Collision Pair Update Frequency"
        doc = """Determines how often collision pairs are updated in each time step.
            By default, the pairs of contact points are computed only at the beginning of each time step, and the pairs are kept during the time step.
            Increasing this value will update the contact pairs more frequently providing better contact points,
            e.g., 2 means collision pairs are updated twice in each time step: 
            at the beginning of the time step, and in the middle of the time step (i.e., at the middle solver iteration).
            Range [1, solverPositionIterationCount/2]"""
    )
    bool physxDeformableSurface:flatteningEnabled = 0 (
        displayName = "Flattening Enabled"
        doc = """If enabled, bending forces are applied such that the surface flattens, i.e., neighboring triangles become coplanar.
        If disabled, the forces drive toward the bend at the rest state."""
    )
    float physxDeformableSurface:maxVelocity = inf (
        displayGroup = "Advanced"
        displayName = "Max Velocity"
        doc = """Maximum velocity. The velocity of each vertex is clamped by the max velocity.
            Range: [0, inf)
            Units: distance / seconds"""
    )
}

class PhysxPhysicsAttachment "PhysxPhysicsAttachment" (
    doc = "Represents attachments between physics actors, for example, between a rigid body and a deformable body, or a deformable body and a particle cloth."
)
{
    rel actor0 (
        displayName = "Actor 0"
        doc = "Reference to the first actor."
    )
    rel actor1 (
        displayName = "Actor 1"
        doc = "Reference to the second actor."
    )
    bool attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Enable or disable the attachment."
    )
    uint[] collisionFilterIndices0 (
        displayGroup = "Advanced"
        displayName = "Collision Filter Indices Actor 0"
        doc = "Indices to geometry of Actor 0 that should not generate collisions with Actor 1 as specified by filterType0. Ignored for rigid bodies."
    )
    uint[] collisionFilterIndices1 (
        displayGroup = "Advanced"
        displayName = "Collision Filter Indices Actor 1"
        doc = "Indices to mesh triangle/tet/hex/etc. of Actor 1 that should not generate collisions with Actor 0. Ignored for rigid bodies."
    )
    uniform token filterType0 (
        allowedTokens = ["Vertices", "Geometry"]
        displayGroup = "Advanced"
        displayName = "Filter Type 0"
        doc = "Specify if indices in collisionFilterIndices0 correspond to vertices; or mesh cell-geometry, i.e. triangles, tetrahedrons, etc."
    )
    uniform token filterType1 (
        allowedTokens = ["Vertices", "Geometry"]
        displayGroup = "Advanced"
        displayName = "Filter Type 1"
        doc = "Specify if indices in collisionFilterIndices1 correspond to vertices; or mesh cell-geometry, i.e. triangles, tetrahedrons, etc."
    )
    point3f[] points0 (
        displayGroup = "Advanced"
        displayName = "Points Actor 0"
        doc = "Attachment points in Actor 0 local space, defined in the actor's rest state, if it is deformable. Elements correspond one-to-one to elements in points1 attribute."
    )
    point3f[] points1 (
        displayGroup = "Advanced"
        displayName = "Points Actor 1"
        doc = "Attachment points in Actor 1 local space, defined in the actor's rest state, if it is deformable. Elements correspond one-to-one to elements in points0 attribute."
    )
}

class "PhysxAutoAttachmentAPI" (
    doc = "Auto generates the attachment points and filtering ids based on the attributes defined in the API."
)
{
    float physxAutoAttachment:collisionFilteringOffset = -inf (
        displayName = "Collision Filtering Offset"
        doc = """Filtering ids are generated for deformable mesh vertices if their distance to the other actor's volume is smaller than the offset. Use heuristic by default.
            Range: [0, inf)
            Units: distance"""
    )
    float physxAutoAttachment:deformableVertexOverlapOffset = 0 (
        displayName = "Deformable Vertex Overlap Offset"
        doc = """Deformable mesh vertices are attached if their distance to the other actor's volume is smaller than the offset.
            Range: [0, inf)
            Units: distance"""
    )
    bool physxAutoAttachment:enableCollisionFiltering = 1 (
        displayName = "Enable Collision Filtering"
        doc = "Enables adding collision filtering in the vicinity of the attachment points."
    )
    bool physxAutoAttachment:enableDeformableFilteringPairs = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Deformable Collision Filtering Pairs"
        doc = """Enables geometry pair based collision filtering for deformable-deformable attachments. 
            By default a filtered geometry of one actor is filtered against all geometries of the other actor."""
    )
    bool physxAutoAttachment:enableDeformableVertexAttachments = 1 (
        displayName = "Enable Deformable Vertex Attachments"
        doc = "Enables attaching deformable mesh vertices which overlap with the other actor's volume."
    )
    bool physxAutoAttachment:enableRigidSurfaceAttachments = 0 (
        displayName = "Enable Rigid Surface Attachments"
        doc = "Enables sampling attachment points on the rigid actor's surface."
    )
    float physxAutoAttachment:rigidSurfaceSamplingDistance = -inf (
        displayName = "Rigid Surface Sampling Distance"
        doc = """Attachment points on the rigid surface are positioned such that their typical neighbor distance matches the sampling distance. Use heuristic by default.
            Range: [0, inf)
            Units: distance"""
    )
}

class "PhysxHairAPI" (
    apiSchemas = ["PhysxDeformableAPI"]
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    This is the PhysX Hair API. This API should be applied to a UsdGeomPointBased, for
    example UsdGeomMesh or UsdGeomBasisCurves to simulate the geometry as a PhysX Hairsystem."""
)
{
    bool physxHair:externalCollision = 1 (
        displayName = "External Collision"
        doc = "Enables the hair segments to collide with other physics objects that have a collision API applied to them."
    )
    float physxHair:globalShapeComplianceAtRoot = -inf (
        displayName = "Global Shape Compliance at Root"
        doc = """Compliance to the global shape-matching constraint at the root of the strand.
        The higher the compliance the softer the constraint.
            A negative value disables the shape-matching constraint.
            Range: [0, inf)
            Units: dimensionless"""
    )
    float physxHair:globalShapeComplianceStrandAttenuation = 1 (
        displayName = "Attenuation for Global Shape Compliance"
        doc = """The factor by which the compliance to the global shape-matching constraint changes from
        a simulation vertex to the next one along the strand. Use it to increase or decrease
        the compliance along a strand, starting with globalShapeComplianceAtRoot.
            A value > 1.0 means the constraint becomes softer towards the strand tips.
            Range: (0, inf)
            Units: dimensionless"""
    )
    float physxHair:interHairRepulsion = 0 (
        displayName = "Repulsion Between Hair Segments"
        doc = """Strength of the repulsion effect between hair segments.
        This effect is based on the volumetric density of hair vertices in space.
        Can be used as a substitute or complement to self-collisions.
            Range: [0.0, inf)
            Units: dimensionless"""
    )
    float physxHair:localShapeMatchingCompliance = -inf (
        displayName = "Local Shape-matching Compliance"
        doc = """Compliance to the local shape matching constraint, which preserves strand shapes.
        The larger the compliance the softer the constraint.
            A negative value disables the constraint.
            Range [0, inf)
            Units: dimensionless"""
    )
    int physxHair:localShapeMatchingGroupOverlap = -1 (
        displayGroup = "Advanced"
        displayName = "Local Shape-matching Group Overlap"
        doc = """Number of vertices by which consecutive shape-matching groups are overlapping.
        Only takes effect if shape matching is enabled.
            Default value of -1 means maximum overlap, i.e., shapeMatchingGroupSize/2
            Range [0, shapeMatchingGroupSize/2]."""
    )
    uint physxHair:localShapeMatchingGroupSize = 32 (
        displayGroup = "Advanced"
        displayName = "Local Shape-matching Group Size"
        doc = """How many vertices of a strand are grouped together into one shape-matching constraint.
        The larger this number to more rigid a strand appears. The value is automatically
        capped at the strand length. Setting only takes effect if shape matching is enabled.
            Range [2, inf)."""
    )
    float physxHair:localShapeMatchingLinearStretching = 0.1 (
        displayGroup = "Advanced"
        displayName = "Local Shape-matching Linear Stretching"
        doc = """Proportion of linear stretching vs rigid transformation allowed in the local shape matching constraint.
        Only takes effect if local shape matching is enabled.
            A value of 0 allows only rigid transforms, a value of 1 permits linear deformations freely.
            Range [0.0, 1.0]
            Units: dimensionless"""
    )
    float physxHair:segmentLength = 0 (
        displayName = "Segment Length"
        doc = """Length of one hair segment (i.e., distance between simulation vertices along a strand).
        This value is used to automatically place simulation vertices (=control points) along a strand.
            The default value of 0 means the length is autocomputed such that the longest strand has 32 vertices.
            Range: [0, inf),
            Units: distance"""
    )
    bool physxHair:twosidedAttachment = 0 (
        displayGroup = "Advanced"
        displayName = "Two-Sided Attachment"
        doc = "Whether the hair should have an effect on the body it is attached to."
    )
    float physxHair:velSmoothing = 0.3 (
        displayName = "Velocity Smoothing"
        doc = """Strength of the velocity smoothing effect.
        The higher the value the more the hair moves like a single rigid body.
            A value of zero disables the constraint.
            Range: [0.0, 1.0]
            Units: dimensionless"""
    )
}

class "PhysxHairMaterialAPI" (
    doc = """WARNING: This is a draft API; the design is not fixed and may change in the future.
    Applied to USD Material. Defines material properties for hair simulation."""
)
{
    float physxHairMaterial:contactOffset = -inf (
        displayGroup = "Advanced"
        displayName = "Contact Offset"
        doc = """Distance at which collisions are generated.
            Overrides the contactOffsetMultiplier attribute if set to a non-negative value.
            Range: [0.0, inf)
            Units: distance"""
    )
    float physxHairMaterial:contactOffsetMultiplier = 1 (
        displayName = "Contact Offset Multiplier"
        doc = """Distance at which collisions are generated as a multiple of curveThickness.
            This attribute has no effect if contactOffset is non-negative.
            Range: [0.0, inf)
            Units: dimensionless
        """
    )
    float physxHairMaterial:curveBendStiffness = -inf (
        displayName = "Curve Bend Stiffness"
        doc = """Optional override for bending stiffness; by default derived from youngsModulus and curveThickness.
            Override is active if the value is non-negative.
            Range: [0, inf)
            Units: mass/(distance*seconds*seconds)."""
    )
    float physxHairMaterial:curveThickness = -inf (
        displayName = "Curve Thickness"
        doc = """Diameter along curve.
            A negative value means the simulation will pick a default.
            Range: [0, inf)
            Units: distance."""
    )
    float physxHairMaterial:density = 0 (
        displayName = "Density"
        doc = """If non-zero, defines the density of the material. This can be
        used for body mass computation, see PhysicsMassAPI.
        Note that if the density is 0.0 it is ignored. 
            Units: mass/distance/distance/distance."""
    )
    float physxHairMaterial:dynamicFriction = 0 (
        displayName = "Dynamic Friction"
        doc = "Dynamic friction coefficient. Unitless."
    )
    float physxHairMaterial:youngsModulus = -inf (
        displayGroup = "Advanced"
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material.
            A negative value means the simulation will pick a default.
            Range: [0, inf)
            Units: mass/(distance*seconds*seconds)."""
    )
}

